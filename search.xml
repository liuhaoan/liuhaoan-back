<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_抽象类]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_多态]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println(&quot;我&quot;); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(&quot;爱&quot;); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(&quot;你&quot;); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_代码块与继承]]></title>
    <url>%2F2019%2F04%2F06%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——java的五大内存区域]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——数据类型]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——进制编码]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>进制编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
