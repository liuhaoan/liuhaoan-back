<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><script type="text/javascript" src="/js/src/clicklove.js"></script><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,a,i,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,i=t.createElement(o),n=t.getElementsByTagName(o)[0],i.async=1,i.src=c,i.charset="utf-8",n.parentNode.insertBefore(i,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/71c3d6a3.js","daovoice"),daovoice("init",{app_id:"71c3d6a3"}),daovoice("update")</script><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Stream流,JDK8新特性,forEach,"><link rel="alternate" href="/atom.xml" title="Ather · Blog" type="application/atom+xml"><meta name="description" content="Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，它关注的是做什么，而不是怎么做，用于解决已有集合类库所有的弊端"><meta name="keywords" content="Stream流,JDK8新特性,forEach"><meta property="og:type" content="article"><meta property="og:title" content="javaSE复习之——JDK8新特性_Stream流"><meta property="og:url" content="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/index.html"><meta property="og:site_name" content="Ather · Blog"><meta property="og:description" content="Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，它关注的是做什么，而不是怎么做，用于解决已有集合类库所有的弊端"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-04-11T09:09:22.625Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="javaSE复习之——JDK8新特性_Stream流"><meta name="twitter:description" content="Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，它关注的是做什么，而不是怎么做，用于解决已有集合类库所有的弊端"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/"><title>javaSE复习之——JDK8新特性_Stream流 | Ather · Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Ather · Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-大事年表"><a href="/timelines" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 大事年表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atcher"><meta itemprop="description" content><meta itemprop="image" content="/images/logo.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ather · Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">javaSE复习之——JDK8新特性_Stream流</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T15:31:42+08:00">2019-04-11</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE-复习/" itemprop="url" rel="index"><span itemprop="name">JavaSE 复习</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i> 浏览<span class="busuanzi-value" id="busuanzi_value_page_pv"></span> 次</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">8</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><blockquote><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？</p><p>在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个<strong>全新的Stream概念</strong>，它关注的是做什么，而不是怎么做，<strong><code>用于解决已有集合类库所有的弊端</code></strong></p></blockquote><a id="more"></a><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>使用Stream流的方式过滤并且遍历集合<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       <span class="comment">//创建一个List集合,存储姓名</span></span><br><span class="line">       <span class="built_in">List</span>&lt;String&gt; <span class="built_in">list</span> = new ArrayList&lt;&gt;();</span><br><span class="line">       <span class="built_in">list</span>.add(<span class="string">"张无忌"</span>);</span><br><span class="line">       <span class="built_in">list</span>.add(<span class="string">"周芷若"</span>);</span><br><span class="line">       <span class="built_in">list</span>.add(<span class="string">"赵敏"</span>);</span><br><span class="line">       <span class="built_in">list</span>.add(<span class="string">"张强"</span>);</span><br><span class="line">       <span class="built_in">list</span>.add(<span class="string">"张三丰"</span>);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//对list集合中的元素进行过滤,只要以张开头的元素,存储到一个新的集合中</span></span><br><span class="line">       <span class="comment">//对listA集合进行过滤,只要姓名长度为3的人,存储到一个新集合中</span></span><br><span class="line">       <span class="comment">//遍历listB集合</span></span><br><span class="line">       <span class="built_in">list</span>.stream()</span><br><span class="line">           .filter(<span class="built_in">name</span>-&gt;<span class="built_in">name</span>.startsWith(<span class="string">"张"</span>))</span><br><span class="line">           .filter(<span class="built_in">name</span>-&gt;<span class="built_in">name</span>.length()==<span class="number">3</span>)</span><br><span class="line">           .<span class="keyword">forEach</span>(<span class="built_in">name</span>-&gt; System.out.println(<span class="built_in">name</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="流式思想概述"><a href="#流式思想概述" class="headerlink" title="流式思想概述"></a>流式思想概述</h3><blockquote><p>整体来讲，流式思想类似于车间的<code>“生产流水线”</code></p><p>当我们需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能以及遍历性，我们应该首先拼好一个“模型”步骤的方案，然后再去按照这个方案去执行它。</p><p>其实Stream流中的元素是一个特定类型的对象，这个类型由自己定义，可以通过泛型给它，在底层形成一个队列。</p><p>并且在java中Stream并不会储存元素，而是按需计算。它数据源 流的来源可以是集合，数组等</p></blockquote><blockquote><ul><li>ps：<strong>“Stream流”其实是一个<code>集合元素的函数模型</code>，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</strong></li></ul></blockquote><h3 id="使用Stream流的步骤"><a href="#使用Stream流的步骤" class="headerlink" title="使用Stream流的步骤"></a>使用Stream流的步骤</h3><blockquote><p>1、获取一个数据源</p><p>2、数据转换（如何转换、转换成什么自己定义）</p><p>3、获取想要的结果</p><ul><li>ps：每次转换 原有的 Stream 对象不会改变，但是会返回一个新的 Stream 对象（可以有多次转换），这样就可以像链条一样的排列，可以理解为链式编程，也可以理解为linux系统中的 管道 “|” 命令。</li></ul></blockquote><h3 id="获取一个Stream流"><a href="#获取一个Stream流" class="headerlink" title="获取一个Stream流"></a>获取一个Stream流</h3><blockquote><p>java.util.stream.Stream<t>是java 8新加入的最常用的流接口（它不是函数式接口），我们使用Stream流都是通过它</t></p></blockquote><ul><li><p><strong>获取一个Stream流有两种方式</strong></p><blockquote><p>1、所有的Collection 集合都可以通过stream()默认方法获取流</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把集合转换为Stream流</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream1 = <span class="built_in">list</span>.stream();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">set</span> = <span class="literal">new</span> HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream2 = <span class="built_in">set</span>.stream();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//获取键,存储到一个Set集合中</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; keySet = <span class="built_in">map</span>.keySet();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream3 = keySet.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取值,存储到一个Collection集合中</span></span><br><span class="line">Collection&lt;<span class="built_in">String</span>&gt; values = <span class="built_in">map</span>.values();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream4 = values.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取键值对(键与值的映射关系 entrySet)</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt; entries = <span class="built_in">map</span>.entrySet();</span><br><span class="line">Stream&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt; stream5 = entries.stream();</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2、Stream接口中的 “of” 静态方法可以获取<strong>数组</strong>对应的流</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把数组转换为Stream流</span></span><br><span class="line">      Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">//可变参数可以传递数组</span></span><br><span class="line">      Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">      Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">      String[] arr2 = &#123;<span class="string">"a"</span>,<span class="string">"bb"</span>,<span class="string">"ccc"</span>&#125;;</span><br><span class="line">      Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="Stream接口的常用方法"><a href="#Stream接口的常用方法" class="headerlink" title="Stream接口的常用方法"></a>Stream接口的常用方法</h3><h4 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h4><blockquote><p>返回值仍然是Stream接口自身类型对象，所以它支持链式调用</p></blockquote><h6 id="1、过滤：filter"><a href="#1、过滤：filter" class="headerlink" title="1、过滤：filter"></a>1、过滤：filter</h6><blockquote><p>可以通过filter方法将<code>一个流</code>转换成另一个<code>子集流</code><br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="tag">&lt;<span class="name">T</span>&gt;</span> filter(Predicate<span class="php"><span class="meta">&lt;?</span> super T&gt; predicate);</span></span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>它接收一个Predicate函数式接口（可以是一个Lambda或者方法引用），作为筛选条件</p></blockquote><h6 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h6><blockquote><p>它其中有一个抽象方法：test()；</p><p>它会产生一个boolean，代表指定的条件是否满足，满足为true，这样Stream流的filter会留着当前元素，否则就放弃当前元素</p></blockquote><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo07StreamFilter &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; original = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>));</span><br><span class="line">	<span class="comment">//结果：张无忌、张三丰</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、映射：map"><a href="#2、映射：map" class="headerlink" title="2、映射：map"></a>2、映射：map</h6><blockquote><p>如果需要将流中的元素映射到另一个流中，我们就需要使用到map方法<br></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="keyword">Stream&lt;R&gt; </span><span class="meta">map</span>(<span class="meta">Function</span>&lt;? super T, ? extends R&gt; mapper)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>此接口需要一个Function函数式接口的参数，可以把T类型数据转换成R类型数据</p></blockquote><h6 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h6><blockquote><p>它是一个函数式接口，它有一个抽象方法：R apply(T t);<br>它可以把T类型的数据转换为R类型的数据，这样就被称为“映射”</p></blockquote><h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo08StreamMap &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; original = <span class="built_in">Stream</span>.of(<span class="string">"10"</span>, <span class="string">"12"</span>, <span class="string">"18"</span>);</span><br><span class="line">	<span class="comment">//定义一个String类型的数组，然后获取它的Stream流</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Stream</span>&lt;Integer&gt; result = original.<span class="built_in">map</span>(str‐&gt;Integer.<span class="built_in">parseInt</span>(str));</span><br><span class="line">	<span class="comment">//把String类型的Stream流转换成Integer类型的Stream流</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3、取用前几个元素：limit"><a href="#3、取用前几个元素：limit" class="headerlink" title="3、取用前几个元素：limit"></a>3、取用前几个元素：limit</h6><blockquote><p>limit方法可以对流进行截取，只取用前n个,如果集合当前长度大于参数则进行截取,否则不进行操作<br></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="variable">&lt;T&gt;</span> <span class="keyword">limit</span>(long <span class="keyword">max</span>Size);</span><br></pre></td></tr></table></figure><p></p></blockquote><h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo10StreamLimit &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; original = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(result.count()); </span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、跳过前几个元素：skip"><a href="#4、跳过前几个元素：skip" class="headerlink" title="4、跳过前几个元素：skip"></a>4、跳过前几个元素：skip</h6><blockquote><p>流中集合总数大于n才会跳过n个，否则会得到一个长度为0的空流<br></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;T&gt; skip(<span class="keyword">long</span> n);</span><br></pre></td></tr></table></figure><p></p></blockquote><h6 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo11StreamSkip &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; original = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(result.count()); </span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5、组合：concat"><a href="#5、组合：concat" class="headerlink" title="5、组合：concat"></a>5、组合：concat</h6><blockquote><p>如果有两个流想合并成一个流，那么就可以使用concat方法,它是一个静态方法</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;<span class="built_in">T</span>&gt; Stream&lt;<span class="built_in">T</span>&gt; <span class="built_in">concat</span>(Stream&lt;? extends <span class="built_in">T</span>&gt; a, Stream&lt;? extends <span class="built_in">T</span>&gt; b)</span><br></pre></td></tr></table></figure><h6 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo12StreamConcat &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; streamA = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; streamB = <span class="built_in">Stream</span>.of(<span class="string">"张翠山"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; result = <span class="built_in">Stream</span>.concat(streamA, streamB);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h4><blockquote><p>返回的不是Stream接口自身类型对象了，所以不支持链式调用</p></blockquote><h6 id="1、逐一处理：forEach"><a href="#1、逐一处理：forEach" class="headerlink" title="1、逐一处理：forEach"></a>1、逐一处理：forEach</h6><blockquote><p>它虽然叫forEach，但是与for循环中的“for-each”是不同的<br></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><ul><li>该方法接收一个Consumer接口类型的函数，会将每一个流元素交给函数进行处理</li></ul></blockquote><h6 id="什么是Consumer接口？"><a href="#什么是Consumer接口？" class="headerlink" title="什么是Consumer接口？"></a>什么是Consumer接口？</h6><blockquote><p>它是一个消费型接口<br>接口中有一个抽象方法：accept(),它的意思是消费一个指定的泛型数据</p></blockquote><h6 id="例子，遍历流中的数据"><a href="#例子，遍历流中的数据" class="headerlink" title="例子，遍历流中的数据"></a>例子，遍历流中的数据</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo12StreamForEach &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stream = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	<span class="comment">//从数组中获取Stream流</span></span><br><span class="line"></span><br><span class="line">	stream.forEach(name‐&gt; System.out.<span class="built_in">println</span>(name));</span><br><span class="line">	<span class="comment">//利用forEach逐一处理Stream流中的每个数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、统计个数：count"><a href="#2、统计个数：count" class="headerlink" title="2、统计个数：count"></a>2、统计个数：count</h6><blockquote><p>正如Collection集合中的size方法一样，count它是数一数Stream流中的元素个数，<code>它返回一个long类型数据</code></p></blockquote><h6 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.<span class="built_in">Stream</span>;</span><br><span class="line"><span class="keyword">public</span> class Demo09StreamCount &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; original = <span class="built_in">Stream</span>.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">	<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>));</span><br><span class="line">	System.out.<span class="built_in">println</span>(result.count()); </span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream流的特点"><a href="#Stream流的特点" class="headerlink" title="Stream流的特点"></a>Stream流的特点</h3><ul><li>Stream流属于管道流，只能被消费（使用）一次<blockquote><p>第一个Stream流调用完方法后，数据就会被流转到下一个Stream上<br>这时第一个Stream流已经使用完毕了，就会关闭了<br>所以第一个Stream流就不能再调用方法了<br>可以想象成一个流水线，它是一直流下去的，流下去就没了嘛。</p></blockquote></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2019/04/11/javaSE复习之——JDK8新特性-Stream流/">javaSE复习之——JDK8新特性_Stream流</a></p><p><span>文章作者:</span><a href="/" title="访问 Atcher 的个人博客">Atcher</a></p><p><span>发布时间:</span>2019年04月11日 - 15:04</p><p><span>最后更新:</span>2019年04月11日 - 17:04</p><p><span>原始链接:</span><a href="/2019/04/11/javaSE复习之——JDK8新特性-Stream流/" title="javaSE复习之——JDK8新特性_Stream流">http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt="Atcher 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt="Atcher 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Stream流/" rel="tag"><i class="fa fa-tag"></i> Stream流</a><a href="/tags/JDK8新特性/" rel="tag"><i class="fa fa-tag"></i> JDK8新特性</a><a href="/tags/forEach/" rel="tag"><i class="fa fa-tag"></i> forEach</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/04/11/javaSE复习之——Junit单元测试/" rel="next" title="javaSE复习之——Junit单元测试"><i class="fa fa-chevron-left"></i> javaSE复习之——Junit单元测试</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/04/11/javaSE复习之——JDK8新特性-Stream流练习/" rel="prev" title="javaSE复习之——JDK8新特性_Stream流练习">javaSE复习之——JDK8新特性_Stream流练习<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="Atcher"><p class="site-author-name" itemprop="name">Atcher</p><p class="site-description motion-element" itemprop="description">知其然知其所以然</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yourname" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/63445e24e8bf" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span><span class="links-of-author-item"><a href="https://juejin.im/user/5a371ae551882512d0607108" target="_blank" title="掘金"><i class="fa fa-fw fa-spinner"></i> 掘金</a></span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("04/05/2019 12:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream流"><span class="nav-number">1.</span> <span class="nav-text">Stream流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#案例"><span class="nav-number">1.0.1.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流式思想概述"><span class="nav-number">1.0.2.</span> <span class="nav-text">流式思想概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Stream流的步骤"><span class="nav-number">1.0.3.</span> <span class="nav-text">使用Stream流的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取一个Stream流"><span class="nav-number">1.0.4.</span> <span class="nav-text">获取一个Stream流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream接口的常用方法"><span class="nav-number">1.0.5.</span> <span class="nav-text">Stream接口的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟方法"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">延迟方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、过滤：filter"><span class="nav-number">1.0.5.1.0.1.</span> <span class="nav-text">1、过滤：filter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Predicate接口"><span class="nav-number">1.0.5.1.0.2.</span> <span class="nav-text">Predicate接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子"><span class="nav-number">1.0.5.1.0.3.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、映射：map"><span class="nav-number">1.0.5.1.0.4.</span> <span class="nav-text">2、映射：map</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Function接口"><span class="nav-number">1.0.5.1.0.5.</span> <span class="nav-text">Function接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子-1"><span class="nav-number">1.0.5.1.0.6.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、取用前几个元素：limit"><span class="nav-number">1.0.5.1.0.7.</span> <span class="nav-text">3、取用前几个元素：limit</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子-2"><span class="nav-number">1.0.5.1.0.8.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、跳过前几个元素：skip"><span class="nav-number">1.0.5.1.0.9.</span> <span class="nav-text">4、跳过前几个元素：skip</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子-3"><span class="nav-number">1.0.5.1.0.10.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5、组合：concat"><span class="nav-number">1.0.5.1.0.11.</span> <span class="nav-text">5、组合：concat</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子-4"><span class="nav-number">1.0.5.1.0.12.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终结方法"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">终结方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、逐一处理：forEach"><span class="nav-number">1.0.5.2.0.1.</span> <span class="nav-text">1、逐一处理：forEach</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#什么是Consumer接口？"><span class="nav-number">1.0.5.2.0.2.</span> <span class="nav-text">什么是Consumer接口？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子，遍历流中的数据"><span class="nav-number">1.0.5.2.0.3.</span> <span class="nav-text">例子，遍历流中的数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、统计个数：count"><span class="nav-number">1.0.5.2.0.4.</span> <span class="nav-text">2、统计个数：count</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#例子-5"><span class="nav-number">1.0.5.2.0.5.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream流的特点"><span class="nav-number">1.0.6.</span> <span class="nav-text">Stream流的特点</span></a></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Atcher</span></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共50.8k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i> 访问总量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script></body></html>