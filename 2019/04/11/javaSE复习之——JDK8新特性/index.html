<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><script type="text/javascript" src="/js/src/clicklove.js"></script><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,a,i,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,i=t.createElement(o),n=t.getElementsByTagName(o)[0],i.async=1,i.src=c,i.charset="utf-8",n.parentNode.insertBefore(i,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/71c3d6a3.js","daovoice"),daovoice("init",{app_id:"71c3d6a3"}),daovoice("update")</script><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="JDK8新特性,函数式编程,函数式接口,"><link rel="alternate" href="/atom.xml" title="Ather · Blog" type="application/atom+xml"><meta name="description" content="JDK8新特性总汇 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理     接口的默认方法和静态方法 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写"><meta name="keywords" content="JDK8新特性,函数式编程,函数式接口"><meta property="og:type" content="article"><meta property="og:title" content="javaSE复习之——JDK8新特性"><meta property="og:url" content="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/index.html"><meta property="og:site_name" content="Ather · Blog"><meta property="og:description" content="JDK8新特性总汇 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理     接口的默认方法和静态方法 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-04-11T07:19:15.622Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="javaSE复习之——JDK8新特性"><meta name="twitter:description" content="JDK8新特性总汇 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理     接口的默认方法和静态方法 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/"><title>javaSE复习之——JDK8新特性 | Ather · Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Ather · Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-大事年表"><a href="/timelines" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 大事年表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atcher"><meta itemprop="description" content><meta itemprop="image" content="/images/logo.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ather · Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">javaSE复习之——JDK8新特性</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T14:46:00+08:00">2019-04-11</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE-复习/" itemprop="url" rel="index"><span itemprop="name">JavaSE 复习</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i> 浏览<span class="busuanzi-value" id="busuanzi_value_page_pv"></span> 次</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">7</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JDK8新特性总汇"><a href="#JDK8新特性总汇" class="headerlink" title="JDK8新特性总汇"></a>JDK8新特性总汇</h1><ul><li>Lambda表达式和函数式接口<blockquote><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理</p></blockquote></li></ul><ul><li>接口的默认方法和静态方法<blockquote><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写</p></blockquote></li></ul><a id="more"></a><ul><li>方法引用</li></ul><ul><li>重复注解<blockquote><p>自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解</p></blockquote></li></ul><ul><li>更好的类型推断<blockquote><p>就是创建有泛型类的对象时，后面不用写类型</p></blockquote></li></ul><ul><li>拓宽注解的应用场景<blockquote><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。</p></blockquote></li></ul><ul><li>Stream流<blockquote><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？</p><p>在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库所有的弊端</p></blockquote></li></ul><h1 id="在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了"><a href="#在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了" class="headerlink" title="在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了"></a>在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了</h1><ul><li>例子：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Inter <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	public default void print（） &#123;</span></span><br><span class="line"><span class="comment">		System.out.println("hello")</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">		System.out.print("static Method")</span></span></span><br><span class="line"><span class="function"><span class="comment">	&#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1-8版本之前是一定要用final修饰的"><a href="#在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1-8版本之前是一定要用final修饰的" class="headerlink" title="在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1.8版本之前是一定要用final修饰的"></a>在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1.8版本之前是一定要用final修饰的</h1><ul><li><p>ps：</p><blockquote><p>其实这就是一个语法糖，底层它还是用final修饰了的</p></blockquote></li><li><p>为什么需要使用final修饰？</p><blockquote><p>答：</p><p>因为不用final修饰可能出现数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。<br>ps：底层详情参考<a href="/2019/04/08/javaSE复习之——面向对象-内部类/">javaSE复习之——面向对象_内部类</a></p><p>数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因</p></blockquote></li></ul><h1 id="函数式-接口-的概述"><a href="#函数式-接口-的概述" class="headerlink" title="函数式 接口 的概述"></a>函数式 接口 的概述</h1><blockquote><p><code>它有且只有一个抽象方法的接口</code>，它适用于函数式编程，也就是函数式接口就是适用于lambda使用的接口，只有确保接口中有且只有一个抽象方法，java中的lambda才能顺利的推导</p></blockquote><h1 id="函数式-编程-的概述"><a href="#函数式-编程-的概述" class="headerlink" title="函数式 编程 的概述"></a>函数式 编程 的概述</h1><blockquote><p>就是使用lambda编程</p></blockquote><ul><li>PS：<blockquote><p>“语法糖”是指使用更加方便，但是原理不变的代码语法。例如遍历集合时使用的for-each语法，其实底层实现原理是迭代器，这就是“语法糖”。从应用层面来讲，java中的Lambda可以被当做是匿名内部类的“语法糖”，<strong>但是二者在原理上是不同的</strong></p></blockquote></li></ul><h3 id="函数式接口的定义："><a href="#函数式接口的定义：" class="headerlink" title="函数式接口的定义："></a>函数式接口的定义：</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称 （可选参数信息）；</span><br><span class="line">	<span class="comment">//其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：接口中的抽象方法的 public abstract 是可以省略的</p><h3 id="函数式接口的特点："><a href="#函数式接口的特点：" class="headerlink" title="函数式接口的特点："></a>函数式接口的特点：</h3><ul><li>它有且只有一个抽象方法的 接口</li><li>函数式接口可以包含其他的方法，</li><li></li><li>比如<blockquote><p>默认、静态、私有</p></blockquote></li></ul><h3 id="正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？"><a href="#正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？" class="headerlink" title="正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？"></a>正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？</h3><ul><li>答<blockquote><p>使用@FunctionalInterface注解，它的作用是检测接口是否是一个函数式接口</p><ul><li><p>是<br>编译成功</p></li><li><p>否<br>编译失败<br>1、接口中没有抽象方法<br>2、抽象方法有多个</p></li></ul></blockquote></li></ul><h3 id="函数式接口的使用"><a href="#函数式接口的使用" class="headerlink" title="函数式接口的使用"></a>函数式接口的使用</h3><ul><li><p>作为方法的参数 和 返回值类型</p><ul><li><p>例子：</p><ul><li><p>作为参数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法，参数使用函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> show（MyInterface myInterface）&#123;</span><br><span class="line">	myInterface.method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法中调用：其实它重写了method方法，结果是打印hello</span></span><br><span class="line">show(() -&gt; Sysytem.out.<span class="built_in">println</span>(<span class="string">"hello"</span>))</span><br></pre></td></tr></table></figure></li><li><p>作为返回值类型：</p><blockquote><p>如果返回值类型是函数式接口，那么我们可以返回匿名内部类，当然也可以返回一个lambda</p></blockquote></li></ul></li></ul></li></ul><h3 id="常用的函数式接口（使用方法同理）"><a href="#常用的函数式接口（使用方法同理）" class="headerlink" title="常用的函数式接口（使用方法同理）"></a>常用的函数式接口（使用方法同理）</h3><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><blockquote><p>它包含一个无参的方法，T get（）。用来获取一个泛型参数指定类型的数据对象，它被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会产生一个什么类型的数据</p><ul><li>例子：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> getString(Supplier&lt;<span class="keyword">String</span>&gt; sup) &#123;</span><br><span class="line">	<span class="built_in">return</span> sup.<span class="built_in">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">String</span> s = getString(() -&gt; <span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="Consumer接口："><a href="#Consumer接口：" class="headerlink" title="Consumer接口："></a>Consumer接口：</h4><blockquote><p>Consumer接口正好与Supplier接口相反，它不是产生一个数据，而是消费一个数据，数据类型由泛型决定，它的抽象方法中有一个 void accept（T，t）意为消费一个指定泛型的数据</p></blockquote><ul><li>Consumer接口和Supplier接口的区别：<blockquote><p>1、Consumer是消费<br>2、Supplier是生产</p></blockquote></li></ul><ul><li>什么是消费和生产：<ul><li>消费：<blockquote><p>我们传入一个变量供accept方法使用</p></blockquote></li><li>生产：<blockquote><p>我们利用lambda重写get方法，然后获取一个自己想要的值</p></blockquote></li></ul></li></ul><ul><li><p>默认方法：andThen</p><ul><li><p>作用：</p><blockquote><p>需要两个Consumer接口，可以吧两个Consumer接口组合到一起，再对数据进行消费</p><p>例如：<br>我们要把s变量消费两次，这样写代码就重复了</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con1</span><br><span class="line">Consumer&lt;String&gt; con2</span><br><span class="line">String s = <span class="string">"hello"</span><span class="comment">;</span></span><br><span class="line">con1.accept(s)<span class="comment">;</span></span><br><span class="line">con2.accept(s)<span class="comment">;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>我们可以这样（下面这段语句和上面是一样的效果）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">con1</span><span class="selector-class">.andThen</span>(<span class="selector-tag">con2</span>)<span class="selector-class">.accept</span>(<span class="selector-tag">s</span>);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>ps：这样就实现了组合消费</strong><br><strong>注意：谁写在前面谁先消费</strong></p></blockquote></li></ul></li></ul><h4 id="Predicate接口："><a href="#Predicate接口：" class="headerlink" title="Predicate接口："></a><strong>Predicate接口：</strong></h4><blockquote><p>我们有时候需要对某种数据类型的数据进行判断，从而得到一个Boolean值得结果，我们就可以用到Predicate接口</p></blockquote><ul><li><p>Predicate接口中的方法：</p><ul><li>抽象方法：<strong>test</strong><blockquote><p>用于条件判断</p></blockquote></li><li><p>默认方法：<strong>and（&amp;&amp;与）</strong></p><blockquote><p>可以连接多个判断条件</p></blockquote></li><li><p>默认方法：<strong>or（或）</strong></p><blockquote><p>可以连接多个判断条件</p></blockquote></li><li><p>默认方法：<strong>negate（非，取反）</strong></p><blockquote><p>可以连接多个判断条件</p></blockquote></li></ul></li><li>例子：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> checkString(<span class="keyword">String</span> s, Predicate&lt;<span class="keyword">String</span>&gt; pre1,Predicate&lt;<span class="keyword">String</span>&gt; pre2)&#123;</span><br><span class="line">    <span class="built_in">return</span> pre1.<span class="keyword">and</span>(pre2).test(s);</span><br><span class="line"><span class="comment">//等价于return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Function接口："><a href="#Function接口：" class="headerlink" title="Function接口："></a><strong>Function接口：</strong></h4><blockquote><p>根据一个类型的数据，得到另一个类型的数据，前者为前置条件，后者为后置条件</p></blockquote><ul><li><p>Function接口中的方法：</p><ul><li><p>抽象方法：<strong>R apply（T t）</strong></p><blockquote><p>根据类型T的参数获取类型R的结果，返回一个R类型数据</p></blockquote></li><li><p>默认方法：<strong>andThen</strong></p><blockquote><p>用来进行组合操作，不过它与Consumer接口中的方法区别是，它执行完主方法后，可以把主方法中的的结果传给副方法</p></blockquote></li><li><p>比如：<strong>fun1.andThen(fun2).apply(s)</strong></p><blockquote><p>其中s是String类型，fun1是把String转int，fun2是int转String</p></blockquote></li><li><p>实例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Change</span> &#123;</span></span><br><span class="line"><span class="class">    public <span class="type">String</span> change(<span class="type">String</span> <span class="title">s</span>, <span class="type">Function</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; <span class="title">fun1</span>, <span class="type">Function</span>&lt;<span class="type">Integer</span>, <span class="type">String</span>&gt; <span class="title">fun2</span>) &#123;</span></span><br><span class="line"><span class="class">        return fun1.andThen(<span class="title">fun2</span>).apply(<span class="title">s</span>);</span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>main方法调用：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="keyword">new</span> Change().change(<span class="string">"100"</span>, s -&gt; <span class="built_in">Integer</span>.parseInt(s) + <span class="number">10</span>, <span class="built_in">integer</span> -&gt; <span class="built_in">integer</span> + <span class="string">""</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(str);</span><br></pre></td></tr></table></figure></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2019/04/11/javaSE复习之——JDK8新特性/">javaSE复习之——JDK8新特性</a></p><p><span>文章作者:</span><a href="/" title="访问 Atcher 的个人博客">Atcher</a></p><p><span>发布时间:</span>2019年04月11日 - 14:04</p><p><span>最后更新:</span>2019年04月11日 - 15:04</p><p><span>原始链接:</span><a href="/2019/04/11/javaSE复习之——JDK8新特性/" title="javaSE复习之——JDK8新特性">http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt="Atcher 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt="Atcher 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JDK8新特性/" rel="tag"><i class="fa fa-tag"></i> JDK8新特性</a><a href="/tags/函数式编程/" rel="tag"><i class="fa fa-tag"></i> 函数式编程</a><a href="/tags/函数式接口/" rel="tag"><i class="fa fa-tag"></i> 函数式接口</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/04/11/javaSE复习之——Lambda表达式/" rel="next" title="javaSE复习之——Lambda表达式"><i class="fa fa-chevron-left"></i> javaSE复习之——Lambda表达式</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/04/11/javaSE复习之——JDK9新特性/" rel="prev" title="javaSE复习之——JDK9新特性">javaSE复习之——JDK9新特性<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="Atcher"><p class="site-author-name" itemprop="name">Atcher</p><p class="site-description motion-element" itemprop="description">知其然知其所以然</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yourname" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/63445e24e8bf" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span><span class="links-of-author-item"><a href="https://juejin.im/user/5a371ae551882512d0607108" target="_blank" title="掘金"><i class="fa fa-fw fa-spinner"></i> 掘金</a></span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("04/05/2019 12:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK8新特性总汇"><span class="nav-number">1.</span> <span class="nav-text">JDK8新特性总汇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了"><span class="nav-number">2.</span> <span class="nav-text">在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1-8版本之前是一定要用final修饰的"><span class="nav-number">3.</span> <span class="nav-text">在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1.8版本之前是一定要用final修饰的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式-接口-的概述"><span class="nav-number">4.</span> <span class="nav-text">函数式 接口 的概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式-编程-的概述"><span class="nav-number">5.</span> <span class="nav-text">函数式 编程 的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式接口的定义："><span class="nav-number">5.0.1.</span> <span class="nav-text">函数式接口的定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式接口的特点："><span class="nav-number">5.0.2.</span> <span class="nav-text">函数式接口的特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？"><span class="nav-number">5.0.3.</span> <span class="nav-text">正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式接口的使用"><span class="nav-number">5.0.4.</span> <span class="nav-text">函数式接口的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的函数式接口（使用方法同理）"><span class="nav-number">5.0.5.</span> <span class="nav-text">常用的函数式接口（使用方法同理）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Supplier接口"><span class="nav-number">5.0.5.1.</span> <span class="nav-text">Supplier接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer接口："><span class="nav-number">5.0.5.2.</span> <span class="nav-text">Consumer接口：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate接口："><span class="nav-number">5.0.5.3.</span> <span class="nav-text">Predicate接口：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function接口："><span class="nav-number">5.0.5.4.</span> <span class="nav-text">Function接口：</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Atcher</span></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共51.7k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i> 访问总量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script></body></html>