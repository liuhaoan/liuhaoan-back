<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><script type="text/javascript" src="/js/src/clicklove.js"></script><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,a,i,n){e.DaoVoiceObject=a,e[a]=e[a]||function(){(e[a].q=e[a].q||[]).push(arguments)},e[a].l=1*new Date,i=t.createElement(o),n=t.getElementsByTagName(o)[0],i.async=1,i.src=c,i.charset="utf-8",n.parentNode.insertBefore(i,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/71c3d6a3.js","daovoice"),daovoice("init",{app_id:"71c3d6a3"}),daovoice("update")</script><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="IO流,文件字节流,标准异常处理代码（面试会用到，背都要背下来）,"><link rel="alternate" href="/atom.xml" title="Ather · Blog" type="application/atom+xml"><meta name="description" content="FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类  创建一个文件输入流12FileInputStream fis = new FileInputStream(&quot;1.txt&quot;);//其实就是创建一个流的对象，不用了关闭即可"><meta name="keywords" content="IO流,文件字节流,标准异常处理代码（面试会用到，背都要背下来）"><meta property="og:type" content="article"><meta property="og:title" content="javaSE复习之——IO流_文件字节流"><meta property="og:url" content="http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/index.html"><meta property="og:site_name" content="Ather · Blog"><meta property="og:description" content="FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类  创建一个文件输入流12FileInputStream fis = new FileInputStream(&quot;1.txt&quot;);//其实就是创建一个流的对象，不用了关闭即可"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-04-10T07:59:36.745Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="javaSE复习之——IO流_文件字节流"><meta name="twitter:description" content="FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类  创建一个文件输入流12FileInputStream fis = new FileInputStream(&quot;1.txt&quot;);//其实就是创建一个流的对象，不用了关闭即可"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/"><title>javaSE复习之——IO流_文件字节流 | Ather · Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Ather · Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-大事年表"><a href="/timelines" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 大事年表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atcher"><meta itemprop="description" content><meta itemprop="image" content="/images/logo.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ather · Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">javaSE复习之——IO流_文件字节流</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T15:14:55+08:00">2019-04-10</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE-复习/" itemprop="url" rel="index"><span itemprop="name">JavaSE 复习</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i> 浏览<span class="busuanzi-value" id="busuanzi_value_page_pv"></span> 次</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2.2k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">8</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="FileInputStream概述"><a href="#FileInputStream概述" class="headerlink" title="FileInputStream概述"></a>FileInputStream概述</h1><blockquote><p>它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是<code>InputStream</code>的子类</p></blockquote><h3 id="创建一个文件输入流"><a href="#创建一个文件输入流" class="headerlink" title="创建一个文件输入流"></a>创建一个文件输入流</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"1.txt"</span>);</span><br><span class="line"><span class="comment">//其实就是创建一个流的对象，不用了关闭即可</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="IO文件输入流的方法"><a href="#IO文件输入流的方法" class="headerlink" title="IO文件输入流的方法"></a>IO文件输入流的方法</h3><ul><li>.read()<blockquote><p>从输入流读取下一个字节返回这个字节的int值，文件结束标记是-1，也就是读到-1就读完这个文件了。</p></blockquote></li><li>.read(arr)<blockquote><p>从输入流读取字节存到arr数组中，也就是内存中，返回读取到的字节数</p></blockquote></li><li>.available()<blockquote><p>获取可以读的剩余字节数</p></blockquote></li></ul><h3 id="为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？"><a href="#为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？" class="headerlink" title="为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？"></a>为什么<code>read（）</code>方法读取一个字节返回的是int而不是字节类型的byte？</h3><ul><li>解答：<blockquote><p>一个字节等于8个二进制位，也就是<code>-1的二进制位补码是1111 1111</code>，然后文件的底层都是以二进制形式存储的，这些文件的二进制中难免中途会遇到某个字节是1111 1111（八个一），如果read方法直接返回byte的话那么遇到这种情况就直接停止读取文件了，为了解决这个问题就直接返回int而不直接返回byte，因为在Java中一个int数据占4个字节，<code>也就是占32个二进制位</code>，而read方法中从文件读取一个字节就在其<code>二进制位前面加上24个0让其组成一个int类型数据返回</code>，这样就返回了一个255而不是返回1了，这样就可以保证数据的完整，而文件结束标记的-1它本身就是整数型所以不会受到影响。当然在使用输出流输出文件时write方法会<code>自动去除int前面的24个零</code>。</p></blockquote></li></ul><h1 id="FileOutputStream的概述"><a href="#FileOutputStream的概述" class="headerlink" title="FileOutputStream的概述"></a>FileOutputStream的概述</h1><blockquote><p>它是一个输出流，它的作用将指定字节写入此文件输出流，它是OutputStream的子类</p></blockquote><h3 id="输出流注意事项"><a href="#输出流注意事项" class="headerlink" title="输出流注意事项"></a>输出流注意事项</h3><blockquote><p>1、输入流指定的文件不存在会报错，而输出流却不会，它是直接创建这个文件</p><p>2、虽然写出的是一个int类型的数据，但其实write方法会自动去除int数据的前3个8位2进制位</p><p>3、如果文件存在，那么就会先将文件内容清空，如果不要让他清空要追加，那么就在创建对象时第二个参数传入一个true</p><ul><li>例子：<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"1.txt"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="IO文件输出流的方法"><a href="#IO文件输出流的方法" class="headerlink" title="IO文件输出流的方法"></a>IO文件输出流的方法</h3><ul><li>.write()<blockquote><p>将指定字节写入此文件输出流</p></blockquote></li><li>.write(arr)<blockquote><p>将arr数组中的字节写到文件中</p></blockquote></li><li>.write(arr, off, len)<blockquote><p>off为数组起始偏移量，也就是起始索引，通常0、len就是要写入数据的总长度</p></blockquote></li></ul><h3 id="利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）"><a href="#利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）" class="headerlink" title="利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）"></a>利用IO流进行文件拷贝例程之——<code>缓冲区拷贝</code>（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int len = fis.available();</span></span><br><span class="line"><span class="comment">//System.out.println(len);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.<span class="built_in">available</span>()];</span><br><span class="line"><span class="comment">//创建与文件一样大小的字节数组</span></span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">read</span>(arr);</span><br><span class="line"><span class="comment">//将文件上的字节读取到内存中</span></span><br><span class="line"></span><br><span class="line">fos.<span class="built_in">write</span>(arr);</span><br><span class="line"><span class="comment">//将字节数组中的字节数据写到文件上</span></span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">close</span>();</span><br><span class="line">fos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>ps：不推荐使用，因为一次性把所有字节都读下来放在内存中会导致占用内存过多，如果操作的是一个蓝光电影，就会<code>内存溢出</code>。</p><ul><li>解决方法：<blockquote><p>一次处理一部分数据，分批次处理即可，代码如下</p></blockquote></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line"><span class="comment">//缓冲区一定要为1024的整数倍</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="built_in">while</span> ((len = fis.<span class="built_in">read</span>(b)) != <span class="number">-1</span>) &#123;</span><br><span class="line">          fos.<span class="built_in">write</span>(b, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="利用IO流进行文件拷贝例程二之——普通拷贝"><a href="#利用IO流进行文件拷贝例程二之——普通拷贝" class="headerlink" title="利用IO流进行文件拷贝例程二之——普通拷贝"></a>利用IO流进行文件拷贝例程二之——<code>普通拷贝</code></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//在不断的读取每一个字节</span></span><br><span class="line"><span class="built_in">while</span>((b = fis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">	fos.<span class="built_in">write</span>(b);</span><br><span class="line">	<span class="comment">//将每一个字节写出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//关流释放资源</span></span><br><span class="line">fos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>ps：他有个缺点，那就是效率非常的慢，因为需要一个字节一个字节的读然后写。</p><h3 id="利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝"><a href="#利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝" class="headerlink" title="利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝"></a>利用IO流进行文件拷贝例程三之——<code>BufferedInputStream和BufferOutputStream拷贝</code></h3><blockquote><p>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，<br>这是加入了数组这样的缓冲区效果，java本身在设计的时候，<br>也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流</p></blockquote><ul><li>BufferedInputStream<blockquote><p>BufferedInputStream内置了一个缓冲区(数组)<br>从<code>BufferedInputStream</code>中读取一个字节时<br><code>BufferedInputStream</code>会一次性从文件中读取8192个, 存在缓冲区中<br>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取<br>直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个</p></blockquote></li><li>BufferedOutputStream<blockquote><p><code>BufferedOutputStream</code>也内置了一个缓冲区(数组)<br>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中<br>直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</p></blockquote></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建文件输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="comment">//创建缓冲区对fis装饰</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"><span class="comment">//创建缓冲区对fos装饰</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="built_in">while</span>((b = bis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">	bos.<span class="built_in">write</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bis.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//只关装饰后的对象即可</span></span><br><span class="line">bos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="flush和close的区别"><a href="#flush和close的区别" class="headerlink" title="flush和close的区别"></a>flush和close的区别</h3><blockquote><p>1、flush只是刷新缓冲区，后面还可以写（默认缓冲区存满放到文件，为了拷贝文件的完整性，拷贝完之后一定要刷新缓冲区，缓冲区也就是那个数组）</p><ul><li>ps：<br>一般用带Buffered的IO文件流才用的到，自己创建缓冲区每次都存到文件里去了。</li></ul></blockquote><blockquote><p>2、close是关闭流，不过在关闭流之前会刷新一便缓冲区，关闭后不能写。</p></blockquote><h3 id="使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别"><a href="#使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别" class="headerlink" title="使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别"></a>使用<code>jdk封装好的带Buffered的字节流类</code>与<code>手动创建字节缓冲区</code><strong>效率</strong>的区别</h3><blockquote><p>1、带Buffered的封装类实现文件复制会有<code>两个缓冲区</code><br>ps:BufferedReader是先将数据抓取到<code>内存的缓冲区</code>再<code>从缓冲区中读取字节或数组</code>，操作的是Buffer里的数据（非底层硬盘的数据）</p><p>2、自己手动创建缓冲区的话有<code>一个缓冲区就能实现文件复制</code></p><p>3、但是两个缓冲区都是再<code>内存中</code>的，所以他们之间的赋值对效率<code>不会有很大影响</code></p><p>4、得出结论：手动创建缓冲区比Buffered封装类效率<code>相对高一点点</code></p></blockquote><h3 id="1-6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）"><a href="#1-6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）" class="headerlink" title="1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）"></a><strong>1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）</strong></h3><ul><li>try finally嵌套<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">	fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">while</span>((b = fis.<span class="keyword">read</span>()) != -<span class="number">1</span>) &#123;</span><br><span class="line">		fos.<span class="keyword">write</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(fis != <span class="keyword">null</span>)</span><br><span class="line">			fis.close();				<span class="comment">//能关掉一个算一个</span></span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(fos != <span class="keyword">null</span>)</span><br><span class="line">			fos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7版本新特性之异常处理的标准代码："><a href="#1-7版本新特性之异常处理的标准代码：" class="headerlink" title="1.7版本新特性之异常处理的标准代码："></a>1.7版本新特性之异常处理的标准代码：</h3><ul><li><p>新特性：</p><blockquote><p>在try后接一个小括号，我们把流对象写在小括号内，程序运行完之后自动关闭流</p></blockquote></li><li><p>为什么会自动关闭流？</p><blockquote><p>因为，FileInputStream 与 FileOutputStream 类都实现了AutoCloseable接口，当然我们自己写个类然后重写close方法也能实现自动关闭</p></blockquote></li><li><p>注意事项：</p><blockquote><p>在开发中用到的不多，但是要知道，因为面试肯能会遇到。</p></blockquote></li></ul><ul><li>try close<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span>(</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">	MyClose mc = <span class="keyword">new</span> MyClose();</span><br><span class="line">)&#123;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">while</span>((b = fis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">		fos.<span class="built_in">write</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展知识之——文件加密"><a href="#拓展知识之——文件加密" class="headerlink" title="拓展知识之——文件加密"></a>拓展知识之——文件加密</h3><ul><li>原理<blockquote><p>我们知道2 ^ 3 = 1这是个异或运算也就是0010 ^ 0011 = 0001.</p><p>那么我们就可以</p><p><code>源数据 ^ 密文 = 加密后的数据</code><br><code>加密后的数据 ^ 密文 = 源数据</code></p><p>通过异或这个原理，我们可以知道用<code>相同数异或两编，那么原来的数就会回来</code>，这样我们就可以再写出字节流时，把写出的数据进行一遍异或运算，这样就达到了加密的效果，解密就是读取的时候再异或<strong><code>同样的数</code></strong>，这样原来的数据就回来了，不过这样加密数据为了代码更加简洁就需要使用Buffered的字节流对象，不能自己创建缓冲区了。</p></blockquote></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2019/04/10/javaSE复习之——IO流-文件字节流/">javaSE复习之——IO流_文件字节流</a></p><p><span>文章作者:</span><a href="/" title="访问 Atcher 的个人博客">Atcher</a></p><p><span>发布时间:</span>2019年04月10日 - 15:04</p><p><span>最后更新:</span>2019年04月10日 - 15:04</p><p><span>原始链接:</span><a href="/2019/04/10/javaSE复习之——IO流-文件字节流/" title="javaSE复习之——IO流_文件字节流">http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt="Atcher 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt="Atcher 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/IO流/" rel="tag"><i class="fa fa-tag"></i> IO流</a><a href="/tags/文件字节流/" rel="tag"><i class="fa fa-tag"></i> 文件字节流</a><a href="/tags/标准异常处理代码（面试会用到，背都要背下来）/" rel="tag"><i class="fa fa-tag"></i> 标准异常处理代码（面试会用到，背都要背下来）</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/04/10/javaSE复习之——IO流的概念/" rel="next" title="javaSE复习之——IO流的概念"><i class="fa fa-chevron-left"></i> javaSE复习之——IO流的概念</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/04/10/javaSE复习之——IO流-字符流/" rel="prev" title="javaSE复习之——IO流_字符流">javaSE复习之——IO流_字符流<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="Atcher"><p class="site-author-name" itemprop="name">Atcher</p><p class="site-description motion-element" itemprop="description">知其然知其所以然</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">137</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yourname" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/63445e24e8bf" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span><span class="links-of-author-item"><a href="https://juejin.im/user/5a371ae551882512d0607108" target="_blank" title="掘金"><i class="fa fa-fw fa-spinner"></i> 掘金</a></span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("04/05/2019 12:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#FileInputStream概述"><span class="nav-number">1.</span> <span class="nav-text">FileInputStream概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个文件输入流"><span class="nav-number">1.0.1.</span> <span class="nav-text">创建一个文件输入流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO文件输入流的方法"><span class="nav-number">1.0.2.</span> <span class="nav-text">IO文件输入流的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？"><span class="nav-number">1.0.3.</span> <span class="nav-text">为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#FileOutputStream的概述"><span class="nav-number">2.</span> <span class="nav-text">FileOutputStream的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输出流注意事项"><span class="nav-number">2.0.1.</span> <span class="nav-text">输出流注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO文件输出流的方法"><span class="nav-number">2.0.2.</span> <span class="nav-text">IO文件输出流的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）"><span class="nav-number">2.0.3.</span> <span class="nav-text">利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用IO流进行文件拷贝例程二之——普通拷贝"><span class="nav-number">2.0.4.</span> <span class="nav-text">利用IO流进行文件拷贝例程二之——普通拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝"><span class="nav-number">2.0.5.</span> <span class="nav-text">利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flush和close的区别"><span class="nav-number">2.0.6.</span> <span class="nav-text">flush和close的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别"><span class="nav-number">2.0.7.</span> <span class="nav-text">使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）"><span class="nav-number">2.0.8.</span> <span class="nav-text">1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7版本新特性之异常处理的标准代码："><span class="nav-number">2.0.9.</span> <span class="nav-text">1.7版本新特性之异常处理的标准代码：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓展知识之——文件加密"><span class="nav-number">2.0.10.</span> <span class="nav-text">拓展知识之——文件加密</span></a></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Atcher</span></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共45.5k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i> 访问总量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script></body></html>