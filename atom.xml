<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ather · Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuhaoan.github.io/"/>
  <updated>2019-04-07T07:22:08.841Z</updated>
  <id>http://liuhaoan.github.io/</id>
  
  <author>
    <name>Atcher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaSE复习之——面向对象_代码块与继承</title>
    <link href="http://liuhaoan.github.io/2019/04/06/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://liuhaoan.github.io/2019/04/06/javaSE复习之——面向对象-代码块与继承/</id>
    <published>2019-04-06T02:08:03.000Z</published>
    <updated>2019-04-07T07:22:08.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、静态方法与静态变量"><a href="#一、静态方法与静态变量" class="headerlink" title="一、静态方法与静态变量"></a>一、静态方法与静态变量</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象</li></ul><h2 id="如何防止创建本类对象？"><a href="#如何防止创建本类对象？" class="headerlink" title="如何防止创建本类对象？"></a>如何防止创建本类对象？</h2><ul><li>可以直接私有构造方法<br>  <code>private 类名（）{}</code></li></ul><h2 id="如何创建一个静态方法？"><a href="#如何创建一个静态方法？" class="headerlink" title="如何创建一个静态方法？"></a>如何创建一个静态方法？</h2><ul><li>在方法中加<code>static</code>修饰，那么这个方法是静态方法（函数）<blockquote><p>在载入类的时候就这个方法就已经在类的<code>静态区</code>创建，不需要创建对象即可调用</p></blockquote></li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li>在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。<blockquote><p>比如</p><p>第一条命令给这个变量赋值“<code>张三</code>”</p><p>第二条命令又给这个变量赋值“<code>李四</code>”</p><p>那么之后调用这个变量时，这个变量返回“<code>李四</code>”</p></blockquote></li></ul><h1 id="二、构造方法-与-代码块"><a href="#二、构造方法-与-代码块" class="headerlink" title="二、构造方法 与 代码块"></a>二、构造方法 与 代码块</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果</p><blockquote><p>系统会自动创建<code>空参构造</code>，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出</p></blockquote></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><ul><li>它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率</li></ul><h4 id="构造代码块-初始化块"><a href="#构造代码块-初始化块" class="headerlink" title="构造代码块 (初始化块)"></a>构造代码块 (初始化块)</h4><ul><li>构造代码块可以在一个类中执行，执行完就弹栈，</li><li><p>例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Deom&#123;&#123;这就是构造代码块&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行</p></blockquote></li><li><p>构造代码块可以把一些<code>初始化的代码</code>放在其中，<code>每次调用构造都执行</code>，并且<code>在构造方法之前执行</code></p><blockquote><p>ps：实际上构造方法开发中用到的不多，但是面试可能会问</p></blockquote></li></ul><ul><li>构造代码块可以做的功能：<blockquote><p>我们可以做诸如统计创建对象的次数等功能。</p></blockquote></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li><p>例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：</p><blockquote><p>用于给类进行初始化，在<code>加载的时候就执行</code>，并且<code>只执行一次</code>。</p><p>一般用于<code>加载驱动</code>，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。</p><p>比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。</p></blockquote></li><li><p><code>注意事项：</code></p><blockquote><p>1、静态代码块不能访问普通变量</p><p>2、静态代码块在 <code>类</code> 中，<code>优先于主方法</code>（<code>面试题</code>）</p><p>3、静态代码块 &gt; 构造代码块 &gt; 构造函数（方法）&gt; 普通代码块</p></blockquote></li></ul><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><blockquote><p>ps：继承与升级一般都用作系统升级</p><p><code>父类 &gt; 子类</code></p></blockquote><ul><li><p>继承的定义</p><blockquote><p><code>class 子类(当前类) extends 父类(继承的类)</code></p><p>ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法</p></blockquote></li><li><p>继承的好处：</p><blockquote><p>1、可以提升代码的复用性，不需要打太多重复的代码</p><p>2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错</p><p>3、是多态的前提</p></blockquote></li><li><p>继承的弊端：</p><blockquote><p>1、耦合性非常强，父类有的一些属性可能是子类不需要的</p></blockquote></li><li><p>开发原则：</p><blockquote><p><code>高内聚、低耦合</code></p><p>耦合：类与类的关系</p><p>内聚：自己完成某件事的能力</p></blockquote></li><li><p>在java中继承的特点：</p><blockquote><p>1、Java<code>只支持单继承</code>不支持多继承（一个孩子只能有一个爹）</p><p>2、<code>可以多层继承</code>（继承体系），也就是可以继承爷爷</p><p>3、想看这个体系<code>所有功能</code>就看最底层类，也就是儿子类</p><p>4、想看这个体系<code>共性功能</code>就要看顶层类，也就是爷爷类</p></blockquote></li><li><p>注意事项</p><blockquote><p>1、子类只能继承父类所有<code>非私有</code>的成员（方法和变量）</p><p>2、<code>子类不能继承父类的构造方法</code>，因为构造方法必须和类名一样，而继承是不一样的，但可以通过<code>super</code>关键字去访问父类的构造方法</p><p>3、<code>不要为了部分功能而去继承</code>，因为<code>继承体现的是一种关系</code>，就算有相同属性也不一定继承。</p><p>比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。</p><p>4、<code>子父类如果出现相同变量那么会采取就近原则</code>，但是在真正的项目开发中不会出现这种情况，因为没有意义</p><p>5、子类<code>无论如何</code>都会访问父类中的<code>构造方法</code></p><p>6、<code>在全是静态方法的类中，构造方法必须私有化</code>，这样防止别人创建这个类的对象</p></blockquote></li></ul><h4 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h4><ul><li>this：<blockquote><p>代表<code>当前对象的引用</code>，如果继承了父类，那么也可以引用父类</p></blockquote></li><li>super：<blockquote><p>代表<code>对父类的引用</code></p></blockquote></li></ul><ul><li><p>一些使用实例：</p><ul><li>this.成员变量名<blockquote><p>调用本类成员变量，也可以调用父类的，但是<code>采用就近原则</code></p></blockquote></li><li><p>super.成员变量名</p><blockquote><p>调用父类的成员变量</p></blockquote><p>ps：成员变量名可以是方法名</p></li><li><p>调用父类中的构造方法:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(...);</span><br></pre></td></tr></table></figure></li><li><p>调用本类中的构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this(...);</span><br></pre></td></tr></table></figure><p>ps：一个方法里只能调用其中的一个</p></li></ul></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>类中的构造方法系统都自带<code>super()；</code>但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以<code>super（参数1，参数2....）；</code>也可以用this调用本类的有参构造，进而间接调用父类有参构造</p></li><li><p><code>构造方法</code>的调用都是从上到下，即<code>从父类调用到子类</code>，可以理解为一个队列</p></li><li><p>继承中的面试</p><blockquote><p>1、假设有  <code>子类方法、子类、父类</code> 且其中都有一个num的变量，那么：<code>num</code>用方法中的变量，<code>this.num</code>调用本类中的变量，<code>super.num</code>调用父类中的变量</p><p>2、在继承中不要忘记了<code>每个构造方法都会有一个super（）；访问父类</code></p><p>3、override   重写：<code>子类中</code>出现了和<code>父类中方法声明一模一样的方法</code>。与返回值类型有关,返<code>回值类型是一致的</code></p><p>4、overload  重载：<code>本类中</code>出现的<code>方法名一样</code>，<code>参数列表不同</code>的方法。<code>与返回值类型无关</code>。</p></blockquote></li><li><p>继承中的成员方法关系</p><blockquote><p>、子、父类有相同方法并且返回值类型也一样，那么会<code>调用子类的方法</code>，也叫<code>方法重写</code></p></blockquote></li></ul><ul><li>final概述<ul><li>它可以用来修饰 <code>类与变量</code> 修饰之后表示它是<code>“最终的”</code>不能被继续操作了</li></ul></li></ul><ul><li>final修饰特点<ul><li>修饰类，类不能被继承</li><li>修饰变量：<code>变量</code>就变成了<code>常量</code>，<code>只能被赋值一次</code>，通常与<code>public static</code>配套使用</li><li>修饰方法：方法<code>不能被重写</code>，表示最终方法。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、静态方法与静态变量&quot;&gt;&lt;a href=&quot;#一、静态方法与静态变量&quot; class=&quot;headerlink&quot; title=&quot;一、静态方法与静态变量&quot;&gt;&lt;/a&gt;一、静态方法与静态变量&lt;/h1&gt;&lt;h2 id=&quot;静态方法&quot;&gt;&lt;a href=&quot;#静态方法&quot; class=&quot;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="面向对象" scheme="http://liuhaoan.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="代码块" scheme="http://liuhaoan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——java的五大内存区域</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94java%E7%9A%84%E4%BA%94%E5%A4%A7%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——java的五大内存区域/</id>
    <published>2019-04-05T15:40:17.000Z</published>
    <updated>2019-04-07T07:22:17.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大内存区域"><a href="#五大内存区域" class="headerlink" title="五大内存区域"></a>五大内存区域</h1><ul><li>堆</li><li>虚拟机栈</li><li>本地方法栈</li><li>方法区</li><li><p>寄存器区</p><blockquote><p>ps：我们主要用：虚拟机栈、方法区、堆</p></blockquote></li></ul><h1 id="Java程序运行过程"><a href="#Java程序运行过程" class="headerlink" title="Java程序运行过程"></a>Java程序运行过程</h1><ul><li>1、加载字节码文件到方法区（.class文件）</li><li>2、程序代码依次进栈（jvm执行main方法）</li></ul><h1 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h1><blockquote><p>最大的一块内存，存放对象实例的地方</p><ul><li>1、Java堆是垃圾收集器管理的主要区域，也称GC堆。</li><li>2、Java堆物理上可不连续，逻辑上连续。</li><li>3、堆中没有完成实例分配，并且对也无法在扩展时抛出 OutOfMemoryError异常</li></ul></blockquote><h1 id="虚拟机栈（stack）："><a href="#虚拟机栈（stack）：" class="headerlink" title="虚拟机栈（stack）："></a>虚拟机栈（stack）：</h1><blockquote><p>java方法执行时的内存模型</p></blockquote><ul><li>栈帧<blockquote><p>1、<code>每个方法</code>都会在虚拟机栈中创建一个对应的栈帧，用于存储<code>局部变量表</code>，<code>操作数栈</code>，<code>动态链接</code>，<code>方法出口</code>等信息。</p><p>2、一个方法的调用到结束就对应这一个栈帧从虚拟机栈<code>入栈到出栈</code>。</p></blockquote></li></ul><ul><li>局部变量表<blockquote><p>1、存放编译期可知在方法中各种<code>基本数据类型</code>和<code>对象</code>的引用，基本数据类型直接存值, 引用数据类型存地址。</p></blockquote></li></ul><p>#本地方法栈：</p><blockquote><p>本地方法栈和虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为jvm使用Native方法服务</p></blockquote><ul><li><p><code>本地方法</code> 关键字 <code>native</code> ，这些方法一般用来调用本地方法库中的方法这些方法，操作底层大多用C 实现。</p></li><li><p>有的虚拟机将<code>本地方法栈</code>和<code>虚拟机栈</code>合在一起，如<code>HotSpot</code>。</p></li></ul><h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><ul><li>存已经被虚拟机加载的类信息（Class对象）、<code>常量</code>、<code>静态变量</code>、即时编译器JIT编译过后的<code>代码数据</code>。</li><li><p>jdk <code>1.7</code>、1.8 对方法区做出了修改，1.8 取消了方法区。</p><blockquote><p>1、方法区被Java虚拟机规范描述为堆的一个逻辑部分，但它不是堆，有一个别名叫非堆Non-Heap</p><p>2、 jdk1.6 及之前方法区位于永久代(PermGen)，永久代和堆相互隔离。</p><p>3、方法区可以不需要连续的内存空间，也可以固定大小，也可以扩展，也可以不实现垃圾收集，如果实现则主要针对常量池的回收和类型的卸载。</p></blockquote></li><li><p>运行时常量池</p><blockquote><p>1、在方法区，用来存放编译期生成的各种符号引用和字面量</p><p>2、编译期将各种<code>符号引用</code>和<code>字面量</code>放置在class文件的常量池中，解析后在运行时常量池，字符串在方法区的字符串常量池中（1.7之前），方法运行时<code>复制</code>到局部变量表中。1.7开始字符串<code>常量池</code>被移入堆中。</p><p>符号引用： String ss = “asdsfg”  ss这个符号就是符号引用。解析阶段解析为直接引用</p><p>字面量： 值本身 如 asdfg</p><p>常量池中有各种虚拟机正常运行需要的字符串，所以有些即使不创建也还会存在于字符串常量池中如”java”。</p></blockquote></li></ul><h1 id="寄存器（程序计数器）："><a href="#寄存器（程序计数器）：" class="headerlink" title="寄存器（程序计数器）："></a>寄存器（程序计数器）：</h1><ul><li>占用较小的一块内存空间，当执行Java方法时<code>记录正在执行的虚拟机字节码指令地址</code>，如果执行Native方法则计时器值为空。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;五大内存区域&quot;&gt;&lt;a href=&quot;#五大内存区域&quot; class=&quot;headerlink&quot; title=&quot;五大内存区域&quot;&gt;&lt;/a&gt;五大内存区域&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="javaSE" scheme="http://liuhaoan.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——数据类型</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——数据类型/</id>
    <published>2019-04-05T12:47:43.000Z</published>
    <updated>2019-04-07T07:20:55.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本数据分为四大类"><a href="#基本数据分为四大类" class="headerlink" title="基本数据分为四大类"></a>基本数据分为四大类</h4><blockquote><p>重要：以后面试可能会问范围</p><p>注：通常在复制 long  float类型时都价格标识符 ，即 L 与 f 。这样不会因为数据类型而出错double类型也可以在后面加D</p></blockquote><ul><li>整数型（整数常亮默认为int类型）<ul><li><code>byte</code>：占一个字节   <code>-128</code> ~ <code>127</code></li><li><code>short</code>：占两个字节   <code>-2^15</code> ~ <code>2^15-1</code></li><li><code>int</code>：占四个字节   <code>-2^31</code> ~ <code>2^31-1</code></li><li><code>long</code>：占八个字节   <code>-2^63</code> ~ <code>2^63-1</code></li></ul></li></ul><ul><li>浮点型（小数型，默认小数是double类型）<ul><li><code>float</code>：占<code>四个字节</code><blockquote><p>-2^128 ~ 2^128        绝对保证精度6位，但有7位有效数字</p></blockquote></li><li><code>double</code>：占<code>八个字节</code><blockquote><p>-2^1024 ~ 2^1024        绝对保证精度15位，但有16位有效数字</p></blockquote></li></ul></li></ul><ul><li>字符型<ul><li><code>char</code>：占两个字节   0 ~ 65535</li></ul></li></ul><ul><li>布尔型（判断）<ul><li><code>boolean</code>：理论<code>八分之一字节</code>，因为只要0和1就能分别决定false和true了，但是boolean并没有明确指定大小</li></ul></li></ul><blockquote><p>ps：<code>float</code>由32个二进制位组成，1位代表符号、8位代表指数位 00000000-11111111 同等与 0 - 255 其中 255代表无穷大，指数范围就是-126 ~ 127这比long的63大，所以float虽然才四个字节但是比long范围大</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本数据分为四大类&quot;&gt;&lt;a href=&quot;#基本数据分为四大类&quot; class=&quot;headerlink&quot; title=&quot;基本数据分为四大类&quot;&gt;&lt;/a&gt;基本数据分为四大类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;重要：以后面试可能会问范围&lt;/p&gt;
&lt;p&gt;注：通常在复制 
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="数据类型" scheme="http://liuhaoan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javaSE复习之——进制编码</title>
    <link href="http://liuhaoan.github.io/2019/04/05/javaSE%E5%A4%8D%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    <id>http://liuhaoan.github.io/2019/04/05/javaSE复习之——进制编码/</id>
    <published>2019-04-05T12:27:44.000Z</published>
    <updated>2019-04-07T07:22:00.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h2><ul><li><p>二进制向右移动两位 ：15 &gt;&gt; 2 = 3</p><ul><li>ps：1111 向右移动两位 等于 0011 = 3</li></ul></li><li><p>二进制向左移动两位 ：15 &lt;&lt; 2 = 60</p><ul><li>ps：1111 向左移动两位 等于 111100 = 60</li></ul></li><li><p>异或运算 ：2 ^ 3 = 1</p><ul><li>例子：0010 ^ 0011 = 0001<blockquote><p>ps：也就是相同为0不同为1，当0001^0011或者0001^0010时都能得出另一个数，和乘法除法运算一样</p></blockquote></li></ul></li><li><p>与运算 ：2 &amp; 3 = 2</p><ul><li>例子：0010 &amp; 0011=0010<blockquote><p>“与”运算中也是二进制位的运算，只要有一个是0那么结果就是0</p></blockquote></li></ul></li></ul><h2 id="java中的数据表示法"><a href="#java中的数据表示法" class="headerlink" title="java中的数据表示法"></a>java中的数据表示法</h2><ul><li>在java中数据前面加  0x表示16进制   0b表示二进制   0表示8进制</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote><p>任何进制转10进制都是    每一位  第某位的数据 乘 被转换的进制数 的 第某位索引次幂  相加</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="八转10："><a href="#八转10：" class="headerlink" title="八转10："></a>八转10：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0120=1 * 8 ^ 2 + 2 * 8 ^ 1 + 0 * 8 ^ 0 = 80</span><br></pre></td></tr></table></figure><blockquote><p>10进制转任何进制都是    除 要转换的进制数 然后取余数，以此类推，最后得出的数据为：进制数从左到右 = 余数列表的从下到上</p></blockquote><h4 id="2、8互转与2、16互转方法："><a href="#2、8互转与2、16互转方法：" class="headerlink" title="2、8互转与2、16互转方法："></a>2、8互转与2、16互转方法：</h4><blockquote><ul><li>2转8 = 3位一组转8<ul><li>8转2 = 每一位转2</li></ul></li><li>2转16 = 4位一组转16    <ul><li>16转2 = 每一位转2</li></ul></li></ul></blockquote><h4 id="二进制快速转换10进制方法："><a href="#二进制快速转换10进制方法：" class="headerlink" title="二进制快速转换10进制方法："></a>二进制快速转换10进制方法：</h4><blockquote><ul><li>二进制：<code>1    1    1    1    1    1    1    1</code></li><li>十进制：<code>128    64    32    16    8    4    2    1</code></li></ul></blockquote><h4 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法:"></a>二进制表示法:</h4><blockquote><p>符号位0为正，1为负</p></blockquote><h4 id="计算机二进制运算原理"><a href="#计算机二进制运算原理" class="headerlink" title="计算机二进制运算原理"></a>计算机二进制运算原理</h4><blockquote><p>计算机二进制运算都是用补码</p></blockquote><ul><li><p>例子：</p><blockquote><p>+7 的原码是 0 0000111</p></blockquote></li><li><p>ps：正数的、原码、反码、补码都一样</p></li></ul><blockquote><p>-7 的原码为 1 0000111</p><p>反码为 1 1111000 （符号位不变）</p><p>补码为 1 1111001（在反码的基础上加1）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进制的运算&quot;&gt;&lt;a href=&quot;#进制的运算&quot; class=&quot;headerlink&quot; title=&quot;进制的运算&quot;&gt;&lt;/a&gt;进制的运算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制向右移动两位 ：15 &amp;gt;&amp;gt; 2 = 3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps：1111
      
    
    </summary>
    
      <category term="JavaSE 复习" scheme="http://liuhaoan.github.io/categories/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="进制编码" scheme="http://liuhaoan.github.io/tags/%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://liuhaoan.github.io/2019/04/04/hello-world/"/>
    <id>http://liuhaoan.github.io/2019/04/04/hello-world/</id>
    <published>2019-04-04T14:54:30.247Z</published>
    <updated>2019-04-04T14:54:30.247Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
