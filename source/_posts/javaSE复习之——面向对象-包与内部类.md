---
title: javaSE复习之——面向对象_包与内部类
categories: JavaSE 复习
copyright: true
date: 2019-04-07 17:55:53
tags:
- 面向对象
- 包
- 内部类
- 链式编程
---
# 包的意义
> 我们以后开发程序都是把源码写在一个个的`源文件`里面，而不是`在一个文件中创建很多的类`，包的用处就在这里，说白了包就是为了封装。

# 定义包的格式
```
	package 包名;
	多级包用“.”分开
```
- 例子：
```
package java.util.Scanner;
```
	在这里当然也可以把`Scanner`用`*`代替，`*`就是通配符，表示该目录下的所有包，但是效率没有导入具体的类高，因为*需要遍历该包所有类。
	ps：在开发中一般都不使用*，而是导入`具体的类`。

# 定义时的注意事项
> 1、必须是程序的`第一条`可执行语句
> 2、`package`在一个java文件中`只能有一个`
> 3、包名的格式为域名倒写
> - 例：com.aikan0.add
> 这个add就是这个包的作用。


# 生成包命令
```
	javac -d  . 源文件名
```
- ps：了解一下就好了


# 面试题——package、import、class有没有顺序关系？
- 解答：
	> 有，并且`package > import > class`


# 权限修饰符
- 四种权限修饰符

| 本类 | 同一个包下(子类和无关类) | 不同包下(子类) | 不同包下(无关类)
- | - | - | - |
private | Y |  |  |  
默认 | Y | Y |  |  
protected | Y | Y | Y |  
public | Y | Y | Y | Y 

> ps：`protected`表示受保护的，就是保护权限只给给自己的子类，一般不用在`变量`，而是用在`成员变量`或者`成员方法`。


# 内部类的面试题之 —— `内部类`能不能访问`外部类`成员变量：
- 答：
	> `内部类`可以访问`外部类`的成员变量，因为编译器底层在创建内部类时，为成员变量加上了指向外部类的引用

- 内部类访问外部类底层实现原理：
> 1、编译器会自动给内部类添加一个`隐藏的成员变量`，这个成员变量类型和`外部类类型相同`，这个成员变量就是`指向外部类对象的引用`
> 
> 2、编译器会自动创建一个`隐藏的有参构造`并且它有一个参数，那个参数的类型就是`外部类`的类型
> 
> 3、当创建内部类的实例时，系统会调用`隐藏的有参构造`初始化这个内部类的实例，而有参构造传入的数据就是`对外部类实例`的引用，然后把`对外部类实例`的引用传给那个`隐藏的成员变量`，我们对外部类中的成员进行访问时都是通过这个`隐藏的成员变量`
> 
> 引用自：[https://blog.csdn.net/weixin_39214481/article/details/80372676](https://blog.csdn.net/weixin_39214481/article/details/80372676 "https://blog.csdn.net/weixin_39214481/article/details/80372676")

- 在jdk8之前，内部类访问外部类成员变量，那么外部类的那个变量就需要用`final`修饰
- jdk8新特性
	> 内部类访问外部类成员变量，外部类那个变量`不需要`final修饰了，但其实底层是给`隐藏的成员变量`加了final修饰的,只是个“语法糖”，只要有对这个成员变量修改的操作，还是会强制要求final修饰的。
	> 

- 为什么需要使用final修饰？
	- 答：
	> - 情况一：当调用方法时，局部变量如果没有用final修饰，它的生命周期和方法的`生命周期`是一样的，当方法弹栈，这个`局部变量也会消失`，那么如果`局部内部类对象`还没有马上消失，它想用这个局部变量的时候就没有了。
	> 
	> - 情况二：如果引用值发生改变，那么就会产生`数据不一致`的问题，例如`外部类方法`修改了这个变量，那么就会导致`外部类`成员变量与`内部类`得到的值不一样，于是让final来让该引用不可变。



# 匿名内部类
- 格式：

```
//如果是类那么就代表继承这个类，是抽象类那么就是实现这个抽象方法
new 类名或者抽象类名() {		

}.方法名（）
//.方法名()可有无，只是加上可以直接调用匿名内部类中的方法
```

- 解释：
	> 可以吧`new 到  }` 的代码看作创建的一个子类对象实例，所以后面可以`.方法名`调用

- 好处：
	> 可以不用声明一个类了，而且把代码都集成到了一起，可以使代码更加简洁。

- 注意事项：
	> 1、`匿名内部类`只针对重写`一个方法`使用，如果要一次性重写`多个方法`的话不使用，因为调用一次就要创建一次对象，这样就没必要使用匿名内部类了，如果要多次使用则`重新定义类`。
	> 
	> 2、匿名内部类可以当作参数传递，本质是把匿名内部类看作一个子类对象。
	> 
	> 3、匿名内部类中不能定义构造函数。
	> 
	> 4、使用匿名内部类时，我们必须是`继承一个类`或者`实现一个接口`，但是两者不可兼得，只能继承一个类或者实现一个接口。
	> 
	> 5、匿名内部类中不能存在任何的静态成员变量和静态方法。
	> 
	> 6、匿名内部类`属于`局部内部类，所以局部内部类`所有限制`都在匿名内部类上生效
	> 
	> 7、匿名内部类不能是抽象的，它`必须实现`继承的类或者接口中的抽象方法

# 链式编程：
- 特点：
	> 调用方法后还能调用方法，也就是说调用第一个方法之后返回的是一个对象。