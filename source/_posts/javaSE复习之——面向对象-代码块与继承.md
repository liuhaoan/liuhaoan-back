---
title: javaSE复习之——面向对象_代码块与继承
categories: JavaSE 复习
date: 2019-04-06 10:08:03
copyright: true
tags: 
- 面向对象
- 代码块
---
# 一、静态方法与静态变量
## 静态方法
- 如果一个类中所有方法都是static静态的，那么需要在类中声明私有构造方法，目的是不让其他类创建本类对象

## 如何防止创建本类对象？
- 可以直接私有构造方法
	`private 类名（）{}`

## 如何创建一个静态方法？

- 在方法中加`static`修饰，那么这个方法是静态方法（函数）
	> 在载入类的时候就这个方法就已经在类的`静态区`创建，不需要创建对象即可调用

## 静态变量

- 在变量前加入static那么这个变量是静态变量，与上同理，不过这个变量是共享的。
	> 比如
	> 
	> 第一条命令给这个变量赋值“`张三`”
	> 
	> 第二条命令又给这个变量赋值“`李四`”
	> 
	> 那么之后调用这个变量时，这个变量返回“`李四`”

# 二、构造方法 与 代码块
## 构造方法
- 构造方法和类名相同，在创建这个类的对象的时候系统就会自动调用，也就是起到初始化的效果

	> 系统会自动创建`空参构造`，顶层的类系统自动继承object类，但是object类的构造方法没有任何输出


## 代码块
#### 局部代码块 
- 它在方法中出现；它可以限定变量生命周期，及早释放，提高内存利用率


#### 构造代码块 (初始化块)
- 构造代码块可以在一个类中执行，执行完就弹栈，
- 例：

	```
	class Deom{		{这就是构造代码块}	}
	```
	> ps：每次创建这个类的对象构造代码块就会执行一次，并且优先执行

- 构造代码块可以把一些`初始化的代码`放在其中，`每次调用构造都执行`，并且`在构造方法之前执行`
	> ps：实际上构造方法开发中用到的不多，但是面试可能会问


- 构造代码块可以做的功能：
	 > 我们可以做诸如统计创建对象的次数等功能。


#### 静态代码块
- 例：
	```
	static {}
	```
- 作用：
	> 用于给类进行初始化，在`加载的时候就执行`，并且`只执行一次`。
	> 
	> 一般用于`加载驱动`，一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。
	> 
	> 比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。

- `注意事项：`
	> 1、静态代码块不能访问普通变量
	> 
	> 2、静态代码块在 `类` 中，`优先于主方法`（`面试题`）
	> 
	> 3、静态代码块 > 构造代码块 > 构造函数（方法）> 普通代码块

#### 类的继承
> ps：继承与升级一般都用作系统升级
> 
> `父类 > 子类`

- 继承的定义
	> `class 子类(当前类) extends 父类(继承的类)`
	> 
	> ps：继承后调用子类等于调用父类，子类可以什么都不写，可以理解为：继承后子类相当于有了父类的方法

- 继承的好处：
	> 1、可以提升代码的复用性，不需要打太多重复的代码
	> 
	> 2、提升了代码的维护性，改一个代码就可以起到全局的作用，不容易出错
	> 
	> 3、是多态的前提

- 继承的弊端：
	> 1、耦合性非常强，父类有的一些属性可能是子类不需要的

- 开发原则：
	> `高内聚、低耦合`
	> 
	> 耦合：类与类的关系
	> 
	> 内聚：自己完成某件事的能力

- 在java中继承的特点：
	> 1、Java`只支持单继承`不支持多继承（一个孩子只能有一个爹）
	> 
	> 2、`可以多层继承`（继承体系），也就是可以继承爷爷
	> 
	> 3、想看这个体系`所有功能`就看最底层类，也就是儿子类
	> 
	> 4、想看这个体系`共性功能`就要看顶层类，也就是爷爷类

- 注意事项
	> 1、子类只能继承父类所有`非私有`的成员（方法和变量）
	> 
	> 2、`子类不能继承父类的构造方法`，因为构造方法必须和类名一样，而继承是不一样的，但可以通过`super`关键字去访问父类的构造方法
	> 
	> 3、`不要为了部分功能而去继承`，因为`继承体现的是一种关系`，就算有相同属性也不一定继承。
	> 
	> 比如：“猫”和“狗”的类，它们虽然都有4条腿，但是却不能继承，因为他们是同级关系，而不是父子关系，但比如有“动物”“猫”“狗”的类，那么“猫”和“狗”都可以继承“动物”的类。
	> 
	> 4、`子父类如果出现相同变量那么会采取就近原则`，但是在真正的项目开发中不会出现这种情况，因为没有意义
	> 
	> 5、子类`无论如何`都会访问父类中的`构造方法`
	> 
	> 6、`在全是静态方法的类中，构造方法必须私有化`，这样防止别人创建这个类的对象

#### this和super
- this：
	> 代表`当前对象的引用`，如果继承了父类，那么也可以引用父类
- super：
	> 代表`对父类的引用`


- 一些使用实例：
	- this.成员变量名
		> 调用本类成员变量，也可以调用父类的，但是`采用就近原则`
		> 
	- super.成员变量名
		> 调用父类的成员变量

	ps：成员变量名可以是方法名
		
	- 调用父类中的构造方法:
		```
		super(...);
		```

	- 调用本类中的构造方法:
```
		this(...);
```

	ps：一个方法里只能调用其中的一个


#### 注意事项
- 类中的构造方法系统都自带`super()；`但是被隐藏了，作用是访问父类的空参构造，如果父类没用空参构造，我们需要访问父类中的有参构造，那么就可以`super（参数1，参数2....）；`也可以用this调用本类的有参构造，进而间接调用父类有参构造

- `构造方法`的调用都是从上到下，即`从父类调用到子类`，可以理解为一个队列
		
- 继承中的面试
	> 1、假设有  `子类方法、子类、父类` 且其中都有一个num的变量，那么：`num`用方法中的变量，`this.num`调用本类中的变量，`super.num`调用父类中的变量
	> 
	> 2、在继承中不要忘记了`每个构造方法都会有一个super（）；访问父类`
	> 
	> 3、override   重写：`子类中`出现了和`父类中方法声明一模一样的方法`。与返回值类型有关,返`回值类型是一致的`
	> 
	> 4、overload  重载：`本类中`出现的`方法名一样`，`参数列表不同`的方法。`与返回值类型无关`。

- 继承中的成员方法关系
	> 、子、父类有相同方法并且返回值类型也一样，那么会`调用子类的方法`，也叫`方法重写`

* final概述
	* 它可以用来修饰 `类与变量` 修饰之后表示它是`“最终的”`不能被继续操作了


* final修饰特点
	* 修饰类，类不能被继承
	* 修饰变量：`变量`就变成了`常量`，`只能被赋值一次`，通常与`public static`配套使用
	* 修饰方法：方法`不能被重写`，表示最终方法。