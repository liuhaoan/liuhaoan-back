---
title: javaSE复习之——String类
categories: JavaSE 复习
copyright: true
date: 2019-04-09 15:42:02
tags:
- String类
---
# String类的概述
- 它的实例用来存储字符串，在平时的使用中我们会经常用到，通常初学者会以为它是一个`基本数据类型`，但其实它是一个`引用数据类型`.

<!--more-->
# String类特点：
- 1、String实际上是一个类，它重写了toString方法，所以创建String引用后`直接输出调用该引用的名称`就可以输出`字符串`数据。


- 2、String属于`引用数据类型`，而不是`基本数据类型`，基本数据类型为：int、char。。。，所以String数据对比需要用到`equals`方法，否则会出现判断不准确的问题


- 3、String没有set和get方法，所以它`不存在修改数据`，只能是`替换数据`，把之前的数据当作垃圾。


- 4、String s = "abc"	 与 String a = "abc"	它们两个变量其实是记录了`常量池中的地址值`，而常量池有个特性，就是`已有的数据它不会再去创建`，所以 `s==a为ture`


- 5、`String s = "a" + "b" + "c"`	同等于`String a = "abc"`	因为java有`常量优化机制`，java编译时已经确定`s = abc`，所以s拿到的是常量abc的地址。


- 6、

```
String b = "ab"
String c = "abc"
c == a + "c"
//结果为false
```
> 解析：因为`任何数据`与`字符串用 + 连接`，会在堆内存中创建`StringBuider` 或 `StringBuffer`缓冲区对象并使用append方法`把数据相连`，这里会得出：`"abc"`然后再使用toString方法`创建一个“abc”的String对象返回`这个"abc"被保存在`堆内存`中，而不是保存在`常量池`，所以变量c的值是`常量池`中的地址，而a + “c”是`堆内存`中的地址，所以用“==”号做比较返回false


- 7、String赋的值是`不可以被改变的`，只有把之前的值丢弃变成垃圾后，再赋新的值。


- 8、String虽然是`引用数据类型`，但是它当作参数传递的时候，它是和基本数据类型一样的。



# 获取键盘输入String需要注意的

> System.in
> 
> 它是标准的输入流，对应着键盘录入
> 
> sc.hasNextxxx（）
> 
> 它判断输入的数是不是xxx数据类型，xxx可以是int、double等
> 
> sc.nextxxx（）
> 
> 它获取已经输入的项，xxx和上面的xxx相同
> 
> sc.nextLine()
> 
> 它获取字符串，遇到/r/n就结束，也是因为这个机制，所以和其他获取输入命令混用会出现获取不到的问题，举个例子。
> 
> 例：nextInt() 之后又用 nexiLine()
> 
> 获取的是整数，而实际是全部内容为  `数值/r/n`  此命令只获取数值部分，所以留下了/r/n，然后nextLine见到上面这个/r/n就直接结束了。


- 解决方法：录入所有数据都用nextLine，然后通过数据转换来实现。



# String的构造方法
```
String str = new String(Byte[] b);
//有参构造
```
> 可以按照平台的默认字符集（也就是码表，GBK等等）`解码byte`数组，而gbk等码表都涵盖了ascii码表，而码表中98、99等代码都代表着ab等，所以解码后看到的和解码前的数据不一样。

```
String str = new String(Byte[] b,2,4);
//表示从b数组中的第二个索引开始解码，总共解码4个数据
```


# String类的判断功能
- .equals()
	> 比较字符串内容序列是否相同，区分大小写
- .equalsIgnoreCase()
	>与上面不同的是：不区分大小写
- .contains()
	>判断字符串中是否包含传入的字符串
- .startsWith()
	>判断字符串是否以传入字符串开头
- .endswith()
	>判断字符串是否以传入字符串结尾
- .isEmpty()	
	>判断字符串是否为空


# Null与""的区别
> ""是`字符串常量`，也是String类的对象，所以可以调用String类的方法
> 
> Null是`空常量`，不能调用任何方法，否则会出现空指针异常，Null可以给`任意引用数据类型`赋值。


- 注意事项：
	> 1、以后比较字符串时最好`都用equals`，因为equals比较的是内容，而==号比较的时后，有时比较的是`地址值`
	> 
	> 2、使用equals时，有常量就用常量对象的equals方法，`尽量不用变量对象的equals方法`，因为变量对象的值有`可能时null`，调用`equals方法会出现空指针异常`



# String类的获取功能
- .length()
	> 获取字符串长度(字符个数)	
	> 
	> 例子：`"我".length()` 为1
	> 
	> ps：数组中的length是`属性`，而String中的是对象`方法`
- .charAt()
	> 获取指定索引的字符
- .indexOf()	
	> 返回字符 或 字符串在此字符串中`第一次出现的索引`
	> 
	> 如果不存在返回-1
	> 
	> 如果查找的是字符串，返回索引就是查找字符串`第一个字符的索引`
- .indexOf(,)
	> 与上面不同的是在某个位置之后查找
- .lastIndexOf()	
	> 从后向前找
- .substring()
	> 从指定位置开始`截取字符串`，默认到末尾
- .substring(,)
	> 与上不同的是自己`指定了截取字符串的尾部位置`并且，`包含头不包含尾部`
	> 
	> 注意：截取字符串之后需要用一个变量来保存，因为substring是`不会改变原来的值`的。

# GBK码表的特性
> 1、中文是`两个字节`组成
> 
> 2、中文字节的`第一个字节一定是负数`


# String类的`类型转换`功能
- .getBytes()
	> 把`字符串转换成字节数组`，这是一个编码的过程：`把我们看的懂的编码成计算机看得懂的`
- .toCharArray()
	> 转换成字符数组
- String.valueOf（）
	> 把字符数组转换为字符串，传入一个字符数组，返回一个字符串
	> 
	> 注意：	
	> 
	> 1、传入的数组类型可以是`任意类型`，并且底层还是由String的`构造方法`来解码的。
	> 
	> 2、此方法可以传入任意object对象，如果传入的是一个对象，那么默认调用对象的toString方法
- .toLowerCase()
	> 把字符串转换为小写
- .toUpperase()
	> 把字符串转换为大写

ps：String中字符的转换都是按照unicode码表来转换的


# String的其他功能
- .repleace(被替换的字符串，要替换成的字符串)
	> 字符或字符串替换，不存在则不改变
- .trim()
	> 去除首尾空格
- .compareTo()
	> 按照字典顺序比较两个字符串